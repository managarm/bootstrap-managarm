From c8b7659ef1428dad62fbae1258c6b6962c96847e Mon Sep 17 00:00:00 2001
From: no92 <no92.mail@gmail.com>
Date: Fri, 28 Mar 2025 19:33:56 +0100
Subject: [PATCH 2/2] Add generated managarm bindings

---
 src/unix/linux_like/managarm/mod.rs | 4363 +++++++++++++++++++++++++++
 1 file changed, 4363 insertions(+)
 create mode 100644 src/unix/linux_like/managarm/mod.rs

diff --git a/src/unix/linux_like/managarm/mod.rs b/src/unix/linux_like/managarm/mod.rs
new file mode 100644
index 0000000..dd2dd9f
--- /dev/null
+++ b/src/unix/linux_like/managarm/mod.rs
@@ -0,0 +1,4363 @@
+// This file is autogenerated!
+// All changes made will be lost (eventually)!
+
+use crate::prelude::*;
+
+use crate::sighandler_t;
+
+pub type blkcnt64_t = i64;
+pub type rlimit64 = crate::rlimit;
+pub type rlim64_t = crate::rlim_t;
+pub type dirent64 = crate::dirent;
+pub type stat64 = crate::stat;
+pub type statfs64 = crate::statfs;
+pub type statvfs64 = crate::statvfs;
+pub type idtype_t = c_uint;
+pub const RTLD_DEFAULT: *mut c_void = 0i64 as *mut c_void;
+pub const RLIM_INFINITY: crate::rlim_t = !0;
+
+pub type Elf32_Half = u16;
+pub type Elf32_Word = u32;
+pub type Elf32_Off = u32;
+pub type Elf32_Addr = u32;
+
+pub type Elf64_Half = u16;
+pub type Elf64_Word = u32;
+pub type Elf64_Off = u64;
+pub type Elf64_Addr = u64;
+pub type Elf64_Xword = u64;
+
+s! {
+    pub struct Elf32_Phdr {
+        pub p_type: Elf32_Word,
+        pub p_offset: Elf32_Off,
+        pub p_vaddr: Elf32_Addr,
+        pub p_paddr: Elf32_Addr,
+        pub p_filesz: Elf32_Word,
+        pub p_memsz: Elf32_Word,
+        pub p_flags: Elf32_Word,
+        pub p_align: Elf32_Word,
+    }
+
+    pub struct Elf64_Phdr {
+        pub p_type: Elf64_Word,
+        pub p_flags: Elf64_Word,
+        pub p_offset: Elf64_Off,
+        pub p_vaddr: Elf64_Addr,
+        pub p_paddr: Elf64_Addr,
+        pub p_filesz: Elf64_Xword,
+        pub p_memsz: Elf64_Xword,
+        pub p_align: Elf64_Xword,
+    }
+}
+
+s! {
+    pub struct dl_phdr_info {
+        #[cfg(target_pointer_width = "64")]
+        pub dlpi_addr: Elf64_Addr,
+        #[cfg(target_pointer_width = "32")]
+        pub dlpi_addr: Elf32_Addr,
+
+        pub dlpi_name: *const c_char,
+
+        #[cfg(target_pointer_width = "64")]
+        pub dlpi_phdr: *const Elf64_Phdr,
+        #[cfg(target_pointer_width = "32")]
+        pub dlpi_phdr: *const Elf32_Phdr,
+
+        #[cfg(target_pointer_width = "64")]
+        pub dlpi_phnum: Elf64_Half,
+        #[cfg(target_pointer_width = "32")]
+        pub dlpi_phnum: Elf32_Half,
+
+        pub dlpi_adds: c_ulonglong,
+        pub dlpi_subs: c_ulonglong,
+        pub dlpi_tls_modid: size_t,
+        pub dlpi_tls_data: *mut c_void,
+    }
+}
+
+f! {
+    pub fn CMSG_NXTHDR(mhdr: *const msghdr, cmsg: *const cmsghdr) -> *mut cmsghdr {
+        if ((*cmsg).cmsg_len as usize) < mem::size_of::<cmsghdr>() {
+            return 0 as *mut cmsghdr;
+        };
+        let next = (cmsg as usize + super::CMSG_ALIGN((*cmsg).cmsg_len as usize)) as *mut cmsghdr;
+        let max = (*mhdr).msg_control as usize + (*mhdr).msg_controllen as usize;
+        if (next.offset(1)) as usize > max ||
+            next as usize + super::CMSG_ALIGN((*next).cmsg_len as usize) > max {
+            0 as *mut cmsghdr
+        } else {
+            next as *mut cmsghdr
+        }
+    }
+}
+
+pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t { size: [0; 16] };
+pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t { size: [0; 12] };
+pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t { size: [0; 12] };
+
+s_no_extra_traits! {
+    pub struct ifreq {
+        pub ifru_addr: crate::sockaddr,
+        pub ifru_dstaddr: crate::sockaddr,
+        pub ifru_broadaddr: crate::sockaddr,
+        pub ifru_netmask: crate::sockaddr,
+        pub ifru_hwaddr: crate::sockaddr,
+        pub ifru_flags: c_short,
+        pub ifru_ivalue: c_int,
+        pub ifru_mtu: c_int,
+        pub ifru_map: crate::ifmap,
+        pub ifru_slave: [c_char; 16],
+        pub ifru_newname: [c_char; 16],
+        pub ifru_data: *mut c_char,
+    }
+}
+
+impl fmt::Debug for ifreq {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        f.debug_struct("ifreq").finish()
+    }
+}
+
+safe_f! {
+    pub {const} fn makedev(major: c_uint, minor: c_uint) -> crate::dev_t {
+        let major = major as crate::dev_t;
+        let minor = minor as crate::dev_t;
+        let mut dev = 0;
+        dev |= (major & 0x00000fff) << 8;
+        dev |= (major & 0xfffff000) << 32;
+        dev |= (minor & 0x000000ff) << 0;
+        dev |= (minor & 0xffffff00) << 12;
+        dev
+    }
+}
+
+f! {
+    pub fn major(dev: crate::dev_t) -> c_uint {
+        let mut major = 0;
+        major |= (dev & 0x00000000000fff00) >> 8;
+        major |= (dev & 0xfffff00000000000) >> 32;
+        major as c_uint
+    }
+
+    pub fn minor(dev: crate::dev_t) -> c_uint {
+        let mut minor = 0;
+        minor |= (dev & 0x00000000000000ff) >> 0;
+        minor |= (dev & 0x00000ffffff00000) >> 12;
+        minor as c_uint
+    }
+}
+
+extern "C" {
+    #[link_name = "__gnu_strerror_r"]
+    pub fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: size_t) -> c_int;
+}
+
+#[repr(C)]
+struct __siginfo_fields {
+    fields: [c_int; 1],
+}
+
+impl siginfo_t {
+    unsafe fn sifields(&self) -> &__siginfo_fields {
+        &(*(self.__si_fields.as_ptr() as *const __siginfo_fields))
+    }
+
+    pub unsafe fn si_status(&self) -> c_int {
+        self.sifields().fields[0]
+    }
+}
+
+// abi-bits/access.h
+
+// abi-bits/auxv.h
+pub const AT_HWCAP: c_int = 16;
+pub const AT_SECURE: c_int = 23;
+pub const AT_RANDOM: c_int = 25;
+pub const AT_EXECFN: c_int = 31;
+pub const AT_SYSINFO_EHDR: c_int = 33;
+pub const AT_XPIPE: c_int = 0x1000;
+pub const AT_OPENFILES: c_int = 0x1001;
+pub const AT_FS_SERVER: c_int = 0x1102;
+pub const AT_MBUS_SERVER: c_int = 0x1103;
+
+// abi-bits/blkcnt_t.h
+pub type blkcnt_t = i64;
+
+// abi-bits/blksize_t.h
+pub type blksize_t = c_long;
+
+// abi-bits/clockid_t.h
+
+// abi-bits/dev_t.h
+pub type dev_t = u64;
+
+// abi-bits/epoll.h
+pub const EPOLL_CLOEXEC: c_int = 0o2000000;
+
+// abi-bits/errno.h
+pub const EPERM: c_int = 1;
+pub const ENOENT: c_int = 2;
+pub const ESRCH: c_int = 3;
+pub const EINTR: c_int = 4;
+pub const EIO: c_int = 5;
+pub const ENXIO: c_int = 6;
+pub const E2BIG: c_int = 7;
+pub const ENOEXEC: c_int = 8;
+pub const EBADF: c_int = 9;
+pub const ECHILD: c_int = 10;
+pub const EAGAIN: c_int = 11;
+pub const ENOMEM: c_int = 12;
+pub const EACCES: c_int = 13;
+pub const EFAULT: c_int = 14;
+pub const ENOTBLK: c_int = 15;
+pub const EBUSY: c_int = 16;
+pub const EEXIST: c_int = 17;
+pub const EXDEV: c_int = 18;
+pub const ENODEV: c_int = 19;
+pub const ENOTDIR: c_int = 20;
+pub const EISDIR: c_int = 21;
+pub const EINVAL: c_int = 22;
+pub const ENFILE: c_int = 23;
+pub const EMFILE: c_int = 24;
+pub const ENOTTY: c_int = 25;
+pub const ETXTBSY: c_int = 26;
+pub const EFBIG: c_int = 27;
+pub const ENOSPC: c_int = 28;
+pub const ESPIPE: c_int = 29;
+pub const EROFS: c_int = 30;
+pub const EMLINK: c_int = 31;
+pub const EPIPE: c_int = 32;
+pub const EDOM: c_int = 33;
+pub const ERANGE: c_int = 34;
+pub const EDEADLK: c_int = 35;
+pub const ENAMETOOLONG: c_int = 36;
+pub const ENOLCK: c_int = 37;
+pub const ENOSYS: c_int = 38;
+pub const ENOTEMPTY: c_int = 39;
+pub const ELOOP: c_int = 40;
+pub const EWOULDBLOCK: c_int = EAGAIN;
+pub const ENOMSG: c_int = 42;
+pub const EIDRM: c_int = 43;
+pub const ECHRNG: c_int = 44;
+pub const EL2NSYNC: c_int = 45;
+pub const EL3HLT: c_int = 46;
+pub const EL3RST: c_int = 47;
+pub const ELNRNG: c_int = 48;
+pub const EUNATCH: c_int = 49;
+pub const ENOCSI: c_int = 50;
+pub const EL2HLT: c_int = 51;
+pub const EBADE: c_int = 52;
+pub const EBADR: c_int = 53;
+pub const EXFULL: c_int = 54;
+pub const ENOANO: c_int = 55;
+pub const EBADRQC: c_int = 56;
+pub const EBADSLT: c_int = 57;
+pub const EDEADLOCK: c_int = EDEADLK;
+pub const EBFONT: c_int = 59;
+pub const ENOSTR: c_int = 60;
+pub const ENODATA: c_int = 61;
+pub const ETIME: c_int = 62;
+pub const ENOSR: c_int = 63;
+pub const ENONET: c_int = 64;
+pub const ENOPKG: c_int = 65;
+pub const EREMOTE: c_int = 66;
+pub const ENOLINK: c_int = 67;
+pub const EADV: c_int = 68;
+pub const ESRMNT: c_int = 69;
+pub const ECOMM: c_int = 70;
+pub const EPROTO: c_int = 71;
+pub const EMULTIHOP: c_int = 72;
+pub const EDOTDOT: c_int = 73;
+pub const EBADMSG: c_int = 74;
+pub const EOVERFLOW: c_int = 75;
+pub const ENOTUNIQ: c_int = 76;
+pub const EBADFD: c_int = 77;
+pub const EREMCHG: c_int = 78;
+pub const ELIBACC: c_int = 79;
+pub const ELIBBAD: c_int = 80;
+pub const ELIBSCN: c_int = 81;
+pub const ELIBMAX: c_int = 82;
+pub const ELIBEXEC: c_int = 83;
+pub const EILSEQ: c_int = 84;
+pub const ERESTART: c_int = 85;
+pub const ESTRPIPE: c_int = 86;
+pub const EUSERS: c_int = 87;
+pub const ENOTSOCK: c_int = 88;
+pub const EDESTADDRREQ: c_int = 89;
+pub const EMSGSIZE: c_int = 90;
+pub const EPROTOTYPE: c_int = 91;
+pub const ENOPROTOOPT: c_int = 92;
+pub const EPROTONOSUPPORT: c_int = 93;
+pub const ESOCKTNOSUPPORT: c_int = 94;
+pub const EOPNOTSUPP: c_int = 95;
+pub const ENOTSUP: c_int = EOPNOTSUPP;
+pub const EPFNOSUPPORT: c_int = 96;
+pub const EAFNOSUPPORT: c_int = 97;
+pub const EADDRINUSE: c_int = 98;
+pub const EADDRNOTAVAIL: c_int = 99;
+pub const ENETDOWN: c_int = 100;
+pub const ENETUNREACH: c_int = 101;
+pub const ENETRESET: c_int = 102;
+pub const ECONNABORTED: c_int = 103;
+pub const ECONNRESET: c_int = 104;
+pub const ENOBUFS: c_int = 105;
+pub const EISCONN: c_int = 106;
+pub const ENOTCONN: c_int = 107;
+pub const ESHUTDOWN: c_int = 108;
+pub const ETOOMANYREFS: c_int = 109;
+pub const ETIMEDOUT: c_int = 110;
+pub const ECONNREFUSED: c_int = 111;
+pub const EHOSTDOWN: c_int = 112;
+pub const EHOSTUNREACH: c_int = 113;
+pub const EALREADY: c_int = 114;
+pub const EINPROGRESS: c_int = 115;
+pub const ESTALE: c_int = 116;
+pub const EUCLEAN: c_int = 117;
+pub const ENOTNAM: c_int = 118;
+pub const ENAVAIL: c_int = 119;
+pub const EISNAM: c_int = 120;
+pub const EREMOTEIO: c_int = 121;
+pub const EDQUOT: c_int = 122;
+pub const ENOMEDIUM: c_int = 123;
+pub const EMEDIUMTYPE: c_int = 124;
+pub const ECANCELED: c_int = 125;
+pub const ENOKEY: c_int = 126;
+pub const EKEYEXPIRED: c_int = 127;
+pub const EKEYREVOKED: c_int = 128;
+pub const EKEYREJECTED: c_int = 129;
+pub const EOWNERDEAD: c_int = 130;
+pub const ENOTRECOVERABLE: c_int = 131;
+pub const ERFKILL: c_int = 132;
+pub const EHWPOISON: c_int = 133;
+pub const EIEIO: c_int = 4095;
+
+// abi-bits/fcntl.h
+pub const O_PATH: c_int = 0o10000000;
+pub const O_ACCMODE: c_int = 0o3 | O_PATH;
+pub const O_CREAT: c_int = 0o100;
+pub const O_EXCL: c_int = 0o200;
+pub const O_NOCTTY: c_int = 0o400;
+pub const O_TRUNC: c_int = 0o1000;
+pub const O_APPEND: c_int = 0o2000;
+pub const O_NONBLOCK: c_int = 0o4000;
+pub const O_DSYNC: c_int = 0o10000;
+pub const O_ASYNC: c_int = 0o20000;
+pub const O_DIRECT: c_int = 0o40000;
+pub const O_DIRECTORY: c_int = 0o200000;
+pub const O_NOFOLLOW: c_int = 0o400000;
+pub const O_CLOEXEC: c_int = 0o2000000;
+pub const O_SYNC: c_int = 0o4010000;
+pub const O_RSYNC: c_int = 0o4010000;
+pub const O_LARGEFILE: c_int = 0o100000;
+pub const O_NOATIME: c_int = 0o1000000;
+pub const O_TMPFILE: c_int = 0o20000000;
+pub const O_EXEC: c_int = O_PATH;
+pub const O_SEARCH: c_int = O_PATH;
+pub const F_SETOWN: c_int = 8;
+pub const F_GETOWN: c_int = 9;
+pub const F_SETSIG: c_int = 10;
+pub const F_GETSIG: c_int = 11;
+pub const F_GETLK: c_int = 5;
+pub const F_SETLK: c_int = 6;
+pub const F_SETLK64: c_int = F_SETLK;
+pub const F_SETLKW: c_int = 7;
+pub const F_SETLKW64: c_int = F_SETLKW;
+pub const F_SETOWN_EX: c_int = 15;
+pub const F_GETOWN_EX: c_int = 16;
+pub const F_GETOWNER_UIDS: c_int = 17;
+pub const F_OFD_GETLK: c_int = 36;
+pub const F_OFD_SETLK: c_int = 37;
+pub const F_OFD_SETLKW: c_int = 38;
+pub const F_RDLCK: c_int = 0;
+pub const F_WRLCK: c_int = 1;
+pub const F_UNLCK: c_int = 2;
+pub const AT_EACCESS: c_int = 0x200;
+pub const AT_STATX_SYNC_AS_STAT: c_int = 0x0000;
+pub const AT_STATX_FORCE_SYNC: c_int = 0x2000;
+pub const AT_STATX_DONT_SYNC: c_int = 0x4000;
+pub const AT_STATX_SYNC_TYPE: c_int = 0x6000;
+pub const F_OWNER_TID: c_int = 0;
+pub const POSIX_FADV_DONTNEED: c_int = 4;
+pub const POSIX_FADV_NOREUSE: c_int = 5;
+s! {
+    pub struct f_owner_ex {
+        pub r#type: c_int,
+        pub pid: crate::pid_t,
+    }
+}
+
+// abi-bits/fsblkcnt_t.h
+pub type fsblkcnt_t = u64;
+
+// abi-bits/fsfilcnt_t.h
+pub type fsfilcnt_t = u64;
+
+// abi-bits/gid_t.h
+
+// abi-bits/in.h
+pub const SOCK_STREAM: c_int = 1;
+pub const SOCK_DGRAM: c_int = 2;
+pub const SOCK_SEQPACKET: c_int = 5;
+pub const SOCK_DCCP: c_int = 6;
+pub const SOCK_PACKET: c_int = 10;
+pub const SOCK_NONBLOCK: c_int = 0o4000;
+pub const PF_LOCAL: c_int = 1;
+pub const PF_FILE: c_int = PF_LOCAL;
+pub const PF_IB: c_int = 27;
+pub const PF_MPLS: c_int = 28;
+pub const PF_NFC: c_int = 39;
+pub const PF_VSOCK: c_int = 40;
+pub const PF_KCM: c_int = 41;
+pub const PF_QIPCRTR: c_int = 42;
+pub const PF_SMC: c_int = 43;
+pub const PF_XDP: c_int = 44;
+pub const PF_MAX: c_int = 45;
+pub const AF_LOCAL: c_int = PF_LOCAL;
+pub const AF_FILE: c_int = AF_LOCAL;
+pub const AF_IB: c_int = PF_IB;
+pub const AF_MPLS: c_int = PF_MPLS;
+pub const AF_NFC: c_int = PF_NFC;
+pub const AF_VSOCK: c_int = PF_VSOCK;
+pub const AF_KCM: c_int = PF_KCM;
+pub const AF_QIPCRTR: c_int = PF_QIPCRTR;
+pub const AF_SMC: c_int = PF_SMC;
+pub const AF_XDP: c_int = PF_XDP;
+pub const AF_MAX: c_int = PF_MAX;
+pub const SO_REUSEADDR: c_int = 2;
+pub const SO_TYPE: c_int = 3;
+pub const SO_ERROR: c_int = 4;
+pub const SO_DONTROUTE: c_int = 5;
+pub const SO_BROADCAST: c_int = 6;
+pub const SO_SNDBUF: c_int = 7;
+pub const SO_RCVBUF: c_int = 8;
+pub const SO_KEEPALIVE: c_int = 9;
+pub const SO_OOBINLINE: c_int = 10;
+pub const SO_NO_CHECK: c_int = 11;
+pub const SO_PRIORITY: c_int = 12;
+pub const SO_LINGER: c_int = 13;
+pub const SO_BSDCOMPAT: c_int = 14;
+pub const SO_REUSEPORT: c_int = 15;
+pub const SO_PASSCRED: c_int = 16;
+pub const SO_PEERCRED: c_int = 17;
+pub const SO_RCVLOWAT: c_int = 18;
+pub const SO_SNDLOWAT: c_int = 19;
+pub const SO_ACCEPTCONN: c_int = 30;
+pub const SO_PEERSEC: c_int = 31;
+pub const SO_SNDBUFFORCE: c_int = 32;
+pub const SO_RCVBUFFORCE: c_int = 33;
+pub const SO_PROTOCOL: c_int = 38;
+pub const SO_DOMAIN: c_int = 39;
+pub const SO_RCVTIMEO: c_int = 20;
+pub const SO_SNDTIMEO: c_int = 21;
+pub const SO_TIMESTAMP: c_int = 29;
+pub const SO_TIMESTAMPNS: c_int = 35;
+pub const SO_TIMESTAMPING: c_int = 37;
+pub const SO_SECURITY_AUTHENTICATION: c_int = 22;
+pub const SO_SECURITY_ENCRYPTION_TRANSPORT: c_int = 23;
+pub const SO_SECURITY_ENCRYPTION_NETWORK: c_int = 24;
+pub const SO_BINDTODEVICE: c_int = 25;
+pub const SO_ATTACH_FILTER: c_int = 26;
+pub const SO_DETACH_FILTER: c_int = 27;
+pub const SO_GET_FILTER: c_int = SO_ATTACH_FILTER;
+pub const SO_PEERNAME: c_int = 28;
+pub const SO_PASSSEC: c_int = 34;
+pub const SCM_TIMESTAMPNS: c_int = SO_TIMESTAMPNS;
+pub const SO_MARK: c_int = 36;
+pub const SCM_TIMESTAMPING: c_int = SO_TIMESTAMPING;
+pub const SO_RXQ_OVFL: c_int = 40;
+pub const SO_WIFI_STATUS: c_int = 41;
+pub const SCM_WIFI_STATUS: c_int = SO_WIFI_STATUS;
+pub const SO_PEEK_OFF: c_int = 42;
+pub const SO_NOFCS: c_int = 43;
+pub const SO_LOCK_FILTER: c_int = 44;
+pub const SO_SELECT_ERR_QUEUE: c_int = 45;
+pub const SO_BUSY_POLL: c_int = 46;
+pub const SO_MAX_PACING_RATE: c_int = 47;
+pub const SO_BPF_EXTENSIONS: c_int = 48;
+pub const SO_INCOMING_CPU: c_int = 49;
+pub const SO_ATTACH_BPF: c_int = 50;
+pub const SO_DETACH_BPF: c_int = SO_DETACH_FILTER;
+pub const SO_ATTACH_REUSEPORT_CBPF: c_int = 51;
+pub const SO_ATTACH_REUSEPORT_EBPF: c_int = 52;
+pub const SO_CNX_ADVICE: c_int = 53;
+pub const SCM_TIMESTAMPING_OPT_STATS: c_int = 54;
+pub const SO_MEMINFO: c_int = 55;
+pub const SO_INCOMING_NAPI_ID: c_int = 56;
+pub const SO_COOKIE: c_int = 57;
+pub const SCM_TIMESTAMPING_PKTINFO: c_int = 58;
+pub const SO_PEERGROUPS: c_int = 59;
+pub const SO_ZEROCOPY: c_int = 60;
+pub const SO_TXTIME: c_int = 61;
+pub const SCM_TXTIME: c_int = SO_TXTIME;
+pub const SO_BINDTOIFINDEX: c_int = 62;
+pub const SO_DETACH_REUSEPORT_BPF: c_int = 68;
+pub const SOL_SOCKET: c_int = 1;
+pub const SOL_RXRPC: c_int = 272;
+pub const SOL_PPPOL2TP: c_int = 273;
+pub const SOL_PNPIPE: c_int = 275;
+pub const SOL_RDS: c_int = 276;
+pub const SOL_IUCV: c_int = 277;
+pub const SOL_CAIF: c_int = 278;
+pub const SOL_NFC: c_int = 280;
+pub const SOL_KCM: c_int = 281;
+pub const SOL_TLS: c_int = 282;
+pub const SOL_XDP: c_int = 283;
+pub const SOMAXCONN: c_int = 128;
+pub const MSG_PROXY: c_int = 0x0010;
+pub const MSG_BATCH: c_int = 0x40000;
+pub const MSG_ZEROCOPY: c_int = 0x4000000;
+pub const INET_ADDRSTRLEN: c_int = 16;
+pub const INET6_ADDRSTRLEN: c_int = 46;
+pub const IPPORT_RESERVED: c_int = 1024;
+pub const IPPROTO_MAX: c_int = 256;
+pub const IPV6_JOIN_GROUP: c_int = 20;
+pub const IPV6_LEAVE_GROUP: c_int = 21;
+pub type socklen_t = c_uint;
+s! {
+    pub struct iovec {
+        pub iov_base: *mut c_void,
+        pub iov_len: usize,
+    }
+}
+s! {
+    pub struct msghdr {
+        pub msg_name: *mut c_void,
+        pub msg_namelen: crate::socklen_t,
+        pub msg_iov: *mut  crate::iovec,
+        pub msg_iovlen: crate::size_t,
+        pub msg_control: *mut c_void,
+        pub msg_controllen: crate::size_t,
+        pub msg_flags: c_int,
+    }
+    pub struct cmsghdr {
+        pub cmsg_len: crate::size_t,
+        pub cmsg_level: c_int,
+        pub cmsg_type: c_int,
+    }
+    pub struct ipv6_mreq {
+        pub ipv6mr_multiaddr: crate::in6_addr,
+        pub ipv6mr_interface: c_uint,
+    }
+    pub struct in6_pktinfo {
+        pub ipi6_addr: crate::in6_addr,
+        pub ipi6_ifindex: u32,
+    }
+    pub struct group_req {
+        pub gr_interface: u32,
+        pub gr_group: crate::sockaddr_storage,
+    }
+    pub struct group_source_req {
+        pub gsr_interface: u32,
+        pub gsr_group: crate::sockaddr_storage,
+        pub gsr_source: crate::sockaddr_storage,
+    }
+}
+
+// abi-bits/ino_t.h
+pub type ino_t = u64;
+pub type ino64_t = crate::ino_t;
+
+// abi-bits/inotify.h
+pub const IN_CLOEXEC: c_int = O_CLOEXEC;
+pub const IN_NONBLOCK: c_int = O_NONBLOCK;
+
+// abi-bits/ioctls.h
+pub const TIOCEXCL: c_int = 0x540C;
+pub const TIOCNXCL: c_int = 0x540D;
+pub const SIOCPROTOPRIVATE: c_int = 0x89E0;
+pub const SIOCGSTAMP: c_int = 0x8906;
+pub const SIOCGIFNAME: c_int = 0x8910;
+pub const SIOCGIFCONF: c_int = 0x8912;
+pub const SIOCGIFFLAGS: c_int = 0x8913;
+pub const SIOCSIFFLAGS: c_int = 0x8914;
+pub const SIOCGIFADDR: c_int = 0x8915;
+pub const SIOCGIFINDEX: c_int = 0x8933;
+pub const SIOCATMARK: c_int = 0x8905;
+pub const SIOCGIFHWADDR: c_int = 0x8927;
+pub const SIOCGIFBRDADDR: c_int = 0x8919;
+pub const SIOCGIFNETMASK: c_int = 0x891B;
+
+// abi-bits/ipc.h
+pub const IPC_CREAT: c_int = 0o1000;
+pub const IPC_EXCL: c_int = 0o2000;
+pub const IPC_NOWAIT: c_int = 0o4000;
+pub const IPC_RMID: c_int = 0;
+pub const IPC_SET: c_int = 1;
+pub const IPC_STAT: c_int = 2;
+pub const IPC_INFO: c_int = 3;
+pub const IPC_64: c_int = 0;
+pub type mode_t = c_uint;
+s! {
+    pub struct ipc64_perm {
+        pub __ipc_perm_key: crate::key_t,
+        pub uid: crate::uid_t,
+        pub gid: crate::gid_t,
+        pub cuid: crate::uid_t,
+        pub cgid: crate::gid_t,
+        pub mode: crate::mode_t,
+        pub __ipc_perm_seq: c_int,
+        pub __unused: [c_long; 2],
+    }
+}
+
+// abi-bits/mode_t.h
+
+// abi-bits/mqueue.h
+s! {
+    pub struct mq_attr {
+        pub mq_flags: c_long,
+        pub mq_maxmsg: c_long,
+        pub mq_msgsize: c_long,
+        pub mq_curmsgs: c_long,
+        pub __pad: [c_long; 4],
+    }
+}
+
+// abi-bits/msg.h
+extern "C" {
+    pub fn ftok(__path: *const c_char, __proj_id: c_int) -> crate::key_t;
+}
+pub type time_t = c_long;
+pub type msglen_t = c_ulong;
+pub type msgqnum_t = c_ulong;
+s! {
+    pub struct msqid64_ds {
+        pub msg_perm: crate::ipc64_perm,
+        pub msg_stime: crate::time_t,
+        pub msg_rtime: crate::time_t,
+        pub msg_ctime: crate::time_t,
+        pub msg_cbytes: c_ulong,
+        pub msg_qnum: crate::msgqnum_t,
+        pub msg_qbytes: crate::msglen_t,
+        pub msg_lspid: crate::pid_t,
+        pub msg_lrpid: crate::pid_t,
+        pub __unused: [c_ulong; 2],
+    }
+}
+
+// abi-bits/nlink_t.h
+pub type nlink_t = c_ulong;
+
+// abi-bits/packet.h
+pub const PACKET_HOST: c_int = 0;
+
+// abi-bits/pid_t.h
+
+// abi-bits/poll.h
+pub const POLLWRNORM: c_short = 0x0100;
+pub const POLLWRBAND: c_short = 0x0200;
+
+// abi-bits/ptrace.h
+pub const PTRACE_PEEKTEXT: c_int = 1;
+pub const PTRACE_PEEKDATA: c_int = 2;
+pub const PTRACE_PEEKUSER: c_int = 3;
+pub const PTRACE_POKETEXT: c_int = 4;
+pub const PTRACE_POKEDATA: c_int = 5;
+pub const PTRACE_POKEUSER: c_int = 6;
+pub const PTRACE_CONT: c_int = 7;
+pub const PTRACE_KILL: c_int = 8;
+pub const PTRACE_SINGLESTEP: c_int = 9;
+pub const PTRACE_GETREGS: c_int = 12;
+pub const PTRACE_SETREGS: c_int = 13;
+pub const PTRACE_GETFPREGS: c_int = 14;
+pub const PTRACE_SETFPREGS: c_int = 15;
+pub const PTRACE_ATTACH: c_int = 16;
+pub const PTRACE_DETACH: c_int = 17;
+pub const PTRACE_GETFPXREGS: c_int = 18;
+pub const PTRACE_SETFPXREGS: c_int = 19;
+pub const PTRACE_SYSCALL: c_int = 24;
+pub const PTRACE_SETOPTIONS: c_int = 0x4200;
+pub const PTRACE_GETEVENTMSG: c_int = 0x4201;
+pub const PTRACE_GETSIGINFO: c_int = 0x4202;
+pub const PTRACE_SETSIGINFO: c_int = 0x4203;
+pub const PTRACE_GETREGSET: c_int = 0x4204;
+pub const PTRACE_SETREGSET: c_int = 0x4205;
+pub const PTRACE_SEIZE: c_int = 0x4206;
+pub const PTRACE_INTERRUPT: c_int = 0x4207;
+pub const PTRACE_LISTEN: c_int = 0x4208;
+pub const PTRACE_PEEKSIGINFO: c_int = 0x4209;
+pub const PTRACE_GETSIGMASK: c_int = 0x420A;
+pub const PTRACE_SETSIGMASK: c_int = 0x420B;
+pub const PTRACE_SECCOMP_GET_FILTER: c_int = 0x420C;
+pub const PTRACE_EVENT_STOP: c_int = 128;
+pub const PTRACE_PEEKSIGINFO_SHARED: c_int = 1;
+
+// abi-bits/random.h
+pub const GRND_NONBLOCK: c_int = 0x0001;
+pub const GRND_RANDOM: c_int = 0x0002;
+pub const GRND_INSECURE: c_int = 0x0004;
+
+// abi-bits/reboot.h
+pub const RB_AUTOBOOT: c_int = 0x01234567;
+pub const RB_HALT_SYSTEM: c_int = 0xcdef0123;
+pub const RB_ENABLE_CAD: c_int = 0x89abcdef;
+pub const RB_DISABLE_CAD: c_int = 0;
+pub const RB_POWER_OFF: c_int = 0x4321fedc;
+pub const RB_SW_SUSPEND: c_int = 0xd000fce2;
+pub const RB_KEXEC: c_int = 0x45584543;
+
+// abi-bits/resource.h
+pub const RUSAGE_CHILDREN: c_int = 1;
+pub const RLIMIT_CPU: c_int = 0;
+pub const RLIMIT_FSIZE: c_int = 1;
+pub const RLIMIT_DATA: c_int = 2;
+pub const RLIMIT_STACK: c_int = 3;
+pub const RLIMIT_CORE: c_int = 4;
+pub const RLIMIT_RSS: c_int = 5;
+pub const RLIMIT_NPROC: c_int = 6;
+pub const RLIMIT_NOFILE: c_int = 7;
+pub const RLIMIT_MEMLOCK: c_int = 8;
+pub const RLIMIT_AS: c_int = 9;
+pub const RLIMIT_LOCKS: c_int = 10;
+pub const RLIMIT_SIGPENDING: c_int = 11;
+pub const RLIMIT_MSGQUEUE: c_int = 12;
+pub const RLIMIT_NICE: c_int = 13;
+pub const RLIMIT_RTPRIO: c_int = 14;
+pub const RLIMIT_RTTIME: c_int = 15;
+pub const RLIMIT_NLIMITS: c_int = 16;
+pub type suseconds_t = c_long;
+s! {
+    pub struct timeval {
+        pub tv_sec: crate::time_t,
+        pub tv_usec: crate::suseconds_t,
+    }
+    pub struct rusage {
+        pub ru_utime: crate::timeval,
+        pub ru_stime: crate::timeval,
+        pub ru_maxrss: c_long,
+        pub ru_ixrss: c_long,
+        pub ru_idrss: c_long,
+        pub ru_isrss: c_long,
+        pub ru_minflt: c_long,
+        pub ru_majflt: c_long,
+        pub ru_nswap: c_long,
+        pub ru_inblock: c_long,
+        pub ru_oublock: c_long,
+        pub ru_msgsnd: c_long,
+        pub ru_msgrcv: c_long,
+        pub ru_nsignals: c_long,
+        pub ru_nvcsw: c_long,
+        pub ru_nivcsw: c_long,
+    }
+}
+
+// abi-bits/rlim_t.h
+pub type rlim_t = c_ulong;
+
+// abi-bits/seek-whence.h
+pub const SEEK_DATA: c_int = 3;
+pub const SEEK_HOLE: c_int = 4;
+
+// abi-bits/shm.h
+pub const _POSIX_VERSION: c_long = 200809;
+pub const _XOPEN_VERSION: c_int = 700;
+pub const _POSIX_JOB_CONTROL: c_int = 1;
+pub const _POSIX_SAVED_IDS: c_int = 1;
+pub const _POSIX_SHELL: c_int = 1;
+pub const _POSIX_MONOTONIC_CLOCK: c_int = 0;
+pub const _CS_PATH: c_int = 0;
+pub const _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS: c_int = 1;
+pub const _CS_GNU_LIBC_VERSION: c_int = 2;
+pub const _CS_GNU_LIBPTHREAD_VERSION: c_int = 3;
+pub const _CS_POSIX_V5_WIDTH_RESTRICTED_ENVS: c_int = 4;
+pub const _CS_POSIX_V7_WIDTH_RESTRICTED_ENVS: c_int = 5;
+pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: c_int = 1116;
+pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: c_int = 1117;
+pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: c_int = 1118;
+pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: c_int = 1119;
+pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: c_int = 1120;
+pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: c_int = 1121;
+pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: c_int = 1122;
+pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: c_int = 1123;
+pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: c_int = 1124;
+pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: c_int = 1125;
+pub const _CS_POSIX_V6_LP64_OFF64_LIBS: c_int = 1126;
+pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: c_int = 1127;
+pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: c_int = 1128;
+pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: c_int = 1129;
+pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: c_int = 1130;
+pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: c_int = 1131;
+pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: c_int = 1132;
+pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: c_int = 1133;
+pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: c_int = 1134;
+pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: c_int = 1135;
+pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: c_int = 1136;
+pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: c_int = 1137;
+pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: c_int = 1138;
+pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: c_int = 1139;
+pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: c_int = 1140;
+pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: c_int = 1141;
+pub const _CS_POSIX_V7_LP64_OFF64_LIBS: c_int = 1142;
+pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: c_int = 1143;
+pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: c_int = 1144;
+pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: c_int = 1145;
+pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: c_int = 1146;
+pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: c_int = 1147;
+pub const _CS_V6_ENV: c_int = 1148;
+pub const _CS_V7_ENV: c_int = 1149;
+pub const F_LOCK: c_int = 1;
+pub const F_TEST: c_int = 2;
+pub const F_TLOCK: c_int = 3;
+pub const F_ULOCK: c_int = 4;
+pub const _PC_LINK_MAX: c_int = 0;
+pub const _PC_MAX_CANON: c_int = 1;
+pub const _PC_MAX_INPUT: c_int = 2;
+pub const _PC_NAME_MAX: c_int = 3;
+pub const _PC_PATH_MAX: c_int = 4;
+pub const _PC_PIPE_BUF: c_int = 5;
+pub const _PC_CHOWN_RESTRICTED: c_int = 6;
+pub const _PC_NO_TRUNC: c_int = 7;
+pub const _PC_VDISABLE: c_int = 8;
+pub const _PC_FILESIZEBITS: c_int = 9;
+pub const _PC_SYMLINK_MAX: c_int = 10;
+pub const _SC_ARG_MAX: c_int = 0;
+pub const _SC_CHILD_MAX: c_int = 1;
+pub const _SC_CLK_TCK: c_int = 2;
+pub const _SC_NGROUPS_MAX: c_int = 3;
+pub const _SC_OPEN_MAX: c_int = 4;
+pub const _SC_STREAM_MAX: c_int = 5;
+pub const _SC_TZNAME_MAX: c_int = 6;
+pub const _SC_JOB_CONTROL: c_int = 7;
+pub const _SC_SAVED_IDS: c_int = 8;
+pub const _SC_REALTIME_SIGNALS: c_int = 9;
+pub const _SC_PRIORITY_SCHEDULING: c_int = 10;
+pub const _SC_TIMERS: c_int = 11;
+pub const _SC_ASYNCHRONOUS_IO: c_int = 12;
+pub const _SC_PRIORITIZED_IO: c_int = 13;
+pub const _SC_SYNCHRONIZED_IO: c_int = 14;
+pub const _SC_FSYNC: c_int = 15;
+pub const _SC_MAPPED_FILES: c_int = 16;
+pub const _SC_MEMLOCK: c_int = 17;
+pub const _SC_MEMLOCK_RANGE: c_int = 18;
+pub const _SC_MEMORY_PROTECTION: c_int = 19;
+pub const _SC_MESSAGE_PASSING: c_int = 20;
+pub const _SC_SEMAPHORES: c_int = 21;
+pub const _SC_SHARED_MEMORY_OBJECTS: c_int = 22;
+pub const _SC_AIO_LISTIO_MAX: c_int = 23;
+pub const _SC_AIO_MAX: c_int = 24;
+pub const _SC_AIO_PRIO_DELTA_MAX: c_int = 25;
+pub const _SC_DELAYTIMER_MAX: c_int = 26;
+pub const _SC_MQ_OPEN_MAX: c_int = 27;
+pub const _SC_MQ_PRIO_MAX: c_int = 28;
+pub const _SC_VERSION: c_int = 29;
+pub const _SC_PAGE_SIZE: c_int = 30;
+pub const _SC_PAGESIZE: c_int = _SC_PAGE_SIZE;
+pub const _SC_RTSIG_MAX: c_int = 31;
+pub const _SC_SEM_NSEMS_MAX: c_int = 32;
+pub const _SC_SEM_VALUE_MAX: c_int = 33;
+pub const _SC_SIGQUEUE_MAX: c_int = 34;
+pub const _SC_TIMER_MAX: c_int = 35;
+pub const _SC_BC_BASE_MAX: c_int = 36;
+pub const _SC_BC_DIM_MAX: c_int = 37;
+pub const _SC_BC_SCALE_MAX: c_int = 38;
+pub const _SC_BC_STRING_MAX: c_int = 39;
+pub const _SC_COLL_WEIGHTS_MAX: c_int = 40;
+pub const _SC_EXPR_NEST_MAX: c_int = 42;
+pub const _SC_LINE_MAX: c_int = 43;
+pub const _SC_RE_DUP_MAX: c_int = 44;
+pub const _SC_2_VERSION: c_int = 46;
+pub const _SC_2_C_BIND: c_int = 47;
+pub const _SC_2_C_DEV: c_int = 48;
+pub const _SC_2_FORT_DEV: c_int = 49;
+pub const _SC_2_FORT_RUN: c_int = 50;
+pub const _SC_2_SW_DEV: c_int = 51;
+pub const _SC_2_LOCALEDEF: c_int = 52;
+pub const _SC_IOV_MAX: c_int = 60;
+pub const _SC_UIO_MAXIOV: c_int = _SC_IOV_MAX;
+pub const _SC_THREADS: c_int = 67;
+pub const _SC_THREAD_SAFE_FUNCTIONS: c_int = 68;
+pub const _SC_GETGR_R_SIZE_MAX: c_int = 69;
+pub const _SC_GETPW_R_SIZE_MAX: c_int = 70;
+pub const _SC_LOGIN_NAME_MAX: c_int = 71;
+pub const _SC_TTY_NAME_MAX: c_int = 72;
+pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: c_int = 73;
+pub const _SC_THREAD_KEYS_MAX: c_int = 74;
+pub const _SC_THREAD_STACK_MIN: c_int = 75;
+pub const _SC_THREAD_THREADS_MAX: c_int = 76;
+pub const _SC_THREAD_ATTR_STACKADDR: c_int = 77;
+pub const _SC_THREAD_ATTR_STACKSIZE: c_int = 78;
+pub const _SC_THREAD_PRIORITY_SCHEDULING: c_int = 79;
+pub const _SC_THREAD_PRIO_INHERIT: c_int = 80;
+pub const _SC_THREAD_PRIO_PROTECT: c_int = 81;
+pub const _SC_THREAD_PROCESS_SHARED: c_int = 82;
+pub const _SC_NPROCESSORS_CONF: c_int = 83;
+pub const _SC_NPROCESSORS_ONLN: c_int = 84;
+pub const _SC_PHYS_PAGES: c_int = 85;
+pub const _SC_AVPHYS_PAGES: c_int = 86;
+pub const _SC_ATEXIT_MAX: c_int = 87;
+pub const _SC_PASS_MAX: c_int = 88;
+pub const _SC_XOPEN_VERSION: c_int = 89;
+pub const _SC_XOPEN_XCU_VERSION: c_int = 90;
+pub const _SC_XOPEN_UNIX: c_int = 91;
+pub const _SC_XOPEN_CRYPT: c_int = 92;
+pub const _SC_XOPEN_ENH_I18N: c_int = 93;
+pub const _SC_XOPEN_SHM: c_int = 94;
+pub const _SC_2_CHAR_TERM: c_int = 95;
+pub const _SC_2_UPE: c_int = 97;
+pub const _SC_XOPEN_XPG2: c_int = 98;
+pub const _SC_XOPEN_XPG3: c_int = 99;
+pub const _SC_XOPEN_XPG4: c_int = 100;
+pub const _SC_NZERO: c_int = 109;
+pub const _SC_XBS5_ILP32_OFF32: c_int = 125;
+pub const _SC_XBS5_ILP32_OFFBIG: c_int = 126;
+pub const _SC_XBS5_LP64_OFF64: c_int = 127;
+pub const _SC_XBS5_LPBIG_OFFBIG: c_int = 128;
+pub const _SC_XOPEN_LEGACY: c_int = 129;
+pub const _SC_XOPEN_REALTIME: c_int = 130;
+pub const _SC_XOPEN_REALTIME_THREADS: c_int = 131;
+pub const _SC_ADVISORY_INFO: c_int = 132;
+pub const _SC_BARRIERS: c_int = 133;
+pub const _SC_CLOCK_SELECTION: c_int = 137;
+pub const _SC_CPUTIME: c_int = 138;
+pub const _SC_THREAD_CPUTIME: c_int = 139;
+pub const _SC_MONOTONIC_CLOCK: c_int = 149;
+pub const _SC_READER_WRITER_LOCKS: c_int = 153;
+pub const _SC_SPIN_LOCKS: c_int = 154;
+pub const _SC_REGEXP: c_int = 155;
+pub const _SC_SHELL: c_int = 157;
+pub const _SC_SPAWN: c_int = 159;
+pub const _SC_SPORADIC_SERVER: c_int = 160;
+pub const _SC_THREAD_SPORADIC_SERVER: c_int = 161;
+pub const _SC_TIMEOUTS: c_int = 164;
+pub const _SC_TYPED_MEMORY_OBJECTS: c_int = 165;
+pub const _SC_2_PBS: c_int = 168;
+pub const _SC_2_PBS_ACCOUNTING: c_int = 169;
+pub const _SC_2_PBS_LOCATE: c_int = 170;
+pub const _SC_2_PBS_MESSAGE: c_int = 171;
+pub const _SC_2_PBS_TRACK: c_int = 172;
+pub const _SC_SYMLOOP_MAX: c_int = 173;
+pub const _SC_STREAMS: c_int = 174;
+pub const _SC_2_PBS_CHECKPOINT: c_int = 175;
+pub const _SC_V6_ILP32_OFF32: c_int = 176;
+pub const _SC_V6_ILP32_OFFBIG: c_int = 177;
+pub const _SC_V6_LP64_OFF64: c_int = 178;
+pub const _SC_V6_LPBIG_OFFBIG: c_int = 179;
+pub const _SC_HOST_NAME_MAX: c_int = 180;
+pub const _SC_TRACE: c_int = 181;
+pub const _SC_TRACE_EVENT_FILTER: c_int = 182;
+pub const _SC_TRACE_INHERIT: c_int = 183;
+pub const _SC_TRACE_LOG: c_int = 184;
+pub const L_ctermid: c_int = 20;
+pub const SHM_R: c_int = 0o400;
+pub const SHM_W: c_int = 0o200;
+pub const SHM_RDONLY: c_int = 0o10000;
+pub const SHM_RND: c_int = 0o20000;
+pub const SHM_REMAP: c_int = 0o40000;
+pub const SHM_EXEC: c_int = 0o100000;
+pub const SHM_LOCK: c_int = 11;
+pub const SHM_UNLOCK: c_int = 12;
+pub const SHM_STAT: c_int = 13;
+pub const SHM_INFO: c_int = 14;
+pub const SHM_STAT_ANY: c_int = 15;
+pub const SHM_DEST: c_int = 0o1000;
+pub const SHM_LOCKED: c_int = 0o2000;
+pub const SHM_HUGETLB: c_int = 0o4000;
+pub const SHM_NORESERVE: c_int = 0o10000;
+pub const SHM_HUGE_SHIFT: c_int = 26;
+pub const SHM_HUGE_MASK: c_int = 0x3f;
+pub const SHM_HUGE_64KB: c_int = 16 << 26;
+pub const SHM_HUGE_512KB: c_int = 19 << 26;
+pub const SHM_HUGE_1MB: c_int = 20 << 26;
+pub const SHM_HUGE_2MB: c_int = 21 << 26;
+pub const SHM_HUGE_8MB: c_int = 23 << 26;
+pub const SHM_HUGE_16MB: c_int = 24 << 26;
+pub const SHM_HUGE_32MB: c_int = 25 << 26;
+pub const SHM_HUGE_256MB: c_int = 28 << 26;
+pub const SHM_HUGE_512MB: c_int = 29 << 26;
+pub const SHM_HUGE_1GB: c_int = 30 << 26;
+pub const SHM_HUGE_2GB: c_int = 31 << 26;
+pub const SHM_HUGE_16GB: c_uint = 34 << 26;
+pub type off_t = c_long;
+pub type off64_t = c_long;
+extern "C" {
+    pub fn ctermid(__s: *mut c_char) -> *mut c_char;
+    pub fn endusershell();
+    pub fn faccessat(__fd: c_int, __path: *const c_char, __mode: c_int, __flags: c_int) -> c_int;
+    pub fn ftruncate64(__fd: c_int, __size: crate::off64_t) -> c_int;
+    pub fn gethostid() -> c_long;
+    pub fn sethostname(__buffer: *const c_char, __max_length: crate::size_t) -> c_int;
+    pub fn getlogin_r(__buffer: *mut c_char, __size: crate::size_t) -> c_int;
+    pub fn getpass(__prompt: *const c_char) -> *mut c_char;
+    pub fn getusershell() -> *mut c_char;
+    pub fn pread64(
+        __fd: c_int,
+        __buf: *mut c_void,
+        __size: crate::size_t,
+        __offset: crate::off_t,
+    ) -> crate::ssize_t;
+    pub fn pwrite64(
+        __fd: c_int,
+        __buf: *const c_void,
+        __size: crate::size_t,
+        __offset: crate::off_t,
+    ) -> crate::ssize_t;
+    pub fn setpgrp() -> crate::pid_t;
+    pub fn setusershell();
+    pub fn swab(__from: *const c_void, __to: *mut c_void, __size: crate::ssize_t);
+    pub fn sync();
+    pub fn truncate64(__path: *const c_char, __size: crate::off64_t) -> c_int;
+}
+pub type useconds_t = u64;
+extern "C" {
+    pub fn getpagesize() -> c_int;
+    pub fn get_current_dir_name() -> *mut c_char;
+    pub fn daemon(__nochdir: c_int, __noclose: c_int) -> c_int;
+    pub fn gettid() -> crate::pid_t;
+    pub fn getentropy(__buffer: *mut c_void, __size: crate::size_t) -> c_int;
+    pub fn getdomainname(__name: *mut c_char, __len: crate::size_t) -> c_int;
+    pub fn setdomainname(__name: *const c_char, __len: crate::size_t) -> c_int;
+    pub fn dup3(__fd: c_int, __newfd: c_int, __flags: c_int) -> c_int;
+    pub fn vhangup() -> c_int;
+    pub fn getdtablesize() -> c_int;
+    pub fn syncfs(__fd: c_int) -> c_int;
+}
+pub type shmatt_t = c_ulong;
+s! {
+    pub struct shmid_ds {
+        pub shm_perm: crate::ipc64_perm,
+        pub shm_segsz: crate::size_t,
+        pub shm_atime: crate::time_t,
+        pub shm_dtime: crate::time_t,
+        pub shm_ctime: crate::time_t,
+        pub shm_cpid: crate::pid_t,
+        pub shm_lpid: crate::pid_t,
+        pub shm_nattch: c_ulong,
+        pub __unused: [c_ulong; 2],
+    }
+    pub struct shminfo {
+        pub shmmax: c_ulong,
+        pub shmmin: c_ulong,
+        pub shmmni: c_ulong,
+        pub shmseg: c_ulong,
+        pub shmall: c_ulong,
+        pub __unused: [c_ulong; 4],
+    }
+    pub struct shm_info {
+        pub used_ids: c_int,
+        pub shm_tot: c_ulong,
+        pub shm_rss: c_ulong,
+        pub shm_swp: c_ulong,
+        pub swap_attempts: c_ulong,
+        pub swap_successes: c_ulong,
+    }
+}
+
+// abi-bits/sigevent.h
+s_no_extra_traits! {
+#[repr(C)]
+    pub union sigval {
+        pub sival_int: c_int,
+        pub sival_ptr: *mut c_void,
+    }
+}
+
+// abi-bits/signal.h
+pub const TIME_UTC: c_int = 1;
+pub const POLL_IN: c_int = 1;
+pub const POLL_OUT: c_int = 2;
+pub const POLL_MSG: c_int = 3;
+pub const POLL_ERR: c_int = 4;
+pub const POLL_PRI: c_int = 5;
+pub const POLL_HUP: c_int = 6;
+pub const SA_NOCLDSTOP: c_ulong = 1;
+pub const SA_NOCLDWAIT: c_ulong = 2;
+pub const SA_SIGINFO: c_ulong = 4;
+pub const SA_ONSTACK: c_ulong = 0x08000000;
+pub const SA_RESTART: c_ulong = 0x10000000;
+pub const SA_NODEFER: c_ulong = 0x40000000;
+pub const SA_RESETHAND: c_ulong = 0x80000000;
+pub const SA_RESTORER: c_int = 0x04000000;
+pub const SIGPROF: c_int = 27;
+pub const SIGIO: c_int = 29;
+pub const SIGPWR: c_int = 30;
+pub const SIG_BLOCK: c_int = 0;
+pub const SIG_UNBLOCK: c_int = 1;
+pub const SIG_SETMASK: c_int = 2;
+pub const SIGBUS: c_int = 7;
+pub const SIGUSR1: c_int = 10;
+pub const SIGUSR2: c_int = 12;
+pub const SIGSTKFLT: c_int = 16;
+pub const SIGCHLD: c_int = 17;
+pub const SIGCONT: c_int = 18;
+pub const SIGSTOP: c_int = 19;
+pub const SIGTSTP: c_int = 20;
+pub const SIGTTIN: c_int = 21;
+pub const SIGTTOU: c_int = 22;
+pub const SIGURG: c_int = 23;
+pub const SIGXCPU: c_int = 24;
+pub const SIGXFSZ: c_int = 25;
+pub const SIGVTALRM: c_int = 26;
+pub const SIGWINCH: c_int = 28;
+pub const SIGPOLL: c_int = 29;
+pub const SIGSYS: c_int = 31;
+pub const SIGUNUSED: c_int = SIGSYS;
+pub const SIGCANCEL: c_int = 32;
+pub const MINSIGSTKSZ: c_int = 2048;
+pub const SIGSTKSZ: c_int = 8192;
+pub const SIGEV_THREAD_ID: c_int = 4;
+pub const SEGV_MAPERR: c_int = 1;
+pub const SEGV_ACCERR: c_int = 2;
+pub const ILL_ILLOPC: c_int = 1;
+pub const ILL_ILLOPN: c_int = 2;
+pub const ILL_ILLADR: c_int = 3;
+pub const ILL_ILLTRP: c_int = 4;
+pub const ILL_PRVOPC: c_int = 5;
+pub const ILL_PRVREG: c_int = 6;
+pub const ILL_COPROC: c_int = 7;
+pub const ILL_BADSTK: c_int = 8;
+pub const ILL_BADIADDR: c_int = 9;
+pub const NSIG: c_int = 65;
+pub const SI_ASYNCNL: c_int = 60;
+pub const SI_TKILL: c_int = 6;
+pub const SI_SIGIO: c_int = 5;
+pub const SI_ASYNCIO: c_int = 4;
+pub const SI_MESGQ: c_int = 3;
+pub const SI_TIMER: c_int = 2;
+pub const SI_QUEUE: c_int = 1;
+pub const SI_USER: c_int = 0;
+pub const SI_KERNEL: c_int = 128;
+pub const REG_R8: c_int = 0;
+pub const REG_R9: c_int = 1;
+pub const REG_R10: c_int = 2;
+pub const REG_R11: c_int = 3;
+pub const REG_R12: c_int = 4;
+pub const REG_R13: c_int = 5;
+pub const REG_R14: c_int = 6;
+pub const REG_R15: c_int = 7;
+pub const REG_RDI: c_int = 8;
+pub const REG_RSI: c_int = 9;
+pub const REG_RBP: c_int = 10;
+pub const REG_RBX: c_int = 11;
+pub const REG_RDX: c_int = 12;
+pub const REG_RAX: c_int = 13;
+pub const REG_RCX: c_int = 14;
+pub const REG_RSP: c_int = 15;
+pub const REG_RIP: c_int = 16;
+pub const REG_EFL: c_int = 17;
+pub const REG_CSGSFS: c_int = 18;
+pub const REG_ERR: c_int = 19;
+pub const REG_TRAPNO: c_int = 20;
+pub const REG_OLDMASK: c_int = 21;
+pub const REG_CR2: c_int = 22;
+pub const NGREG: c_int = 23;
+pub const CPU_SETSIZE: c_int = 1024;
+pub const __MLIBC_THREAD_CREATE_JOINABLE: c_int = 0;
+pub const __MLIBC_THREAD_CREATE_DETACHED: c_int = 1;
+pub const __MLIBC_THREAD_MUTEX_DEFAULT: c_int = 0;
+pub const __MLIBC_THREAD_MUTEX_NORMAL: c_int = 0;
+pub const __MLIBC_THREAD_MUTEX_ERRORCHECK: c_int = 1;
+pub const __MLIBC_THREAD_MUTEX_RECURSIVE: c_int = 2;
+pub const __MLIBC_THREAD_PROCESS_PRIVATE: c_int = 0;
+pub const __MLIBC_THREAD_PROCESS_SHARED: c_int = 1;
+pub const __MLIBC_THREAD_MUTEX_STALLED: c_int = 0;
+pub const __MLIBC_THREAD_MUTEX_ROBUST: c_int = 1;
+pub const __MLIBC_THREAD_PRIO_NONE: c_int = 0;
+pub const __MLIBC_THREAD_PRIO_INHERIT: c_int = 1;
+pub const __MLIBC_THREAD_PRIO_PROTECT: c_int = 2;
+s! {
+    pub struct timespec {
+        pub tv_sec: crate::time_t,
+        pub tv_nsec: c_long,
+    }
+}
+pub type clock_t = c_long;
+extern "C" {
+    pub fn clock() -> crate::clock_t;
+    pub fn timespec_get(__ptr: *mut crate::timespec, __base: c_int) -> c_int;
+    pub fn asctime(__ptr: *const crate::tm) -> *mut c_char;
+    pub fn ctime(__timer: *const crate::time_t) -> *mut c_char;
+    pub fn strftime(
+        __dest: *mut c_char,
+        __max_size: crate::size_t,
+        __format: *const c_char,
+        __ptr: *const crate::tm,
+    ) -> crate::size_t;
+    pub fn tzset();
+}
+s! {
+    pub struct itimerspec {
+        pub it_interval: crate::timespec,
+        pub it_value: crate::timespec,
+    }
+}
+extern "C" {
+    pub fn timer_getoverrun(__timerid: crate::timer_t) -> c_int;
+    pub fn futimes(__fd: c_int, __tv: *const crate::timeval) -> c_int;
+    pub fn lutimes(__filename: *const c_char, __tv: *const crate::timeval) -> c_int;
+    pub fn timer_create(
+        __clockid: crate::clockid_t,
+        __sevp: *mut crate::sigevent,
+        __timerid: *mut crate::timer_t,
+    ) -> c_int;
+    pub fn timer_settime(
+        __timerid: crate::timer_t,
+        __flags: c_int,
+        __new_value: *const crate::itimerspec,
+        __old_value: *mut crate::itimerspec,
+    ) -> c_int;
+    pub fn timer_gettime(__timerid: crate::timer_t, __curr_value: *mut crate::itimerspec) -> c_int;
+    pub fn timer_delete(__timerid: crate::timer_t) -> c_int;
+}
+extern "C" {
+    pub fn clock_nanosleep(
+        __clockid: crate::clockid_t,
+        __flags: c_int,
+        __req: *const crate::timespec,
+        __rem: *mut crate::timespec,
+    ) -> c_int;
+    pub fn asctime_r(__tm: *const crate::tm, __buf: *mut c_char) -> *mut c_char;
+    pub fn ctime_r(__timer: *const crate::time_t, __buf: *mut c_char) -> *mut c_char;
+    pub fn strptime(
+        __buf: *const c_char,
+        __format: *const c_char,
+        __tm: *mut crate::tm,
+    ) -> *mut c_char;
+    pub fn timelocal(__tm: *mut crate::tm) -> crate::time_t;
+}
+s! {
+    pub struct siginfo_t {
+        pub si_signo: c_int,
+        pub si_errno: c_int,
+        pub si_code: c_int,
+        pub __si_fields: [c_char; 112],
+    }
+}
+pub type __sighandler = Option<unsafe extern "C" fn(c_int) -> c_void>;
+s! {
+    pub struct sigset_t {
+        pub sig: [c_ulong; 16],
+    }
+}
+s! {
+    pub struct __stack {
+        pub ss_sp: *mut c_void,
+        pub ss_flags: c_int,
+        pub ss_size: crate::size_t,
+    }
+}
+pub type stack_t = crate::__stack;
+pub type __cpu_mask = c_ulong;
+s! {
+    pub struct cpu_set_t {
+        pub __bits: [crate::__cpu_mask; 16],
+    }
+}
+s! {
+    pub struct __mlibc_thread_data {
+    }
+    pub struct __mlibc_threadattr {
+        pub __mlibc_guardsize: crate::size_t,
+        pub __mlibc_stacksize: crate::size_t,
+        pub __mlibc_stackaddr: *mut c_void,
+        pub __mlibc_detachstate: c_int,
+        pub __mlibc_scope: c_int,
+        pub __mlibc_inheritsched: c_int,
+        pub __mlibc_schedparam: crate::sched_param,
+        pub __mlibc_schedpolicy: c_int,
+        pub __mlibc_cpuset: *mut crate::cpu_set_t,
+        pub __mlibc_cpusetsize: crate::size_t,
+        pub __mlibc_sigmask: crate::sigset_t,
+        pub __mlibc_sigmaskset: c_int,
+    }
+    pub struct __mlibc_mutex {
+        #[doc(hidden)]
+        size: [u8; 16],
+    }
+    pub struct __mlibc_mutexattr {
+        pub __mlibc_type: c_int,
+        pub __mlibc_robust: c_int,
+        pub __mlibc_protocol: c_int,
+        pub __mlibc_pshared: c_int,
+        pub __mlibc_prioceiling: c_int,
+    }
+    pub struct __mlibc_cond {
+        #[doc(hidden)]
+        size: [u8; 12],
+    }
+    pub struct __mlibc_condattr {
+        pub __mlibc_pshared: c_int,
+        pub __mlibc_clock: crate::clockid_t,
+    }
+    pub struct sigaction {
+        pub sa_sigaction: sighandler_t,
+        pub sa_flags: c_ulong,
+        pub sa_restorer: Option<unsafe extern "C" fn() -> c_void>,
+        pub sa_mask: crate::sigset_t,
+    }
+    pub struct _fpreg {
+        pub significand: [c_ushort; 4],
+        pub exponent: c_ushort,
+    }
+    pub struct _fpxreg {
+        pub significand: [c_ushort; 4],
+        pub exponent: c_ushort,
+        pub padding: [c_ushort; 3],
+    }
+    pub struct _xmmreg {
+        pub element: [u32; 4],
+    }
+    pub struct _fpstate {
+        pub cwd: u16,
+        pub swd: u16,
+        pub ftw: u16,
+        pub fop: u16,
+        pub rip: u64,
+        pub rdp: u64,
+        pub mxcsr: u32,
+        pub mxcr_mask: u32,
+        pub _st: [crate::_fpxreg; 8],
+        pub _xmm: [crate::_xmmreg; 16],
+        pub padding: [u32; 24],
+    }
+    pub struct sigcontext {
+        pub r8: c_ulong,
+        pub r9: c_ulong,
+        pub r10: c_ulong,
+        pub r11: c_ulong,
+        pub r12: c_ulong,
+        pub r13: c_ulong,
+        pub r14: c_ulong,
+        pub r15: c_ulong,
+        pub rdi: c_ulong,
+        pub rsi: c_ulong,
+        pub rbp: c_ulong,
+        pub rbx: c_ulong,
+        pub rdx: c_ulong,
+        pub rax: c_ulong,
+        pub rcx: c_ulong,
+        pub rsp: c_ulong,
+        pub rip: c_ulong,
+        pub eflags: c_ulong,
+        pub cs: c_ushort,
+        pub gs: c_ushort,
+        pub fs: c_ushort,
+        pub __pad0: c_ushort,
+        pub err: c_ulong,
+        pub trapno: c_ulong,
+        pub oldmask: c_ulong,
+        pub cr2: c_ulong,
+        pub fpstate: *mut  crate::_fpstate,
+        pub __reserved1: [c_ulong; 8],
+    }
+    pub struct mcontext_t {
+        pub gregs: [c_ulong; 23],
+        pub fpregs: *mut  crate::_fpstate,
+        pub __reserved1: [c_ulong; 8],
+    }
+}
+s! {
+    pub struct __ucontext {
+        pub uc_flags: c_ulong,
+        pub uc_link: *mut  crate::__ucontext,
+        pub uc_stack: crate::stack_t,
+        pub uc_mcontext: crate::mcontext_t,
+        pub uc_sigmask: crate::sigset_t,
+    }
+}
+pub type ucontext_t = crate::__ucontext;
+
+// abi-bits/sigval.h
+
+// abi-bits/socket.h
+
+// abi-bits/socklen_t.h
+
+// abi-bits/stat.h
+s! {
+    pub struct stat {
+        pub st_dev: crate::dev_t,
+        pub st_ino: crate::ino_t,
+        pub st_nlink: crate::nlink_t,
+        pub st_mode: crate::mode_t,
+        pub st_uid: crate::uid_t,
+        pub st_gid: crate::gid_t,
+        pub __pad0: c_uint,
+        pub st_rdev: crate::dev_t,
+        pub st_size: crate::off_t,
+        pub st_blksize: crate::blksize_t,
+        pub st_blocks: crate::blkcnt_t,
+        pub st_atime: crate::time_t,
+        pub st_atime_nsec: i64,
+        pub st_mtime: crate::time_t,
+        pub st_mtime_nsec: i64,
+        pub st_ctime: crate::time_t,
+        pub st_ctime_nsec: i64,
+        pub __unused: [c_long; 3],
+    }
+}
+
+// abi-bits/statfs.h
+s! {
+    pub struct __mlibc_fsid {
+        pub __val: [c_int; 2],
+    }
+}
+pub type fsid_t = crate::__mlibc_fsid;
+s! {
+    pub struct statfs {
+        pub f_type: c_ulong,
+        pub f_bsize: c_ulong,
+        pub f_blocks: crate::fsblkcnt_t,
+        pub f_bfree: crate::fsblkcnt_t,
+        pub f_bavail: crate::fsblkcnt_t,
+        pub f_files: crate::fsfilcnt_t,
+        pub f_ffree: crate::fsfilcnt_t,
+        pub f_fsid: crate::fsid_t,
+        pub f_namelen: c_ulong,
+        pub f_frsize: c_ulong,
+        pub f_flags: c_ulong,
+        pub __f_spare: [c_ulong; 4],
+    }
+}
+
+// abi-bits/statvfs.h
+pub const ST_RDONLY: c_int = 1;
+pub const ST_NOSUID: c_int = 2;
+pub const ST_MANDLOCK: c_int = 64;
+s! {
+    pub struct statvfs {
+        pub f_bsize: c_ulong,
+        pub f_frsize: c_ulong,
+        pub f_blocks: crate::fsblkcnt_t,
+        pub f_bfree: crate::fsblkcnt_t,
+        pub f_bavail: crate::fsblkcnt_t,
+        pub f_files: crate::fsfilcnt_t,
+        pub f_ffree: crate::fsfilcnt_t,
+        pub f_favail: crate::fsfilcnt_t,
+        pub f_fsid: c_ulong,
+        pub f_flag: c_ulong,
+        pub f_namemax: c_ulong,
+    }
+}
+
+// abi-bits/statx.h
+pub const STATX_TYPE: c_int = 0x1;
+pub const STATX_MODE: c_int = 0x2;
+pub const STATX_NLINK: c_int = 0x4;
+pub const STATX_UID: c_int = 0x8;
+pub const STATX_GID: c_int = 0x10;
+pub const STATX_ATIME: c_int = 0x20;
+pub const STATX_MTIME: c_int = 0x40;
+pub const STATX_CTIME: c_int = 0x80;
+pub const STATX_INO: c_int = 0x100;
+pub const STATX_SIZE: c_int = 0x200;
+pub const STATX_BLOCKS: c_int = 0x400;
+pub const STATX_BASIC_STATS: c_int = 0x7ff;
+pub const STATX_BTIME: c_int = 0x800;
+pub const STATX_MNT_ID: c_int = 0x1000;
+pub const STATX_DIOALIGN: c_int = 0x2000;
+pub const STATX_ALL: c_int = 0xfff;
+pub const STATX_ATTR_COMPRESSED: c_int = 0x4;
+pub const STATX_ATTR_IMMUTABLE: c_int = 0x10;
+pub const STATX_ATTR_APPEND: c_int = 0x20;
+pub const STATX_ATTR_NODUMP: c_int = 0x40;
+pub const STATX_ATTR_ENCRYPTED: c_int = 0x800;
+pub const STATX_ATTR_AUTOMOUNT: c_int = 0x1000;
+pub const STATX_ATTR_MOUNT_ROOT: c_int = 0x2000;
+pub const STATX_ATTR_VERITY: c_int = 0x100000;
+pub const STATX_ATTR_DAX: c_int = 0x200000;
+s! {
+    pub struct statx_timestamp {
+        pub tv_sec: i64,
+        pub tv_nsec: u32,
+        pub __padding: u32,
+    }
+    pub struct statx {
+        pub stx_mask: u32,
+        pub stx_blksize: u32,
+        pub stx_attributes: u64,
+        pub stx_nlink: u32,
+        pub stx_uid: u32,
+        pub stx_gid: u32,
+        pub stx_mode: u16,
+        pub __padding: u16,
+        pub stx_ino: u64,
+        pub stx_size: u64,
+        pub stx_blocks: u64,
+        pub stx_attributes_mask: u64,
+        pub stx_atime: crate::statx_timestamp,
+        pub stx_btime: crate::statx_timestamp,
+        pub stx_ctime: crate::statx_timestamp,
+        pub stx_mtime: crate::statx_timestamp,
+        pub stx_rdev_major: u32,
+        pub stx_rdev_minor: u32,
+        pub stx_dev_major: u32,
+        pub stx_dev_minor: u32,
+        pub stx_mnt_id: u64,
+        pub stx_dio_mem_align: u32,
+        pub stx_dio_offset_align: u32,
+        pub __padding1: [u64; 12],
+    }
+}
+
+// abi-bits/suseconds_t.h
+
+// abi-bits/termios.h
+pub const NCCS: usize = 32;
+pub const VEOF: usize = 4;
+pub const VTIME: c_int = 5;
+pub const VMIN: c_int = 6;
+pub const VSWTC: c_int = 7;
+pub const VSTART: c_int = 8;
+pub const VSTOP: c_int = 9;
+pub const VSUSP: c_int = 10;
+pub const VEOL: c_int = 11;
+pub const VREPRINT: c_int = 12;
+pub const VDISCARD: c_int = 13;
+pub const VWERASE: c_int = 14;
+pub const VEOL2: c_int = 16;
+pub const IUCLC: c_uint = 0o001000;
+pub const IXON: c_uint = 0o002000;
+pub const IXOFF: c_uint = 0o010000;
+pub const IUTF8: crate::tcflag_t = 0o040000;
+pub const OLCUC: crate::tcflag_t = 0o000002;
+pub const ONLCR: crate::tcflag_t = 0o000004;
+pub const NLDLY: crate::tcflag_t = 0o000400;
+pub const CRDLY: crate::tcflag_t = 0o003000;
+pub const CR1: crate::tcflag_t = 0o001000;
+pub const CR2: crate::tcflag_t = 0o002000;
+pub const CR3: crate::tcflag_t = 0o003000;
+pub const TABDLY: crate::tcflag_t = 0o014000;
+pub const TAB1: crate::tcflag_t = 0o004000;
+pub const TAB2: crate::tcflag_t = 0o010000;
+pub const TAB3: crate::tcflag_t = 0o014000;
+pub const BSDLY: crate::tcflag_t = 0o020000;
+pub const BS1: crate::tcflag_t = 0o020000;
+pub const FFDLY: crate::tcflag_t = 0o100000;
+pub const FF1: crate::tcflag_t = 0o100000;
+pub const VTDLY: crate::tcflag_t = 0o040000;
+pub const VT1: crate::tcflag_t = 0o040000;
+pub const CSIZE: crate::tcflag_t = 0o000060;
+pub const CS6: crate::tcflag_t = 0o000020;
+pub const CS7: crate::tcflag_t = 0o000040;
+pub const CS8: crate::tcflag_t = 0o000060;
+pub const CSTOPB: crate::tcflag_t = 0o000100;
+pub const CREAD: crate::tcflag_t = 0o000200;
+pub const PARENB: crate::tcflag_t = 0o000400;
+pub const PARODD: crate::tcflag_t = 0o001000;
+pub const HUPCL: crate::tcflag_t = 0o002000;
+pub const CLOCAL: crate::tcflag_t = 0o004000;
+pub const ISIG: crate::tcflag_t = 0o000001;
+pub const ICANON: crate::tcflag_t = 0o000002;
+pub const ECHOE: crate::tcflag_t = 0o000020;
+pub const ECHOK: crate::tcflag_t = 0o000040;
+pub const ECHONL: crate::tcflag_t = 0o000100;
+pub const NOFLSH: crate::tcflag_t = 0o000200;
+pub const TOSTOP: crate::tcflag_t = 0o000400;
+pub const IEXTEN: crate::tcflag_t = 0o100000;
+pub const EXTA: c_int = 0o000016;
+pub const EXTB: c_int = 0o000017;
+pub const CBAUD: c_int = 0o010017;
+pub const CBAUDEX: c_int = 0o010000;
+pub const CIBAUD: c_int = 0o02003600000;
+pub const CMSPAR: crate::tcflag_t = 0o10000000000;
+pub const XCASE: c_int = 0o000004;
+pub const ECHOCTL: crate::tcflag_t = 0o001000;
+pub const ECHOPRT: crate::tcflag_t = 0o002000;
+pub const ECHOKE: crate::tcflag_t = 0o004000;
+pub const FLUSHO: crate::tcflag_t = 0o010000;
+pub const PENDIN: crate::tcflag_t = 0o040000;
+pub const EXTPROC: crate::tcflag_t = 0o200000;
+pub const XTABS: crate::tcflag_t = 0o014000;
+pub const NCC: c_int = 8;
+s! {
+    pub struct termios {
+        pub c_iflag: crate::tcflag_t,
+        pub c_oflag: crate::tcflag_t,
+        pub c_cflag: crate::tcflag_t,
+        pub c_lflag: crate::tcflag_t,
+        pub c_line: crate::cc_t,
+        pub c_cc: [crate::cc_t; 32],
+        pub ibaud: crate::speed_t,
+        pub obaud: crate::speed_t,
+    }
+    pub struct termio {
+        pub c_iflag: c_ushort,
+        pub c_oflag: c_ushort,
+        pub c_cflag: c_ushort,
+        pub c_lflag: c_ushort,
+        pub c_line: c_uchar,
+        pub c_cc: [c_uchar; 8],
+    }
+}
+
+// abi-bits/time.h
+pub const ITIMER_REAL: c_int = 0;
+pub const ITIMER_VIRTUAL: c_int = 1;
+pub const ITIMER_PROF: c_int = 2;
+s! {
+    pub struct itimerval {
+        pub it_interval: crate::timeval,
+        pub it_value: crate::timeval,
+    }
+}
+
+// abi-bits/uid_t.h
+
+// abi-bits/utsname.h
+
+// abi-bits/vm-flags.h
+pub const MAP_ANON: c_int = 0x20;
+pub const MAP_ANONYMOUS: c_int = 0x20;
+pub const MAP_GROWSDOWN: c_int = 0x100;
+pub const MAP_DENYWRITE: c_int = 0x800;
+pub const MAP_EXECUTABLE: c_int = 0x1000;
+pub const MAP_LOCKED: c_int = 0x2000;
+pub const MAP_NORESERVE: c_int = 0x4000;
+pub const MAP_POPULATE: c_int = 0x8000;
+pub const MAP_NONBLOCK: c_int = 0x10000;
+pub const MAP_STACK: c_int = 0x20000;
+pub const MAP_HUGETLB: c_int = 0x40000;
+pub const MAP_SYNC: c_int = 0x80000;
+pub const MAP_FIXED_NOREPLACE: c_int = 0x100000;
+pub const MCL_CURRENT: c_int = 0x01;
+pub const MCL_FUTURE: c_int = 0x02;
+pub const POSIX_MADV_NORMAL: c_int = 0;
+pub const POSIX_MADV_RANDOM: c_int = 1;
+pub const POSIX_MADV_SEQUENTIAL: c_int = 2;
+pub const POSIX_MADV_WILLNEED: c_int = 3;
+pub const POSIX_MADV_DONTNEED: c_int = 4;
+pub const MADV_SOFT_OFFLINE: c_int = 101;
+pub const MREMAP_MAYMOVE: c_int = 1;
+pub const MREMAP_FIXED: c_int = 2;
+pub const MFD_CLOEXEC: c_uint = 1;
+pub const MFD_ALLOW_SEALING: c_uint = 2;
+pub const MFD_HUGETLB: c_uint = 4;
+
+// alloca.h
+
+// arpa/inet.h
+pub const IN_CLASSA_NET: c_int = 0xff000000;
+pub const IN_CLASSA_NSHIFT: c_int = 24;
+pub const IN_CLASSA_MAX: c_int = 128;
+pub const IN_CLASSB_NET: c_int = 0xffff0000;
+pub const IN_CLASSB_NSHIFT: c_int = 16;
+pub const IN_CLASSB_MAX: c_int = 65536;
+pub const IN_CLASSC_NET: c_int = 0xffffff00;
+pub const IN_CLASSC_NSHIFT: c_int = 8;
+pub const IN_LOOPBACKNET: c_int = 127;
+s! {
+    pub struct linger {
+        pub l_onoff: c_int,
+        pub l_linger: c_int,
+    }
+    pub struct ucred {
+        pub pid: crate::pid_t,
+        pub uid: crate::uid_t,
+        pub gid: crate::gid_t,
+    }
+}
+extern "C" {
+    pub fn accept4(
+        __sockfd: c_int,
+        __addr: *mut crate::sockaddr,
+        __addrlen: *mut crate::socklen_t,
+        __flags: c_int,
+    ) -> c_int;
+    pub fn recvfrom(
+        __sockfd: c_int,
+        __buf: *mut c_void,
+        __size: crate::size_t,
+        __flags: c_int,
+        __src_addr: *mut crate::sockaddr,
+        __addrlen: *mut crate::socklen_t,
+    ) -> crate::ssize_t;
+    pub fn recvmmsg(
+        __sockfd: c_int,
+        __msgvec: *mut crate::mmsghdr,
+        __vlen: c_uint,
+        __flags: c_int,
+        __timeout: *mut crate::timespec,
+    ) -> c_int;
+    pub fn sendmmsg(
+        __sockfd: c_int,
+        __msgvec: *mut crate::mmsghdr,
+        __vlen: c_uint,
+        __flags: c_int,
+    ) -> c_int;
+    pub fn sockatmark(__sockfd: c_int) -> c_int;
+}
+extern "C" {
+    pub fn htonl(__x: u32) -> u32;
+    pub fn htons(__x: u16) -> u16;
+    pub fn ntohl(__x: u32) -> u32;
+    pub fn ntohs(__x: u16) -> u16;
+    pub fn inet_addr(__cp: *const c_char) -> crate::in_addr_t;
+    pub fn inet_network(__cp: *const c_char) -> crate::in_addr_t;
+    pub fn inet_ntoa(__in: crate::in_addr) -> *mut c_char;
+    pub fn inet_aton(__cp: *const c_char, __dest: *mut crate::in_addr) -> c_int;
+    pub fn inet_ntop(
+        __af: c_int,
+        __src: *const c_void,
+        __dst: *mut c_char,
+        __size: crate::socklen_t,
+    ) -> *const c_char;
+    pub fn inet_pton(__af: c_int, __src: *const c_char, __dst: *mut c_void) -> c_int;
+    pub fn inet_makeaddr(__net: crate::in_addr_t, __host: crate::in_addr_t) -> crate::in_addr;
+    pub fn inet_netof(__in: crate::in_addr) -> crate::in_addr_t;
+}
+
+// arpa/nameser_compat.h
+
+// assert.h
+
+// bits/ansi/fenv.h
+pub const FE_DENORMAL: c_int = 2;
+pub const FE_DIVBYZERO: c_int = 4;
+pub const FE_INEXACT: c_int = 32;
+pub const FE_INVALID: c_int = 1;
+pub const FE_OVERFLOW: c_int = 8;
+pub const FE_UNDERFLOW: c_int = 16;
+pub const FE_TONEAREST: c_int = 0;
+pub const FE_DOWNWARD: c_int = 0x400;
+pub const FE_UPWARD: c_int = 0x800;
+pub const FE_TOWARDZERO: c_int = 0xC00;
+
+// bits/ansi/time_t.h
+
+// bits/ansi/timespec.h
+
+// bits/bsd/bsd_stdlib.h
+extern "C" {
+    pub fn getloadavg(__loadavg: *mut c_double, __count: c_int) -> c_int;
+}
+
+// bits/bsd/bsd_unistd.h
+
+// bits/cpu_set.h
+
+// bits/ether_addr.h
+s! {
+    #[repr(packed)]
+    pub struct ether_addr {
+        pub ether_addr_octet: [u8; 6],
+    }
+}
+
+// bits/file.h
+
+// bits/glibc/glibc_icmp6.h
+pub const ND_OPT_SOURCE_LINKADDR: c_int = 1;
+pub const ND_OPT_TARGET_LINKADDR: c_int = 2;
+pub const ND_OPT_PREFIX_INFORMATION: c_int = 3;
+pub const ND_OPT_REDIRECTED_HEADER: c_int = 4;
+pub const ND_OPT_MTU: c_int = 5;
+pub const ND_OPT_RTR_ADV_INTERVAL: c_int = 7;
+pub const ND_OPT_HOME_AGENT_INFO: c_int = 8;
+
+// bits/glibc/glibc_malloc.h
+extern "C" {
+    pub fn malloc_usable_size(__ptr: *mut c_void) -> crate::size_t;
+}
+
+// bits/glibc/glibc_stdlib.h
+pub type comparison_fn_t = Option<unsafe extern "C" fn(*const c_void, *const c_void) -> c_int>;
+extern "C" {
+    pub fn rpmatch(__resp: *const c_char) -> c_int;
+}
+
+// bits/inline-definition.h
+
+// bits/linux/cpu_set.h
+pub const CHAR_BIT: c_int = 8;
+pub const MB_LEN_MAX: c_int = 4;
+pub const LONG_BIT: c_int = 64;
+pub const NAME_MAX: c_int = 255;
+pub const LINE_MAX: c_int = 4096;
+pub const CHARCLASS_NAME_MAX: c_int = 14;
+pub const RE_DUP_MAX: c_int = 255;
+pub const NGROUPS_MAX: c_int = 8;
+pub const NL_ARGMAX: c_int = 9;
+pub const _POSIX_ARG_MAX: c_int = 4096;
+pub const _POSIX_OPEN_MAX: c_int = 16;
+pub const _POSIX_HOST_NAME_MAX: c_int = 255;
+pub const _POSIX_NAME_MAX: c_int = 14;
+pub const _POSIX_TZNAME_MAX: c_int = 6;
+pub const _XOPEN_NAME_MAX: c_int = 255;
+pub const PTHREAD_STACK_MIN: usize = 16384;
+pub const PTHREAD_KEYS_MAX: c_int = 1024;
+pub type wchar_t = c_int;
+extern "C" {
+    pub fn rand() -> c_int;
+    pub fn rand_r(__seed: *mut c_uint) -> c_int;
+    pub fn srand(__seed: c_uint);
+    pub fn aligned_alloc(__alignment: crate::size_t, __size: crate::size_t) -> *mut c_void;
+    pub fn at_quick_exit(__func: Option<unsafe extern "C" fn() -> c_void>) -> c_int;
+    pub fn _Exit(__status: c_int);
+    pub fn quick_exit(__status: c_int);
+    pub fn mktemp(__pattern: *mut c_char) -> *mut c_char;
+    pub fn qsort_r(
+        __base: *mut c_void,
+        __nmemb: crate::size_t,
+        __size: crate::size_t,
+        __compar: Option<unsafe extern "C" fn(*const c_void, *const c_void, *mut c_void) -> c_int>,
+        __arg: *mut c_void,
+    );
+    pub fn abs(__number: c_int) -> c_int;
+    pub fn labs(__number: c_long) -> c_long;
+    pub fn llabs(__number: c_longlong) -> c_longlong;
+    pub fn mblen(__mbs: *const c_char, __limit: crate::size_t) -> c_int;
+    pub fn mbtowc(
+        __wc: *mut crate::wchar_t,
+        __mb_chr: *const c_char,
+        __max_size: crate::size_t,
+    ) -> c_int;
+    pub fn wctomb(__mb_chr: *mut c_char, __wc: crate::wchar_t) -> c_int;
+    pub fn mbstowcs(
+        __wc_string: *mut crate::wchar_t,
+        __mb_string: *const c_char,
+        __max_size: crate::size_t,
+    ) -> crate::size_t;
+}
+extern "C" {
+    pub fn random() -> c_long;
+    pub fn drand48() -> c_double;
+    pub fn erand48(__s: *mut c_ushort) -> c_double;
+    pub fn seed48(__s: *mut c_ushort) -> *mut c_ushort;
+    pub fn srand48(__seed: c_long);
+    pub fn mrand48() -> c_long;
+    pub fn jrand48(__s: *mut c_ushort) -> c_long;
+    pub fn initstate(__seed: c_uint, __state: *mut c_char, __size: crate::size_t) -> *mut c_char;
+    pub fn setstate(__state: *mut c_char) -> *mut c_char;
+    pub fn srandom(__seed: c_uint);
+    pub fn mkstemps(__pattern: *mut c_char, __suffixlen: c_int) -> c_int;
+    pub fn mkostemp(__pattern: *mut c_char, __flags: c_int) -> c_int;
+    pub fn mkostemps(__pattern: *mut c_char, __suffixlen: c_int, __flags: c_int) -> c_int;
+    pub fn strtod_l(
+        __nptr: *const c_char,
+        __endptr: *mut *mut c_char,
+        __loc: crate::locale_t,
+    ) -> c_double;
+    pub fn strtof_l(
+        __string: *const c_char,
+        __end: *mut *mut c_char,
+        __loc: crate::locale_t,
+    ) -> c_float;
+    pub fn getsubopt(
+        __optionp: *mut *mut c_char,
+        __tokens: *mut *mut c_char,
+        __valuep: *mut *mut c_char,
+    ) -> c_int;
+    pub fn secure_getenv(__name: *const c_char) -> *mut c_char;
+    pub fn canonicalize_file_name(__name: *const c_char) -> *mut c_char;
+    pub fn reallocarray(
+        __ptr: *mut c_void,
+        __count: crate::size_t,
+        __size: crate::size_t,
+    ) -> *mut c_void;
+}
+
+// bits/linux/linux_sched.h
+extern "C" {
+    pub fn sched_getscheduler(__pid: crate::pid_t) -> c_int;
+    pub fn sched_setaffinity(
+        __pid: crate::pid_t,
+        __cpusetsize: crate::size_t,
+        __mask: *const crate::cpu_set_t,
+    ) -> c_int;
+    pub fn sched_getaffinity(
+        __pid: crate::pid_t,
+        __cpusetsize: crate::size_t,
+        __mask: *mut crate::cpu_set_t,
+    ) -> c_int;
+    pub fn unshare(flags: c_int) -> c_int;
+    pub fn clone(
+        arg0: Option<unsafe extern "C" fn(*mut c_void) -> c_int>,
+        arg1: *mut c_void,
+        arg2: c_int,
+        arg3: *mut c_void,
+        ...
+    ) -> c_int;
+    pub fn sched_getcpu() -> c_int;
+    pub fn setns(fd: c_int, nstype: c_int) -> c_int;
+}
+
+// bits/linux/linux_stat.h
+extern "C" {
+    pub fn statx(
+        __dirfd: c_int,
+        __pathname: *const c_char,
+        __flags: c_int,
+        __mask: c_uint,
+        __statxbuf: *mut crate::statx,
+    ) -> c_int;
+}
+
+// bits/linux/linux_unistd.h
+
+// bits/machine.h
+
+// bits/mbstate.h
+s! {
+    pub struct __mlibc_mbstate {
+        pub __progress: c_short,
+        pub __shift: c_short,
+        pub __cpoint: c_uint,
+    }
+}
+pub type mbstate_t = crate::__mlibc_mbstate;
+
+// bits/nl_item.h
+pub const ABDAY_1: c_int = 0x60000;
+pub const ABDAY_2: c_int = 0x60001;
+pub const ABDAY_3: c_int = 0x60002;
+pub const ABDAY_4: c_int = 0x60003;
+pub const ABDAY_5: c_int = 0x60004;
+pub const ABDAY_6: c_int = 0x60005;
+pub const ABDAY_7: c_int = 0x60006;
+pub const DAY_1: c_int = 0x60007;
+pub const DAY_2: c_int = 0x60008;
+pub const DAY_3: c_int = 0x60009;
+pub const DAY_4: c_int = 0x6000A;
+pub const DAY_5: c_int = 0x6000B;
+pub const DAY_6: c_int = 0x6000C;
+pub const DAY_7: c_int = 0x6000D;
+pub const ABMON_1: c_int = 0x6000E;
+pub const ABMON_2: c_int = 0x6000F;
+pub const ABMON_3: c_int = 0x60010;
+pub const ABMON_4: c_int = 0x60011;
+pub const ABMON_5: c_int = 0x60012;
+pub const ABMON_6: c_int = 0x60013;
+pub const ABMON_7: c_int = 0x60014;
+pub const ABMON_8: c_int = 0x60015;
+pub const ABMON_9: c_int = 0x60016;
+pub const ABMON_10: c_int = 0x60017;
+pub const ABMON_11: c_int = 0x60018;
+pub const ABMON_12: c_int = 0x60019;
+pub const MON_1: c_int = 0x6001A;
+pub const MON_2: c_int = 0x6001B;
+pub const MON_3: c_int = 0x6001C;
+pub const MON_4: c_int = 0x6001D;
+pub const MON_5: c_int = 0x6001E;
+pub const MON_6: c_int = 0x6001F;
+pub const MON_7: c_int = 0x60020;
+pub const MON_8: c_int = 0x60021;
+pub const MON_9: c_int = 0x60022;
+pub const MON_10: c_int = 0x60023;
+pub const MON_11: c_int = 0x60024;
+pub const MON_12: c_int = 0x60025;
+pub const AM_STR: c_int = 0x60026;
+pub const PM_STR: c_int = 0x60027;
+pub const D_T_FMT: c_int = 0x60028;
+pub const D_FMT: c_int = 0x60029;
+pub const T_FMT: c_int = 0x6002A;
+pub const T_FMT_AMPM: c_int = 0x6002B;
+pub const ERA: c_int = 0x6002C;
+pub const ERA_D_FMT: c_int = 0x6002D;
+pub const ALT_DIGITS: c_int = 0x6002E;
+pub const ERA_D_T_FMT: c_int = 0x6002F;
+pub const ERA_T_FMT: c_int = 0x60030;
+pub const CODESET: c_int = 0x30000;
+pub const CRNCYSTR: c_int = 0x40000;
+pub const RADIXCHAR: c_int = 0x50000;
+pub const DECIMAL_POINT: c_int = RADIXCHAR;
+pub const THOUSEP: c_int = 0x50001;
+pub const THOUSANDS_SEP: c_int = THOUSEP;
+pub const YESEXPR: c_int = 0x70000;
+pub const NOEXPR: c_int = 0x70001;
+pub type nl_item = c_int;
+
+// bits/off_t.h
+
+// bits/posix/fd_set.h
+
+// bits/posix/id_t.h
+
+// bits/posix/in_addr_t.h
+
+// bits/posix/in_port_t.h
+
+// bits/posix/iovec.h
+
+// bits/posix/locale_t.h
+
+// bits/posix/posix_ctype.h
+extern "C" {
+    pub fn isalnum_l(__c: c_int, __loc: crate::locale_t) -> c_int;
+    pub fn isalpha_l(__c: c_int, __loc: crate::locale_t) -> c_int;
+    pub fn isblank_l(__c: c_int, __loc: crate::locale_t) -> c_int;
+    pub fn iscntrl_l(__c: c_int, __loc: crate::locale_t) -> c_int;
+    pub fn isdigit_l(__c: c_int, __loc: crate::locale_t) -> c_int;
+    pub fn isgraph_l(__c: c_int, __loc: crate::locale_t) -> c_int;
+    pub fn islower_l(__c: c_int, __loc: crate::locale_t) -> c_int;
+    pub fn isprint_l(__c: c_int, __loc: crate::locale_t) -> c_int;
+    pub fn ispunct_l(__c: c_int, __loc: crate::locale_t) -> c_int;
+    pub fn isspace_l(__c: c_int, __loc: crate::locale_t) -> c_int;
+    pub fn isupper_l(__c: c_int, __loc: crate::locale_t) -> c_int;
+    pub fn isxdigit_l(__c: c_int, __loc: crate::locale_t) -> c_int;
+    pub fn isascii_l(__c: c_int, __loc: crate::locale_t) -> c_int;
+    pub fn tolower_l(__c: c_int, __loc: crate::locale_t) -> c_int;
+    pub fn toupper_l(__c: c_int, __loc: crate::locale_t) -> c_int;
+}
+
+// bits/posix/posix_locale.h
+
+// bits/posix/posix_signal.h
+pub const FPE_INTDIV: c_int = 1;
+pub const FPE_INTOVF: c_int = 2;
+pub const FPE_FLTDIV: c_int = 3;
+pub const FPE_FLTOVF: c_int = 4;
+pub const FPE_FLTUND: c_int = 5;
+pub const FPE_FLTRES: c_int = 6;
+pub const FPE_FLTINV: c_int = 7;
+pub const FPE_FLTSUB: c_int = 8;
+pub const TRAP_BRKPT: c_int = 1;
+pub const TRAP_TRACE: c_int = 2;
+pub type pthread_t = *mut crate::__mlibc_thread_data;
+s! {
+    pub struct _libc_fpxreg {
+        pub significand: [c_ushort; 4],
+        pub exponent: c_ushort,
+        pub __glibc_reserved1: [c_ushort; 3],
+    }
+    pub struct _libc_xmmreg {
+        pub element: [u32; 4],
+    }
+    pub struct _libc_fpstate {
+        pub cwd: u16,
+        pub swd: i16,
+        pub ftw: u16,
+        pub fop: u16,
+        pub rip: u64,
+        pub dp: u64,
+        pub mxcsr: u32,
+        pub mxcr_mask: u32,
+        pub _st: [crate::_libc_fpxreg; 8],
+        pub _xmm: [crate::_libc_xmmreg; 16],
+        pub __glibc_reserved1: [u32; 24],
+    }
+}
+pub type fpregset_t = *mut crate::_libc_fpstate;
+pub type greg_t = c_ulong;
+extern "C" {
+    pub fn sigsuspend(__sigmask: *const crate::sigset_t) -> c_int;
+    pub fn pthread_sigmask(
+        __how: c_int,
+        __sigmask: *const crate::sigset_t,
+        __oldmask: *mut crate::sigset_t,
+    ) -> c_int;
+    pub fn pthread_kill(__thrd: crate::pthread_t, __sig: c_int) -> c_int;
+    pub fn siginterrupt(__sig: c_int, __flag: c_int) -> c_int;
+    pub fn sigaltstack(__ss: *const crate::stack_t, __oss: *mut crate::stack_t) -> c_int;
+    pub fn sigtimedwait(
+        __set: *const crate::sigset_t,
+        __info: *mut crate::siginfo_t,
+        __timeout: *const crate::timespec,
+    ) -> c_int;
+    pub fn sigwait(__set: *const crate::sigset_t, __sig: *mut c_int) -> c_int;
+    pub fn sigwaitinfo(__set: *const crate::sigset_t, __info: *mut crate::siginfo_t) -> c_int;
+    pub fn sigisemptyset(__set: *const crate::sigset_t) -> c_int;
+    pub fn sigqueue(__pid: crate::pid_t, __sig: c_int, __value: crate::sigval) -> c_int;
+}
+
+// bits/posix/posix_stdio.h
+extern "C" {
+    pub fn popen(__command: *const c_char, __type: *const c_char) -> *mut crate::FILE;
+    pub fn fseeko64(__stream: *mut crate::FILE, __offset: crate::off64_t, __whence: c_int)
+        -> c_int;
+    pub fn ftello64(__stream: *mut crate::FILE) -> crate::off64_t;
+    pub fn dprintf(__fd: c_int, __format: *const c_char, ...) -> c_int;
+    pub fn vdprintf(__fd: c_int, __format: *const c_char, __args: *mut c_char) -> c_int;
+    pub fn fgetln(__stream: *mut crate::FILE, __size: *mut crate::size_t) -> *mut c_char;
+    pub fn tempnam(__dir: *const c_char, __pfx: *const c_char) -> *mut c_char;
+}
+
+// bits/posix/posix_stdlib.h
+
+// bits/posix/posix_string.h
+extern "C" {
+    pub fn strsep(__stringp: *mut *mut c_char, __delim: *const c_char) -> *mut c_char;
+    pub fn memccpy(
+        __dest: *mut c_void,
+        __src: *const c_void,
+        __c: c_int,
+        __n: crate::size_t,
+    ) -> *mut c_void;
+    pub fn strcoll_l(__s1: *const c_char, __s2: *const c_char, __locale: crate::locale_t) -> c_int;
+    pub fn strerror_l(__errnum: c_int, __locale: crate::locale_t) -> *mut c_char;
+    pub fn strlcpy(__d: *mut c_char, __s: *const c_char, __n: crate::size_t) -> c_ulong;
+    pub fn strlcat(__d: *mut c_char, __s: *const c_char, __n: crate::size_t) -> c_ulong;
+}
+
+// bits/posix/posix_time.h
+
+// bits/posix/posix_wctype.h
+pub type wint_t = c_uint;
+pub type wctype_t = c_ulong;
+pub type wctrans_t = c_ulong;
+extern "C" {
+    pub fn iswalnum_l(__wc: crate::wint_t, __loc: crate::locale_t) -> c_int;
+    pub fn iswblank_l(__wc: crate::wint_t, __loc: crate::locale_t) -> c_int;
+    pub fn iswcntrl_l(__wc: crate::wint_t, __loc: crate::locale_t) -> c_int;
+    pub fn iswdigit_l(__wc: crate::wint_t, __loc: crate::locale_t) -> c_int;
+    pub fn iswgraph_l(__wc: crate::wint_t, __loc: crate::locale_t) -> c_int;
+    pub fn iswlower_l(__wc: crate::wint_t, __loc: crate::locale_t) -> c_int;
+    pub fn iswprint_l(__wc: crate::wint_t, __loc: crate::locale_t) -> c_int;
+    pub fn iswpunct_l(__wc: crate::wint_t, __loc: crate::locale_t) -> c_int;
+    pub fn iswspace_l(__wc: crate::wint_t, __loc: crate::locale_t) -> c_int;
+    pub fn iswupper_l(__wc: crate::wint_t, __loc: crate::locale_t) -> c_int;
+    pub fn iswxdigit_l(__wc: crate::wint_t, __loc: crate::locale_t) -> c_int;
+    pub fn iswalpha_l(__wc: crate::wint_t, __loc: crate::locale_t) -> c_int;
+    pub fn wctype_l(__string: *const c_char, __loc: crate::locale_t) -> crate::wctype_t;
+    pub fn iswctype_l(
+        __wc: crate::wint_t,
+        __type: crate::wctype_t,
+        __loc: crate::locale_t,
+    ) -> c_int;
+    pub fn towlower_l(__wc: crate::wint_t, __loc: crate::locale_t) -> crate::wint_t;
+    pub fn towupper_l(__wc: crate::wint_t, __loc: crate::locale_t) -> crate::wint_t;
+    pub fn wctrans_l(__string: *const c_char, __loc: crate::locale_t) -> crate::wctrans_t;
+    pub fn towctrans_l(
+        __wc: crate::wint_t,
+        __trans: crate::wctrans_t,
+        __loc: crate::locale_t,
+    ) -> crate::wint_t;
+}
+
+// bits/posix/pthread_t.h
+
+// bits/posix/stat.h
+
+// bits/posix/timer_t.h
+
+// bits/posix/timeval.h
+
+// bits/sigset_t.h
+
+// bits/size_t.h
+
+// bits/ssize_t.h
+
+// bits/threads.h
+
+// bits/types.h
+
+// bits/wchar.h
+
+// bits/wchar_t.h
+
+// bits/wctrans_t.h
+
+// bits/wctype_t.h
+
+// bits/winsize.h
+s! {
+    pub struct winsize {
+        pub ws_row: c_ushort,
+        pub ws_col: c_ushort,
+        pub ws_xpixel: c_ushort,
+        pub ws_ypixel: c_ushort,
+    }
+}
+
+// bits/wint_t.h
+
+// ctype.h
+extern "C" {
+    pub fn isascii(__c: c_int) -> c_int;
+}
+
+// dirent.h
+pub const DT_WHT: c_int = 14;
+s! {
+    pub struct dirent {
+        pub d_ino: crate::ino_t,
+        pub d_off: crate::off_t,
+        pub d_reclen: c_ushort,
+        pub d_type: c_uchar,
+        pub d_name: [c_char; 1024],
+    }
+    pub struct __mlibc_dir_struct {
+        pub __handle: c_int,
+        pub __ent_next: usize,
+        pub __ent_limit: usize,
+        pub __ent_buffer: [c_char; 2048],
+        pub __current: crate::dirent,
+    }
+}
+extern "C" {
+    pub fn alphasort(__a: *const *mut crate::dirent, __b: *const *mut crate::dirent) -> c_int;
+    pub fn readdir64(__dirp: *mut crate::DIR) -> *mut crate::dirent64;
+    pub fn scandir(
+        __pathname: *const c_char,
+        __res: *mut *mut *mut crate::dirent,
+        __select: Option<unsafe extern "C" fn(*const crate::dirent) -> c_int>,
+        __compare: Option<
+            unsafe extern "C" fn(*const *mut crate::dirent, *const *mut crate::dirent) -> c_int,
+        >,
+    ) -> c_int;
+    pub fn seekdir(__dirp: *mut crate::DIR, __loc: c_long);
+    pub fn telldir(__dirp: *mut crate::DIR) -> c_long;
+    pub fn versionsort(__a: *const *mut crate::dirent, __b: *const *mut crate::dirent) -> c_int;
+}
+
+// errno.h
+extern "C" {
+    pub fn __errno_location() -> *mut c_int;
+}
+
+// error.h
+extern "C" {
+    pub fn error(__status: c_int, __errnum: c_int, __format: *const c_char, ...);
+    pub fn error_at_line(
+        __status: c_int,
+        __errnum: c_int,
+        __filename: *const c_char,
+        __linenum: c_uint,
+        __format: *const c_char,
+        ...
+    );
+}
+
+// execinfo.h
+extern "C" {
+    pub fn backtrace(__buffer: *mut *mut c_void, __size: c_int) -> c_int;
+    pub fn backtrace_symbols(__buffer: *mut *mut c_void, __size: c_int) -> *mut *mut c_char;
+    pub fn backtrace_symbols_fd(__buffer: *mut *mut c_void, __size: c_int, __fd: c_int);
+}
+
+// fcntl.h
+pub const O_NDELAY: c_int = O_NONBLOCK;
+pub const FALLOC_FL_KEEP_SIZE: c_int = 1;
+pub const FALLOC_FL_PUNCH_HOLE: c_int = 2;
+s! {
+    pub struct flock {
+        pub l_type: c_short,
+        pub l_whence: c_short,
+        pub l_start: crate::off_t,
+        pub l_len: crate::off_t,
+        pub l_pid: crate::pid_t,
+    }
+    pub struct flock64 {
+        pub l_type: c_short,
+        pub l_whence: c_short,
+        pub l_start: crate::off_t,
+        pub l_len: crate::off_t,
+        pub l_pid: crate::pid_t,
+    }
+}
+extern "C" {
+    pub fn fallocate(
+        __fd: c_int,
+        __mode: c_int,
+        __offset: crate::off_t,
+        __len: crate::off_t,
+    ) -> c_int;
+    pub fn open64(__path: *const c_char, __flags: c_int, ...) -> c_int;
+    pub fn posix_fallocate(__fd: c_int, __offset: crate::off_t, __size: crate::off_t) -> c_int;
+}
+s! {
+    pub struct file_handle {
+        pub handle_bytes: c_uint,
+        pub handle_type: c_int,
+        pub f_handle: [c_uchar; 0],
+    }
+}
+extern "C" {
+    pub fn name_to_handle_at(
+        __dirfd: c_int,
+        __path: *const c_char,
+        __handle: *mut crate::file_handle,
+        __mount_id: *mut c_int,
+        __flags: c_int,
+    ) -> c_int;
+    pub fn open_by_handle_at(
+        __dirfd: c_int,
+        __handle: *mut crate::file_handle,
+        __flags: c_int,
+    ) -> c_int;
+    pub fn splice(
+        __fd_in: c_int,
+        __off_in: *mut crate::off_t,
+        __fd_out: c_int,
+        __off_out: *mut crate::off_t,
+        __len: crate::size_t,
+        __flags: c_uint,
+    ) -> crate::ssize_t;
+    pub fn vmsplice(
+        __fd: c_int,
+        __iov: *const crate::iovec,
+        __nr_segs: crate::size_t,
+        __flags: c_uint,
+    ) -> crate::ssize_t;
+}
+
+// features.h
+
+// getopt.h
+pub const no_argument: c_int = 0;
+pub const required_argument: c_int = 1;
+pub const optional_argument: c_int = 2;
+s! {
+    pub struct option {
+        pub name: *const c_char,
+        pub has_arg: c_int,
+        pub flag: *mut c_int,
+        pub val: c_int,
+    }
+}
+extern "C" {
+    pub fn getopt_long(
+        __argc: c_int,
+        __argv: *mut *mut c_char,
+        __optstring: *const c_char,
+        __longopts: *const option,
+        __longindex: *mut c_int,
+    ) -> c_int;
+    pub fn getopt_long_only(
+        __argc: c_int,
+        __argv: *mut *mut c_char,
+        __optstring: *const c_char,
+        __longopts: *const option,
+        __longindex: *mut c_int,
+    ) -> c_int;
+}
+
+// glob.h
+pub const GLOB_APPEND: c_int = 0x01;
+pub const GLOB_DOOFFS: c_int = 0x02;
+pub const GLOB_ERR: c_int = 0x04;
+pub const GLOB_MARK: c_int = 0x08;
+pub const GLOB_NOCHECK: c_int = 0x10;
+pub const GLOB_NOESCAPE: c_int = 0x20;
+pub const GLOB_NOSORT: c_int = 0x40;
+pub const GLOB_PERIOD: c_int = 0x80;
+pub const GLOB_TILDE: c_int = 0x100;
+pub const GLOB_TILDE_CHECK: c_int = 0x200;
+pub const GLOB_BRACE: c_int = 0x400;
+pub const GLOB_NOMAGIC: c_int = 0x800;
+pub const GLOB_ALTDIRFUNC: c_int = 0x1000;
+pub const GLOB_ONLYDIR: c_int = 0x2000;
+pub const GLOB_MAGCHAR: c_int = 0x4000;
+pub const GLOB_ABORTED: c_int = 1;
+pub const GLOB_NOMATCH: c_int = 2;
+pub const GLOB_NOSPACE: c_int = 3;
+pub const GLOB_NOSYS: c_int = 4;
+s! {
+    pub struct glob_t {
+        pub gl_pathc: crate::size_t,
+        pub gl_pathv: *mut *mut c_char,
+        pub gl_offs: crate::size_t,
+        pub gl_flags: c_int,
+        pub gl_closedir: Option<unsafe extern "C" fn(*mut c_void) -> c_void>,
+        pub gl_readdir: Option<unsafe extern "C" fn(*mut c_void) -> *mut  crate::dirent>,
+        pub gl_opendir: Option<unsafe extern "C" fn(*const c_char) -> *mut c_void>,
+        pub gl_lstat: Option<unsafe extern "C" fn(*const c_char, *mut  crate::stat) -> c_int>,
+        pub gl_stat: Option<unsafe extern "C" fn(*const c_char, *mut  crate::stat) -> c_int>,
+    }
+}
+extern "C" {
+    pub fn glob(
+        __pattern: *const c_char,
+        __flags: c_int,
+        __errfunc: Option<unsafe extern "C" fn(*const c_char, c_int) -> c_int>,
+        __pglob: *mut crate::glob_t,
+    ) -> c_int;
+    pub fn globfree(__pglog: *mut crate::glob_t);
+}
+
+// grp.h
+pub const BUFSIZ: c_int = 512;
+pub const FOPEN_MAX: c_int = 1024;
+pub const FILENAME_MAX: c_int = 256;
+pub const L_tmpnam: c_int = 256;
+pub const TMP_MAX: c_int = 1024;
+s! {
+    pub struct __mlibc_file_base {
+        pub __buffer_ptr: *mut c_char,
+        pub __buffer_size: crate::size_t,
+        pub __offset: crate::size_t,
+        pub __io_offset: crate::size_t,
+        pub __valid_limit: crate::size_t,
+        pub __dirty_begin: crate::size_t,
+        pub __dirty_end: crate::size_t,
+        pub __unget_ptr: *mut c_char,
+        pub __io_mode: c_int,
+        pub __status_bits: c_int,
+    }
+}
+extern "C" {
+    pub fn setlinebuf(__stream: *mut crate::FILE);
+    pub fn setbuffer(__stream: *mut crate::FILE, __buffer: *mut c_char, __size: crate::size_t);
+    pub fn vfprintf(
+        __stream: *mut crate::FILE,
+        __format: *const c_char,
+        __args: *mut c_char,
+    ) -> c_int;
+    pub fn vfscanf(
+        __stream: *mut crate::FILE,
+        __format: *const c_char,
+        __args: *mut c_char,
+    ) -> c_int;
+    pub fn vprintf(__format: *const c_char, __args: *mut c_char) -> c_int;
+    pub fn vscanf(__format: *const c_char, __args: *mut c_char) -> c_int;
+    pub fn vsnprintf(
+        __buffer: *mut c_char,
+        __max_size: crate::size_t,
+        __format: *const c_char,
+        __args: *mut c_char,
+    ) -> c_int;
+    pub fn vsprintf(__buffer: *mut c_char, __format: *const c_char, __args: *mut c_char) -> c_int;
+    pub fn vsscanf(__buffer: *const c_char, __format: *const c_char, __args: *mut c_char) -> c_int;
+    pub fn vasprintf(
+        __buffer: *mut *mut c_char,
+        __format: *const c_char,
+        __args: *mut c_char,
+    ) -> c_int;
+    pub fn gets(__s: *mut c_char) -> *mut c_char;
+    pub fn getc(__stream: *mut crate::FILE) -> c_int;
+    pub fn putc(__c: c_int, __stream: *mut crate::FILE) -> c_int;
+    pub fn getc_unlocked(__stream: *mut crate::FILE) -> c_int;
+    pub fn putc_unlocked(__c: c_int, __stream: *mut crate::FILE) -> c_int;
+    pub fn getdelim(
+        __linep: *mut *mut c_char,
+        __sizep: *mut crate::size_t,
+        __delim: c_int,
+        __stream: *mut crate::FILE,
+    ) -> crate::ssize_t;
+    pub fn asprintf(__buffer: *mut *mut c_char, __format: *const c_char, ...) -> c_int;
+    pub fn flockfile(__stream: *mut crate::FILE);
+    pub fn funlockfile(__stream: *mut crate::FILE);
+    pub fn ftrylockfile(__stream: *mut crate::FILE) -> c_int;
+    pub fn clearerr_unlocked(__stream: *mut crate::FILE);
+    pub fn feof_unlocked(__stream: *mut crate::FILE) -> c_int;
+    pub fn ferror_unlocked(__stream: *mut crate::FILE) -> c_int;
+    pub fn fileno_unlocked(__stream: *mut crate::FILE) -> c_int;
+    pub fn fflush_unlocked(__stream: *mut crate::FILE) -> c_int;
+    pub fn fgetc_unlocked(__stream: *mut crate::FILE) -> c_int;
+    pub fn fputc_unlocked(__c: c_int, __stream: *mut crate::FILE) -> c_int;
+    pub fn fread_unlocked(
+        __buffer: *mut c_void,
+        __size: crate::size_t,
+        __count: crate::size_t,
+        __stream: *mut crate::FILE,
+    ) -> crate::size_t;
+    pub fn fwrite_unlocked(
+        __buffer: *const c_void,
+        __size: crate::size_t,
+        __count: crate::size_t,
+        __stream: *mut crate::FILE,
+    ) -> crate::size_t;
+    pub fn fgets_unlocked(
+        __buffer: *mut c_char,
+        __size: c_int,
+        __stream: *mut crate::FILE,
+    ) -> *mut c_char;
+    pub fn fputs_unlocked(__buffer: *const c_char, __stream: *mut crate::FILE) -> c_int;
+}
+s! {
+    pub struct group {
+        pub gr_name: *mut c_char,
+        pub gr_passwd: *mut c_char,
+        pub gr_gid: crate::gid_t,
+        pub gr_mem: *mut *mut c_char,
+    }
+}
+extern "C" {
+    pub fn endgrent();
+    pub fn getgrent() -> *mut crate::group;
+    pub fn getgrgid(__gid: crate::gid_t) -> *mut crate::group;
+    pub fn getgrgid_r(
+        __gid: crate::gid_t,
+        __grp: *mut crate::group,
+        __buf: *mut c_char,
+        __buflen: crate::size_t,
+        __res: *mut *mut crate::group,
+    ) -> c_int;
+    pub fn getgrnam(__name: *const c_char) -> *mut crate::group;
+    pub fn getgrnam_r(
+        __name: *const c_char,
+        __grp: *mut crate::group,
+        __buf: *mut c_char,
+        __buflen: crate::size_t,
+        __res: *mut *mut crate::group,
+    ) -> c_int;
+    pub fn setgrent();
+    pub fn putgrent(__grp: *const crate::group, __stream: *mut crate::FILE) -> c_int;
+    pub fn fgetgrent(__stream: *mut crate::FILE) -> *mut crate::group;
+    pub fn initgroups(__user: *const c_char, __group: crate::gid_t) -> c_int;
+    pub fn getgrouplist(
+        __user: *const c_char,
+        __group: crate::gid_t,
+        __groups: *mut crate::gid_t,
+        __ngroups: *mut c_int,
+    ) -> c_int;
+}
+
+// ifaddrs.h
+
+// langinfo.h
+extern "C" {
+    pub fn nl_langinfo(__item: crate::nl_item) -> *mut c_char;
+    pub fn nl_langinfo_l(__item: crate::nl_item, __loc: crate::locale_t) -> *mut c_char;
+}
+
+// libgen.h
+extern "C" {
+    pub fn basename(__path: *mut c_char) -> *mut c_char;
+    pub fn dirname(__path: *mut c_char) -> *mut c_char;
+}
+
+// limits.h
+
+// link.h
+extern "C" {
+    pub fn dl_iterate_phdr(
+        __callback: Option<
+            unsafe extern "C" fn(*mut crate::dl_phdr_info, crate::size_t, *mut c_void) -> c_int,
+        >,
+        __data: *mut c_void,
+    ) -> c_int;
+}
+
+// malloc.h
+
+// memory.h
+extern "C" {
+    pub fn mempcpy(__dest: *mut c_void, __src: *const c_void, __size: crate::size_t)
+        -> *mut c_void;
+    pub fn strverscmp(__l0: *const c_char, __r0: *const c_char) -> c_int;
+    pub fn ffsl(__i: c_long) -> c_int;
+    pub fn ffsll(__i: c_longlong) -> c_int;
+    pub fn memmem(
+        __haystack: *const c_void,
+        __haystacklen: crate::size_t,
+        __needle: *const c_void,
+        __needlelen: crate::size_t,
+    ) -> *mut c_void;
+}
+
+// mntent.h
+s! {
+    pub struct mntent {
+        pub mnt_fsname: *mut c_char,
+        pub mnt_dir: *mut c_char,
+        pub mnt_type: *mut c_char,
+        pub mnt_opts: *mut c_char,
+        pub mnt_freq: c_int,
+        pub mnt_passno: c_int,
+    }
+}
+extern "C" {
+    pub fn setmntent(__filename: *const c_char, __type: *const c_char) -> *mut crate::FILE;
+    pub fn getmntent(__f: *mut crate::FILE) -> *mut crate::mntent;
+    pub fn addmntent(__f: *mut crate::FILE, __mnt: *const crate::mntent) -> c_int;
+    pub fn endmntent(__f: *mut crate::FILE) -> c_int;
+    pub fn hasmntopt(__mnt: *const crate::mntent, __opt: *const c_char) -> *mut c_char;
+    pub fn getmntent_r(
+        __f: *mut crate::FILE,
+        __mnt: *mut crate::mntent,
+        __linebuf: *mut c_char,
+        __buflen: c_int,
+    ) -> *mut crate::mntent;
+}
+
+// mqueue.h
+pub type mqd_t = c_int;
+extern "C" {
+    pub fn mq_getattr(__mqdes: crate::mqd_t, __attr: *mut crate::mq_attr) -> c_int;
+    pub fn mq_setattr(
+        __mqdes: crate::mqd_t,
+        __newattr: *const crate::mq_attr,
+        __oldattr: *mut crate::mq_attr,
+    ) -> c_int;
+    pub fn mq_unlink(__name: *const c_char) -> c_int;
+    pub fn mq_open(__name: *const c_char, __flags: c_int, ...) -> crate::mqd_t;
+}
+
+// net/if.h
+pub const ALTIFNAMSIZ: c_int = 128;
+pub const IFALIASZ: c_int = 256;
+pub const IFHWADDRLEN: c_int = 6;
+pub const IFF_BROADCAST: c_int = 0x2;
+pub const IFF_LOOPBACK: c_int = 0x8;
+pub const IFF_POINTOPOINT: c_int = 0x10;
+pub const IFF_RUNNING: c_int = 0x40;
+pub const IFF_MASTER: c_int = 0x400;
+pub const IFF_SLAVE: c_int = 0x800;
+pub const IFF_LOWER_UP: c_int = 0x10000;
+pub const IFF_DORMANT: c_int = 0x20000;
+pub const IFF_ECHO: c_int = 0x40000;
+s! {
+    pub struct if_nameindex {
+        pub if_index: c_uint,
+        pub if_name: *mut c_char,
+    }
+    pub struct ifmap {
+        pub mem_start: c_ulong,
+        pub mem_end: c_ulong,
+        pub base_addr: c_ushort,
+        pub irq: c_uchar,
+        pub dma: c_uchar,
+        pub port: c_uchar,
+    }
+}
+extern "C" {
+    pub fn if_freenameindex(__index: *mut crate::if_nameindex);
+    pub fn if_nameindex() -> *mut crate::if_nameindex;
+}
+
+// net/route.h
+pub const RTF_HOST: c_int = 0x0004;
+pub const RTF_REJECT: c_int = 0x0200;
+s! {
+    pub struct rtentry {
+        pub rt_pad1: c_ulong,
+        pub rt_dst: crate::sockaddr,
+        pub rt_gateway: crate::sockaddr,
+        pub rt_genmask: crate::sockaddr,
+        pub rt_flags: c_ushort,
+        pub rt_pad2: c_short,
+        pub rt_pad3: c_ulong,
+        pub rt_tos: c_uchar,
+        pub rt_class: c_uchar,
+        pub rt_pad4: [c_short; 3],
+        pub rt_metric: c_short,
+        pub rt_dev: *mut c_char,
+        pub rt_mtu: c_ulong,
+        pub rt_window: c_ulong,
+        pub rt_irtt: c_ushort,
+    }
+}
+
+// netdb.h
+pub const AI_PASSIVE: c_int = 0x01;
+pub const AI_CANONNAME: c_int = 0x02;
+pub const AI_NUMERICHOST: c_int = 0x04;
+pub const AI_V4MAPPED: c_int = 0x08;
+pub const AI_ALL: c_int = 0x10;
+pub const AI_ADDRCONFIG: c_int = 0x20;
+pub const AI_NUMERICSERV: c_int = 0x40;
+pub const NI_NOFQDN: c_int = 0x01;
+pub const NI_NUMERICHOST: c_int = 0x02;
+pub const NI_NAMEREQD: c_int = 0x04;
+pub const NI_NUMERICSCOPE: c_int = 0x08;
+pub const NI_DGRAM: c_int = 0x10;
+pub const NI_NUMERICSERV: c_int = 2;
+pub const NI_MAXSERV: c_int = 32;
+pub const NI_IDN: c_int = 32;
+pub const NI_IDN_USE_STD3_ASCII_RULES: c_int = 128;
+pub const NI_MAXHOST: c_int = 1025;
+pub const EAI_AGAIN: c_int = 1;
+pub const EAI_BADFLAGS: c_int = 2;
+pub const EAI_FAIL: c_int = 3;
+pub const EAI_FAMILY: c_int = 4;
+pub const EAI_MEMORY: c_int = 5;
+pub const EAI_NONAME: c_int = 6;
+pub const EAI_SERVICE: c_int = 7;
+pub const EAI_SOCKTYPE: c_int = 8;
+pub const EAI_SYSTEM: c_int = 9;
+pub const EAI_OVERFLOW: c_int = 10;
+pub const EAI_NODATA: c_int = 11;
+pub const EAI_ADDRFAMILY: c_int = 12;
+pub const HOST_NOT_FOUND: c_int = 1;
+pub const TRY_AGAIN: c_int = 2;
+pub const NO_RECOVERY: c_int = 3;
+pub const NO_DATA: c_int = 4;
+pub const NO_ADDRESS: c_int = NO_DATA;
+s! {
+    pub struct hostent {
+        pub h_name: *mut c_char,
+        pub h_aliases: *mut *mut c_char,
+        pub h_addrtype: c_int,
+        pub h_length: c_int,
+        pub h_addr_list: *mut *mut c_char,
+    }
+    pub struct netent {
+        pub n_name: *mut c_char,
+        pub n_aliases: *mut *mut c_char,
+        pub n_addrtype: c_int,
+        pub n_net: u32,
+    }
+    pub struct protoent {
+        pub p_name: *mut c_char,
+        pub p_aliases: *mut *mut c_char,
+        pub p_proto: c_int,
+    }
+    pub struct servent {
+        pub s_name: *mut c_char,
+        pub s_aliases: *mut *mut c_char,
+        pub s_port: c_int,
+        pub s_proto: *mut c_char,
+    }
+}
+extern "C" {
+    pub fn endhostent();
+    pub fn endnetent();
+    pub fn endprotoent();
+    pub fn gethostent() -> *mut crate::hostent;
+    pub fn gethostbyname(__name: *const c_char) -> *mut crate::hostent;
+    pub fn gethostbyname2(__name: *const c_char, __flags: c_int) -> *mut crate::hostent;
+    pub fn gethostbyaddr(
+        __addr: *const c_void,
+        __len: crate::socklen_t,
+        __type: c_int,
+    ) -> *mut crate::hostent;
+    pub fn gethostbyaddr_r(
+        __addr: *const c_void,
+        __len: crate::socklen_t,
+        __type: c_int,
+        __ret: *mut crate::hostent,
+        __buf: *mut c_char,
+        __buflen: crate::size_t,
+        __res: *mut *mut crate::hostent,
+        __h_errnump: *mut c_int,
+    ) -> c_int;
+    pub fn gethostbyname_r(
+        __name: *const c_char,
+        __ret: *mut crate::hostent,
+        __buf: *mut c_char,
+        __buflen: crate::size_t,
+        __res: *mut *mut crate::hostent,
+        __h_errnump: *mut c_int,
+    ) -> c_int;
+    pub fn getnameinfo(
+        __addr: *const crate::sockaddr,
+        __addrlen: crate::socklen_t,
+        __host: *mut c_char,
+        __hostlen: crate::socklen_t,
+        __serv: *mut c_char,
+        __servlen: crate::socklen_t,
+        __flags: c_int,
+    ) -> c_int;
+    pub fn getnetbyaddr(__net: u32, __type: c_int) -> *mut crate::netent;
+    pub fn getnetbyname(__name: *const c_char) -> *mut crate::netent;
+    pub fn getnetent() -> *mut crate::netent;
+    pub fn getprotoent() -> *mut crate::protoent;
+    pub fn sethostent(__stayopen: c_int);
+    pub fn setnetent(__stayopen: c_int);
+    pub fn setprotoent(__stayopen: c_int);
+}
+
+// netinet/ether.h
+pub const ETH_ALEN: c_int = 6;
+pub const ETH_HLEN: c_int = 14;
+pub const ETH_ZLEN: c_int = 60;
+pub const ETH_FRAME_LEN: c_int = 1514;
+pub const ETH_FCS_LEN: c_int = 4;
+pub const ETH_P_LOOP: c_int = 0x0060;
+pub const ETH_P_PUP: c_int = 0x0200;
+pub const ETH_P_PUPAT: c_int = 0x0201;
+pub const ETH_P_IP: c_int = 0x0800;
+pub const ETH_P_X25: c_int = 0x0805;
+pub const ETH_P_ARP: c_int = 0x0806;
+pub const ETH_P_BPQ: c_int = 0x08FF;
+pub const ETH_P_IEEEPUP: c_int = 0x0a00;
+pub const ETH_P_IEEEPUPAT: c_int = 0x0a01;
+pub const ETH_P_BATMAN: c_int = 0x4305;
+pub const ETH_P_DEC: c_int = 0x6000;
+pub const ETH_P_DNA_DL: c_int = 0x6001;
+pub const ETH_P_DNA_RC: c_int = 0x6002;
+pub const ETH_P_DNA_RT: c_int = 0x6003;
+pub const ETH_P_LAT: c_int = 0x6004;
+pub const ETH_P_DIAG: c_int = 0x6005;
+pub const ETH_P_CUST: c_int = 0x6006;
+pub const ETH_P_SCA: c_int = 0x6007;
+pub const ETH_P_TEB: c_int = 0x6558;
+pub const ETH_P_RARP: c_int = 0x8035;
+pub const ETH_P_ATALK: c_int = 0x809B;
+pub const ETH_P_AARP: c_int = 0x80F3;
+pub const ETH_P_8021Q: c_int = 0x8100;
+pub const ETH_P_IPX: c_int = 0x8137;
+pub const ETH_P_IPV6: c_int = 0x86DD;
+pub const ETH_P_PAUSE: c_int = 0x8808;
+pub const ETH_P_SLOW: c_int = 0x8809;
+pub const ETH_P_WCCP: c_int = 0x883E;
+pub const ETH_P_MPLS_UC: c_int = 0x8847;
+pub const ETH_P_MPLS_MC: c_int = 0x8848;
+pub const ETH_P_ATMMPOA: c_int = 0x884c;
+pub const ETH_P_PPP_DISC: c_int = 0x8863;
+pub const ETH_P_PPP_SES: c_int = 0x8864;
+pub const ETH_P_LINK_CTL: c_int = 0x886c;
+pub const ETH_P_ATMFATE: c_int = 0x8884;
+pub const ETH_P_PAE: c_int = 0x888E;
+pub const ETH_P_AOE: c_int = 0x88A2;
+pub const ETH_P_8021AD: c_int = 0x88A8;
+pub const ETH_P_802_EX1: c_int = 0x88B5;
+pub const ETH_P_TIPC: c_int = 0x88CA;
+pub const ETH_P_8021AH: c_int = 0x88E7;
+pub const ETH_P_MVRP: c_int = 0x88F5;
+pub const ETH_P_1588: c_int = 0x88F7;
+pub const ETH_P_PRP: c_int = 0x88FB;
+pub const ETH_P_FCOE: c_int = 0x8906;
+pub const ETH_P_TDLS: c_int = 0x890D;
+pub const ETH_P_FIP: c_int = 0x8914;
+pub const ETH_P_80221: c_int = 0x8917;
+pub const ETH_P_LOOPBACK: c_int = 0x9000;
+pub const ETH_P_QINQ1: c_int = 0x9100;
+pub const ETH_P_QINQ2: c_int = 0x9200;
+pub const ETH_P_QINQ3: c_int = 0x9300;
+pub const ETH_P_EDSA: c_int = 0xDADA;
+pub const ETH_P_AF_IUCV: c_int = 0xFBFB;
+pub const ETH_P_802_3_MIN: c_int = 0x0600;
+pub const ETH_P_802_3: c_int = 0x0001;
+pub const ETH_P_AX25: c_int = 0x0002;
+pub const ETH_P_ALL: c_int = 0x0003;
+pub const ETH_P_802_2: c_int = 0x0004;
+pub const ETH_P_SNAP: c_int = 0x0005;
+pub const ETH_P_DDCMP: c_int = 0x0006;
+pub const ETH_P_WAN_PPP: c_int = 0x0007;
+pub const ETH_P_PPP_MP: c_int = 0x0008;
+pub const ETH_P_LOCALTALK: c_int = 0x0009;
+pub const ETH_P_CAN: c_int = 0x000C;
+pub const ETH_P_CANFD: c_int = 0x000D;
+pub const ETH_P_PPPTALK: c_int = 0x0010;
+pub const ETH_P_TR_802_2: c_int = 0x0011;
+pub const ETH_P_MOBITEX: c_int = 0x0015;
+pub const ETH_P_CONTROL: c_int = 0x0016;
+pub const ETH_P_IRDA: c_int = 0x0017;
+pub const ETH_P_ECONET: c_int = 0x0018;
+pub const ETH_P_HDLC: c_int = 0x0019;
+pub const ETH_P_ARCNET: c_int = 0x001A;
+pub const ETH_P_DSA: c_int = 0x001B;
+pub const ETH_P_TRAILER: c_int = 0x001C;
+pub const ETH_P_PHONET: c_int = 0x00F5;
+pub const ETH_P_IEEE802154: c_int = 0x00F6;
+pub const ETH_P_CAIF: c_int = 0x00F7;
+pub type __fd_mask = c_long;
+pub type fd_mask = crate::__fd_mask;
+pub type u_int = c_uint;
+pub type u_char = c_uchar;
+pub type u_short = c_ushort;
+pub type u_long = c_ulong;
+pub type caddr_t = *mut c_char;
+pub type loff_t = crate::off64_t;
+pub type ulong = c_ulong;
+pub type ushort = c_ushort;
+pub type uint = c_uint;
+pub type u_int8_t = u8;
+pub type u_int16_t = u16;
+pub type u_int32_t = u32;
+pub type u_int64_t = u64;
+pub type quad_t = i64;
+pub type u_quad_t = u64;
+s! {
+    pub struct ether_arp {
+        pub ea_hdr: crate::arphdr,
+        pub arp_sha: [u8; 6],
+        pub arp_spa: [u8; 4],
+        pub arp_tha: [u8; 6],
+        pub arp_tpa: [u8; 4],
+    }
+}
+extern "C" {
+    pub fn ether_ntoa(__addr: *const crate::ether_addr) -> *mut c_char;
+    pub fn ether_ntoa_r(__p_a: *const crate::ether_addr, __x: *mut c_char) -> *mut c_char;
+    pub fn ether_aton(__asc: *const c_char) -> *mut crate::ether_addr;
+}
+
+// netinet/if_ether.h
+
+// netinet/in.h
+
+// netinet/in_systm.h
+
+// netpacket/packet.h
+pub const PACKET_BROADCAST: c_int = 1;
+pub const PACKET_MULTICAST: c_int = 2;
+pub const PACKET_OTHERHOST: c_int = 3;
+pub const PACKET_OUTGOING: c_int = 4;
+pub const PACKET_LOOPBACK: c_int = 5;
+pub const PACKET_FASTROUTE: c_int = 6;
+pub const PACKET_ADD_MEMBERSHIP: c_int = 1;
+pub const PACKET_DROP_MEMBERSHIP: c_int = 2;
+pub const PACKET_MR_MULTICAST: c_int = 0;
+pub const PACKET_MR_PROMISC: c_int = 1;
+pub const PACKET_MR_ALLMULTI: c_int = 2;
+pub const PACKET_MR_UNICAST: c_int = 3;
+s! {
+    pub struct packet_mreq {
+        pub mr_ifindex: c_int,
+        pub mr_type: c_ushort,
+        pub mr_alen: c_ushort,
+        pub mr_address: [c_uchar; 8],
+    }
+}
+
+// nl_types.h
+
+// poll.h
+pub type nfds_t = usize;
+s! {
+    pub struct pollfd {
+        pub fd: c_int,
+        pub events: c_short,
+        pub revents: c_short,
+    }
+}
+extern "C" {
+    pub fn ppoll(
+        __fds: *mut crate::pollfd,
+        __nfds: crate::nfds_t,
+        __timeout_ts: *const crate::timespec,
+        __sigmask: *const crate::sigset_t,
+    ) -> c_int;
+}
+
+// pthread.h
+pub const _NSIG: c_int = NSIG;
+pub const SCHED_OTHER: c_int = 0;
+pub const SCHED_FIFO: c_int = 1;
+pub const SCHED_RR: c_int = 2;
+pub const SCHED_BATCH: c_int = 3;
+pub const SCHED_IDLE: c_int = 5;
+pub const SCHED_DEADLINE: c_int = 6;
+pub const SCHED_RESET_ON_FORK: c_int = 0x40000000;
+pub const PTHREAD_SCOPE_SYSTEM: c_int = 0;
+pub const PTHREAD_SCOPE_PROCESS: c_int = 1;
+pub const PTHREAD_INHERIT_SCHED: c_int = 0;
+pub const PTHREAD_EXPLICIT_SCHED: c_int = 1;
+pub const PTHREAD_CANCEL_DEFERRED: c_int = 0;
+pub const PTHREAD_CANCEL_ASYNCHRONOUS: c_int = 1;
+pub const PTHREAD_CANCEL_ENABLE: c_int = 0;
+pub const PTHREAD_CANCEL_DISABLE: c_int = 1;
+pub const PTHREAD_MUTEX_DEFAULT: c_int = __MLIBC_THREAD_MUTEX_DEFAULT;
+pub const PTHREAD_MUTEX_NORMAL: c_int = __MLIBC_THREAD_MUTEX_NORMAL;
+pub const PTHREAD_MUTEX_ERRORCHECK: c_int = __MLIBC_THREAD_MUTEX_ERRORCHECK;
+pub const PTHREAD_MUTEX_RECURSIVE: c_int = __MLIBC_THREAD_MUTEX_RECURSIVE;
+pub const PTHREAD_MUTEX_STALLED: c_int = __MLIBC_THREAD_MUTEX_STALLED;
+pub const PTHREAD_MUTEX_ROBUST: c_int = __MLIBC_THREAD_MUTEX_ROBUST;
+pub const PTHREAD_PROCESS_PRIVATE: c_int = __MLIBC_THREAD_PROCESS_PRIVATE;
+pub const PTHREAD_PROCESS_SHARED: c_int = __MLIBC_THREAD_PROCESS_SHARED;
+pub const PTHREAD_PRIO_NONE: c_int = __MLIBC_THREAD_PRIO_NONE;
+pub const PTHREAD_PRIO_INHERIT: c_int = __MLIBC_THREAD_PRIO_INHERIT;
+pub const PTHREAD_PRIO_PROTECT: c_int = __MLIBC_THREAD_PRIO_PROTECT;
+pub const PTHREAD_BARRIER_SERIAL_THREAD: c_int = 1;
+pub const PTHREAD_DESTRUCTOR_ITERATIONS: c_int = 8;
+pub const PTHREAD_ATTR_NO_SIGMASK_NP: c_int = 1;
+pub type sig_atomic_t = c_int;
+extern "C" {
+    pub fn sched_get_priority_max(__policy: c_int) -> c_int;
+    pub fn sched_get_priority_min(__policy: c_int) -> c_int;
+    pub fn sched_setscheduler(
+        __pid: crate::pid_t,
+        __policy: c_int,
+        __param: *const crate::sched_param,
+    ) -> c_int;
+    pub fn sched_getparam(__pid: crate::pid_t, __param: *mut crate::sched_param) -> c_int;
+    pub fn sched_setparam(__pid: crate::pid_t, __param: *const crate::sched_param) -> c_int;
+}
+pub type pthread_attr_t = crate::__mlibc_threadattr;
+pub type pthread_key_t = crate::uintptr_t;
+s! {
+    pub struct __mlibc_once {
+        pub __mlibc_done: c_uint,
+    }
+}
+pub type pthread_once_t = crate::__mlibc_once;
+pub type pthread_mutexattr_t = crate::__mlibc_mutexattr;
+pub type pthread_mutex_t = crate::__mlibc_mutex;
+pub type pthread_condattr_t = crate::__mlibc_condattr;
+pub type pthread_cond_t = crate::__mlibc_cond;
+s! {
+    pub struct __mlibc_barrierattr_struct {
+        pub __mlibc_pshared: c_int,
+    }
+}
+pub type pthread_barrierattr_t = crate::__mlibc_barrierattr_struct;
+s! {
+    pub struct __mlibc_barrier {
+        pub __mlibc_waiting: c_uint,
+        pub __mlibc_inside: c_uint,
+        pub __mlibc_count: c_uint,
+        pub __mlibc_seq: c_uint,
+        pub __mlibc_flags: c_uint,
+    }
+}
+pub type pthread_barrier_t = crate::__mlibc_barrier;
+s! {
+    pub struct __mlibc_fair_rwlock {
+        #[doc(hidden)]
+        size: [u8; 12],
+    }
+}
+pub type pthread_rwlock_t = crate::__mlibc_fair_rwlock;
+s! {
+    pub struct __mlibc_rwlockattr {
+        pub __mlibc_pshared: c_int,
+    }
+}
+pub type pthread_rwlockattr_t = crate::__mlibc_rwlockattr;
+extern "C" {
+    pub fn pthread_attr_getdetachstate(
+        __attr: *const crate::pthread_attr_t,
+        __state: *mut c_int,
+    ) -> c_int;
+    pub fn pthread_attr_getstackaddr(
+        __attr: *const crate::pthread_attr_t,
+        __stackaddr: *mut *mut c_void,
+    ) -> c_int;
+    pub fn pthread_attr_setstackaddr(
+        __attr: *mut crate::pthread_attr_t,
+        __stackaddr: *mut c_void,
+    ) -> c_int;
+    pub fn pthread_attr_setstack(
+        __attr: *mut crate::pthread_attr_t,
+        __stackaddr: *mut c_void,
+        __stacksize: crate::size_t,
+    ) -> c_int;
+    pub fn pthread_attr_getguardsize(
+        __attr: *const crate::pthread_attr_t,
+        __guardsize: *mut crate::size_t,
+    ) -> c_int;
+    pub fn pthread_attr_setguardsize(
+        __attr: *mut crate::pthread_attr_t,
+        __guardsize: crate::size_t,
+    ) -> c_int;
+    pub fn pthread_attr_getscope(
+        __attr: *const crate::pthread_attr_t,
+        __scope: *mut c_int,
+    ) -> c_int;
+    pub fn pthread_attr_setscope(__attr: *mut crate::pthread_attr_t, __scope: c_int) -> c_int;
+    pub fn pthread_attr_getschedparam(
+        __attr: *const crate::pthread_attr_t,
+        __param: *mut crate::sched_param,
+    ) -> c_int;
+    pub fn pthread_attr_setschedparam(
+        __attr: *mut crate::pthread_attr_t,
+        __param: *const crate::sched_param,
+    ) -> c_int;
+    pub fn pthread_attr_getschedpolicy(
+        __attr: *const crate::pthread_attr_t,
+        __schedpolicy: *mut c_int,
+    ) -> c_int;
+    pub fn pthread_attr_setschedpolicy(
+        __attr: *mut crate::pthread_attr_t,
+        __schedpolicy: c_int,
+    ) -> c_int;
+    pub fn pthread_attr_getinheritsched(
+        __attr: *const crate::pthread_attr_t,
+        __inheritsched: *mut c_int,
+    ) -> c_int;
+    pub fn pthread_attr_setinheritsched(
+        __attr: *mut crate::pthread_attr_t,
+        __inheritsched: c_int,
+    ) -> c_int;
+    pub fn pthread_attr_getaffinity_np(
+        __attr: *const crate::pthread_attr_t,
+        __cpusetsize: crate::size_t,
+        __cpuset: *mut crate::cpu_set_t,
+    ) -> c_int;
+    pub fn pthread_attr_setaffinity_np(
+        __attr: *mut crate::pthread_attr_t,
+        __cpusetsize: crate::size_t,
+        __cpuset: *const crate::cpu_set_t,
+    ) -> c_int;
+    pub fn pthread_attr_getsigmask_np(
+        __attr: *const crate::pthread_attr_t,
+        __sigmask: *mut crate::sigset_t,
+    ) -> c_int;
+    pub fn pthread_attr_setsigmask_np(
+        __attr: *mut crate::pthread_attr_t,
+        __sigmask: *const crate::sigset_t,
+    ) -> c_int;
+    pub fn pthread_getaffinity_np(
+        __thrd: crate::pthread_t,
+        __cpusetsize: crate::size_t,
+        __cpuset: *mut crate::cpu_set_t,
+    ) -> c_int;
+    pub fn pthread_setaffinity_np(
+        __thrd: crate::pthread_t,
+        __cpusetsize: crate::size_t,
+        __cpuset: *const crate::cpu_set_t,
+    ) -> c_int;
+    pub fn pthread_create(
+        __thrd: *mut crate::pthread_t,
+        __attr: *const crate::pthread_attr_t,
+        __fn: extern "C" fn(*mut c_void) -> *mut c_void,
+        __arg: *mut c_void,
+    ) -> c_int;
+    pub fn pthread_equal(__a: crate::pthread_t, __b: crate::pthread_t) -> c_int;
+    pub fn pthread_cleanup_push(
+        __fn: Option<unsafe extern "C" fn(*mut c_void) -> c_void>,
+        __arg: *mut c_void,
+    );
+    pub fn pthread_cleanup_pop(__execute: c_int);
+    pub fn pthread_setname_np(__thrd: crate::pthread_t, __name: *const c_char) -> c_int;
+    pub fn pthread_getname_np(
+        __thrd: crate::pthread_t,
+        __name: *mut c_char,
+        __size: crate::size_t,
+    ) -> c_int;
+    pub fn pthread_setschedparam(
+        __thrd: crate::pthread_t,
+        __policy: c_int,
+        __param: *const crate::sched_param,
+    ) -> c_int;
+    pub fn pthread_getschedparam(
+        __thrd: crate::pthread_t,
+        __policy: *mut c_int,
+        __param: *mut crate::sched_param,
+    ) -> c_int;
+    pub fn pthread_setcanceltype(__type: c_int, __oldtype: *mut c_int) -> c_int;
+    pub fn pthread_setcancelstate(__state: c_int, __oldstate: *mut c_int) -> c_int;
+    pub fn pthread_testcancel();
+    pub fn pthread_cancel(__thrd: crate::pthread_t) -> c_int;
+    pub fn pthread_atfork(
+        __prepare: Option<unsafe extern "C" fn() -> c_void>,
+        __parent: Option<unsafe extern "C" fn() -> c_void>,
+        __child: Option<unsafe extern "C" fn() -> c_void>,
+    ) -> c_int;
+    pub fn pthread_once(
+        __once: *mut crate::pthread_once_t,
+        __fn: Option<unsafe extern "C" fn() -> c_void>,
+    ) -> c_int;
+    pub fn pthread_mutexattr_gettype(
+        __attr: *const crate::pthread_mutexattr_t,
+        __type: *mut c_int,
+    ) -> c_int;
+    pub fn pthread_mutexattr_getrobust(
+        __attr: *const crate::pthread_mutexattr_t,
+        __robust: *mut c_int,
+    ) -> c_int;
+    pub fn pthread_mutexattr_setrobust(
+        __attr: *mut crate::pthread_mutexattr_t,
+        __robust: c_int,
+    ) -> c_int;
+    pub fn pthread_mutexattr_getpshared(
+        __attr: *const crate::pthread_mutexattr_t,
+        __pshared: *mut c_int,
+    ) -> c_int;
+    pub fn pthread_mutexattr_getprotocol(
+        __attr: *const crate::pthread_mutexattr_t,
+        __protocol: *mut c_int,
+    ) -> c_int;
+    pub fn pthread_mutexattr_setprotocol(
+        __attr: *mut crate::pthread_mutexattr_t,
+        __protocol: c_int,
+    ) -> c_int;
+    pub fn pthread_mutexattr_getprioceiling(
+        __attr: *const crate::pthread_mutexattr_t,
+        __prioceiling: *mut c_int,
+    ) -> c_int;
+    pub fn pthread_mutexattr_setprioceiling(
+        __attr: *mut crate::pthread_mutexattr_t,
+        __prioceiling: c_int,
+    ) -> c_int;
+    pub fn pthread_mutex_timedlock(
+        __mtx: *mut crate::pthread_mutex_t,
+        __abs_timeout: *const crate::timespec,
+    ) -> c_int;
+    pub fn pthread_mutex_consistent(__mtx: *mut crate::pthread_mutex_t) -> c_int;
+    pub fn pthread_condattr_getpshared(
+        __attr: *const crate::pthread_condattr_t,
+        __pshared: *mut c_int,
+    ) -> c_int;
+    pub fn pthread_barrierattr_init(__attr: *mut crate::pthread_barrierattr_t) -> c_int;
+    pub fn pthread_barrierattr_destroy(__attr: *mut crate::pthread_barrierattr_t) -> c_int;
+    pub fn pthread_barrierattr_setpshared(
+        __attr: *mut crate::pthread_barrierattr_t,
+        __pshared: c_int,
+    ) -> c_int;
+    pub fn pthread_barrierattr_getpshared(
+        __attr: *const crate::pthread_barrierattr_t,
+        __pshared: *mut c_int,
+    ) -> c_int;
+    pub fn pthread_barrier_init(
+        __barrier: *mut crate::pthread_barrier_t,
+        __attr: *const crate::pthread_barrierattr_t,
+        __count: c_uint,
+    ) -> c_int;
+    pub fn pthread_barrier_destroy(__barrier: *mut crate::pthread_barrier_t) -> c_int;
+    pub fn pthread_barrier_wait(__barrier: *mut crate::pthread_barrier_t) -> c_int;
+    pub fn pthread_getcpuclockid(
+        __thrd: crate::pthread_t,
+        __clockid: *mut crate::clockid_t,
+    ) -> c_int;
+}
+
+// pwd.h
+pub const NSS_BUFLEN_PASSWD: c_int = 512;
+s! {
+    pub struct passwd {
+        pub pw_name: *mut c_char,
+        pub pw_passwd: *mut c_char,
+        pub pw_uid: crate::uid_t,
+        pub pw_gid: crate::gid_t,
+        pub pw_gecos: *mut c_char,
+        pub pw_dir: *mut c_char,
+        pub pw_shell: *mut c_char,
+    }
+}
+extern "C" {
+    pub fn endpwent();
+    pub fn getpwent() -> *mut crate::passwd;
+    pub fn getpwnam_r(
+        __name: *const c_char,
+        __ret: *mut crate::passwd,
+        __buf: *mut c_char,
+        __buflen: crate::size_t,
+        __res: *mut *mut crate::passwd,
+    ) -> c_int;
+    pub fn getpwuid_r(
+        __uid: crate::uid_t,
+        __ret: *mut crate::passwd,
+        __buf: *mut c_char,
+        __buflen: crate::size_t,
+        __res: *mut *mut crate::passwd,
+    ) -> c_int;
+    pub fn setpwent();
+    pub fn putpwent(__pwd: *const crate::passwd, __f: *mut crate::FILE) -> c_int;
+    pub fn fgetpwent(__f: *mut crate::FILE) -> *mut crate::passwd;
+}
+
+// regex.h
+pub const REG_EXTENDED: c_int = 1;
+pub const REG_ICASE: c_int = 2;
+pub const REG_NEWLINE: c_int = 4;
+pub const REG_NOSUB: c_int = 8;
+pub const REG_NOTBOL: c_int = 1;
+pub const REG_NOTEOL: c_int = 2;
+pub const REG_OK: c_int = 0;
+pub const REG_NOMATCH: c_int = 1;
+pub const REG_BADPAT: c_int = 2;
+pub const REG_ECOLLATE: c_int = 3;
+pub const REG_ECTYPE: c_int = 4;
+pub const REG_EESCAPE: c_int = 5;
+pub const REG_ESUBREG: c_int = 6;
+pub const REG_EBRACK: c_int = 7;
+pub const REG_EPAREN: c_int = 8;
+pub const REG_EBRACE: c_int = 9;
+pub const REG_BADBR: c_int = 10;
+pub const REG_ERANGE: c_int = 11;
+pub const REG_ESPACE: c_int = 12;
+pub const REG_BADRPT: c_int = 13;
+pub const REG_ENOSYS: c_int = 1;
+pub type regoff_t = crate::ptrdiff_t;
+s! {
+    pub struct re_pattern_buffer {
+        pub re_nsub: crate::size_t,
+        pub __opaque: *mut c_void,
+        pub __padding: [*mut c_void; 4],
+        pub __nsub2: crate::size_t,
+        pub __padding2: c_char,
+    }
+}
+pub type regex_t = crate::re_pattern_buffer;
+s! {
+    pub struct regmatch_t {
+        pub rm_so: crate::regoff_t,
+        pub rm_eo: crate::regoff_t,
+    }
+}
+extern "C" {
+    pub fn regcomp(__regex: *mut crate::regex_t, __pattern: *const c_char, __flags: c_int)
+        -> c_int;
+    pub fn regexec(
+        __regex: *const crate::regex_t,
+        __string: *const c_char,
+        __nmatch: crate::size_t,
+        __pmatch: *mut crate::regmatch_t,
+        __flags: c_int,
+    ) -> c_int;
+    pub fn regerror(
+        __errcode: c_int,
+        __regex: *const crate::regex_t,
+        __errbuf: *mut c_char,
+        __errbuf_size: crate::size_t,
+    ) -> crate::size_t;
+    pub fn regfree(__regex: *mut crate::regex_t);
+}
+
+// sched.h
+
+// scsi/scsi_ioctl.h
+
+// semaphore.h
+pub const SEM_VALUE_MAX: c_int = 0x7FFFFFFF;
+s! {
+    pub struct sem_ {
+        pub __mlibc_count: c_uint,
+    }
+}
+pub type sem_t = crate::sem_;
+extern "C" {
+    pub fn sem_open(__name: *const c_char, __oflag: c_int, ...) -> *mut crate::sem_t;
+    pub fn sem_close(__sem: *mut crate::sem_t) -> c_int;
+    pub fn sem_unlink(__name: *const c_char) -> c_int;
+    pub fn sem_timedwait(__sem: *mut crate::sem_t, __abstime: *const crate::timespec) -> c_int;
+    pub fn sem_getvalue(__sem: *mut crate::sem_t, __sval: *mut c_int) -> c_int;
+}
+
+// shadow.h
+s! {
+    pub struct spwd {
+        pub sp_namp: *mut c_char,
+        pub sp_pwdp: *mut c_char,
+        pub sp_lstchg: c_long,
+        pub sp_min: c_long,
+        pub sp_max: c_long,
+        pub sp_warn: c_long,
+        pub sp_inact: c_long,
+        pub sp_expire: c_long,
+        pub sp_flag: c_ulong,
+    }
+}
+extern "C" {
+    pub fn putspent(__sp: *const crate::spwd, __f: *mut crate::FILE) -> c_int;
+    pub fn lckpwdf() -> c_int;
+    pub fn ulckpwdf() -> c_int;
+    pub fn getspnam(__name: *const c_char) -> *mut crate::spwd;
+    pub fn getspnam_r(
+        __name: *const c_char,
+        __sp: *mut crate::spwd,
+        __buf: *mut c_char,
+        __size: crate::size_t,
+        __res: *mut *mut crate::spwd,
+    ) -> c_int;
+    pub fn fgetspent(__f: *mut crate::FILE) -> *mut crate::spwd;
+    pub fn endspent();
+    pub fn sgetspent(__s: *const c_char) -> *mut crate::spwd;
+}
+
+// signal.h
+
+// spawn.h
+pub const POSIX_SPAWN_RESETIDS: c_int = 1;
+pub const POSIX_SPAWN_SETPGROUP: c_int = 2;
+pub const POSIX_SPAWN_SETSIGDEF: c_int = 4;
+pub const POSIX_SPAWN_SETSIGMASK: c_int = 8;
+pub const POSIX_SPAWN_SETSCHEDPARAM: c_int = 16;
+pub const POSIX_SPAWN_SETSCHEDULER: c_int = 32;
+pub const POSIX_SPAWN_USEVFORK: c_int = 64;
+pub const POSIX_SPAWN_SETSID: c_int = 128;
+s! {
+    pub struct posix_spawnattr_t {
+        pub __flags: c_int,
+        pub __pgrp: crate::pid_t,
+        pub __def: crate::sigset_t,
+        pub __mask: crate::sigset_t,
+        pub __prio: c_int,
+        pub __pol: c_int,
+        pub __fn: *mut c_void,
+        pub __pad: [c_char; 56],
+    }
+}
+s! {
+    pub struct posix_spawn_file_actions_t {
+        pub __pad0: [c_int; 2],
+        pub __actions: *mut c_void,
+        pub __pad: [c_int; 16],
+    }
+}
+extern "C" {
+    pub fn posix_spawn(
+        __pid: *mut crate::pid_t,
+        __path: *const c_char,
+        __file_actions: *const crate::posix_spawn_file_actions_t,
+        __attrs: *const crate::posix_spawnattr_t,
+        __argv: *mut *mut c_char,
+        __envp: *mut *mut c_char,
+    ) -> c_int;
+    pub fn posix_spawnattr_init(__attr: *mut crate::posix_spawnattr_t) -> c_int;
+    pub fn posix_spawnattr_destroy(__attr: *mut crate::posix_spawnattr_t) -> c_int;
+    pub fn posix_spawnattr_setflags(
+        __attr: *mut crate::posix_spawnattr_t,
+        __flags: c_short,
+    ) -> c_int;
+    pub fn posix_spawnattr_setsigdefault(
+        __attr: *mut crate::posix_spawnattr_t,
+        __sigdefault: *const crate::sigset_t,
+    ) -> c_int;
+    pub fn posix_spawnattr_setschedparam(
+        __attr: *mut crate::posix_spawnattr_t,
+        __schedparam: *const crate::sched_param,
+    ) -> c_int;
+    pub fn posix_spawnattr_setschedpolicy(
+        __attr: *mut crate::posix_spawnattr_t,
+        __schedpolicy: c_int,
+    ) -> c_int;
+    pub fn posix_spawnattr_setsigmask(
+        __attr: *mut crate::posix_spawnattr_t,
+        __sigmask: *const crate::sigset_t,
+    ) -> c_int;
+    pub fn posix_spawnattr_setpgroup(
+        __attr: *mut crate::posix_spawnattr_t,
+        __pgroup: crate::pid_t,
+    ) -> c_int;
+    pub fn posix_spawn_file_actions_init(
+        __file_actions: *mut crate::posix_spawn_file_actions_t,
+    ) -> c_int;
+    pub fn posix_spawn_file_actions_destroy(
+        __file_actions: *mut crate::posix_spawn_file_actions_t,
+    ) -> c_int;
+    pub fn posix_spawn_file_actions_adddup2(
+        __file_actions: *mut crate::posix_spawn_file_actions_t,
+        __fildes: c_int,
+        __newfildes: c_int,
+    ) -> c_int;
+    pub fn posix_spawn_file_actions_addclose(
+        __file_actions: *mut crate::posix_spawn_file_actions_t,
+        __fildes: c_int,
+    ) -> c_int;
+    pub fn posix_spawn_file_actions_addopen(
+        __file_actions: *mut crate::posix_spawn_file_actions_t,
+        __fildes: c_int,
+        __path: *const c_char,
+        __oflag: c_int,
+        __mode: crate::mode_t,
+    ) -> c_int;
+    pub fn posix_spawnp(
+        __pid: *mut crate::pid_t,
+        __file: *const c_char,
+        __file_actions: *const crate::posix_spawn_file_actions_t,
+        __attrp: *const crate::posix_spawnattr_t,
+        __argv: *mut *mut c_char,
+        __envp: *mut *mut c_char,
+    ) -> c_int;
+}
+
+// stdc-predef.h
+
+// stdio.h
+
+// stdio_ext.h
+pub const FSETLOCKING_INTERNAL: c_int = 1;
+pub const FSETLOCKING_BYCALLER: c_int = 2;
+pub const FSETLOCKING_QUERY: c_int = 3;
+extern "C" {
+    pub fn _flushlbf();
+}
+
+// stdlib.h
+
+// string.h
+
+// sys/auxv.h
+pub const AT_NULL: c_int = 0;
+extern "C" {
+    pub fn peekauxval(__type: c_ulong, __value: *mut c_ulong) -> c_int;
+    pub fn getauxval(__type: c_ulong) -> c_ulong;
+}
+
+// sys/cachectl.h
+
+// sys/endian.h
+
+// sys/epoll.h
+pub const EPOLL_NONBLOCK: c_int = O_NONBLOCK;
+extern "C" {
+    pub fn epoll_create(__flags: c_int) -> c_int;
+    pub fn epoll_create1(__flags: c_int) -> c_int;
+    pub fn epoll_ctl(
+        __epfd: c_int,
+        __mode: c_int,
+        __fd: c_int,
+        __ev: *mut crate::epoll_event,
+    ) -> c_int;
+    pub fn epoll_wait(
+        __epfd: c_int,
+        __events: *mut crate::epoll_event,
+        __maxevents: c_int,
+        __timeout: c_int,
+    ) -> c_int;
+    pub fn epoll_pwait(
+        __epfd: c_int,
+        __events: *mut crate::epoll_event,
+        __maxevents: c_int,
+        __timeout: c_int,
+        __sigmask: *const crate::sigset_t,
+    ) -> c_int;
+}
+
+// sys/errno.h
+
+// sys/eventfd.h
+pub const EFD_SEMAPHORE: c_int = 1;
+pub const EFD_CLOEXEC: c_int = O_CLOEXEC;
+pub const EFD_NONBLOCK: c_int = O_NONBLOCK;
+pub type eventfd_t = u64;
+extern "C" {
+    pub fn eventfd(__initval: c_uint, __flags: c_int) -> c_int;
+    pub fn eventfd_read(__fd: c_int, __value: *mut crate::eventfd_t) -> c_int;
+    pub fn eventfd_write(__fd: c_int, __value: crate::eventfd_t) -> c_int;
+}
+
+// sys/fcntl.h
+
+// sys/file.h
+extern "C" {
+    pub fn flock64(__fd: c_int, __op: c_int) -> c_int;
+}
+
+// sys/fsuid.h
+extern "C" {
+    pub fn setfsuid(__uid: crate::uid_t) -> c_int;
+    pub fn setfsgid(__gid: crate::gid_t) -> c_int;
+}
+
+// sys/inotify.h
+pub const IN_ACCESS: c_int = 0x1;
+pub const IN_ATTRIB: c_int = 0x4;
+pub const IN_CLOSE_WRITE: c_int = 0x8;
+pub const IN_CLOSE_NOWRITE: c_int = 0x10;
+pub const IN_CREATE: c_int = 0x100;
+pub const IN_DELETE: c_int = 0x200;
+pub const IN_DELETE_SELF: c_int = 0x400;
+pub const IN_MODIFY: c_int = 0x2;
+pub const IN_MOVE_SELF: c_int = 0x800;
+pub const IN_MOVED_FROM: c_int = 0x40;
+pub const IN_MOVED_TO: c_int = 0x80;
+pub const IN_OPEN: c_int = 0x20;
+pub const IN_MOVE: c_int = IN_MOVED_FROM | IN_MOVED_TO;
+pub const IN_CLOSE: c_int = IN_CLOSE_WRITE | IN_CLOSE_NOWRITE;
+pub const IN_DONT_FOLLOW: c_int = 0x2000000;
+pub const IN_EXCL_UNLINK: c_int = 0x4000000;
+pub const IN_MASK_ADD: c_int = 0x20000000;
+pub const IN_ONESHOT: c_int = 0x80000000;
+pub const IN_ONLYDIR: c_int = 0x1000000;
+pub const IN_IGNORED: c_int = 0x8000;
+pub const IN_ISDIR: c_int = 0x40000000;
+pub const IN_Q_OVERFLOW: c_int = 0x4000;
+pub const IN_UNMOUNT: c_int = 0x2000;
+pub const IN_ALL_EVENTS: c_int = IN_ACCESS
+    | IN_MODIFY
+    | IN_ATTRIB
+    | IN_CLOSE_WRITE
+    | IN_CLOSE_NOWRITE
+    | IN_OPEN
+    | IN_MOVED_FROM
+    | IN_MOVED_TO
+    | IN_DELETE
+    | IN_CREATE
+    | IN_DELETE_SELF
+    | IN_MOVE_SELF;
+s! {
+    pub struct inotify_event {
+        pub wd: c_int,
+        pub mask: c_uint,
+        pub cookie: c_uint,
+        pub len: c_uint,
+        pub name: *mut c_char,
+    }
+}
+extern "C" {
+    pub fn inotify_init() -> c_int;
+    pub fn inotify_init1(__flags: c_int) -> c_int;
+    pub fn inotify_add_watch(__ifd: c_int, __path: *const c_char, __mask: u32) -> c_int;
+    pub fn inotify_rm_watch(__ifd: c_int, __wd: c_int) -> c_int;
+}
+
+// sys/io.h
+extern "C" {
+    pub fn ioperm(__from: c_ulong, __num: c_ulong, __turn_on: c_int) -> c_int;
+    pub fn iopl(__level: c_int) -> c_int;
+    pub fn inb(__port: c_ushort) -> c_uchar;
+    pub fn inb_p(__port: c_ushort) -> c_uchar;
+    pub fn inw(__port: c_ushort) -> c_ushort;
+    pub fn inw_p(__port: c_ushort) -> c_ushort;
+    pub fn inl(__port: c_ushort) -> c_uint;
+    pub fn inl_p(__port: c_ushort) -> c_uint;
+    pub fn outb(value: c_uchar, __port: c_ushort);
+    pub fn outb_p(__value: c_uchar, __port: c_ushort);
+    pub fn outw(__value: c_ushort, __port: c_ushort);
+    pub fn outw_p(__value: c_ushort, __port: c_ushort);
+    pub fn outl(__value: c_uint, __port: c_ushort);
+    pub fn outl_p(__value: c_uint, __port: c_ushort);
+    pub fn insb(__port: c_ushort, __addr: *mut c_void, __count: c_ulong);
+    pub fn insw(__port: c_ushort, __addr: *mut c_void, __count: c_ulong);
+    pub fn insl(__port: c_ushort, __addr: *mut c_void, __count: c_ulong);
+    pub fn outsb(__port: c_ushort, __addr: *const c_void, __count: c_ulong);
+    pub fn outsw(__port: c_ushort, __addr: *const c_void, __count: c_ulong);
+    pub fn outsl(__port: c_ushort, __addr: *const c_void, __count: c_ulong);
+}
+
+// sys/ioctl.h
+pub const FIONREAD: c_ulong = 0x541B;
+pub const FIONBIO: c_ulong = 0x5421;
+pub const FIONCLEX: c_ulong = 0x5450;
+pub const FIOCLEX: c_ulong = 0x5451;
+pub const SIOCGIFMTU: c_ulong = 0x8921;
+pub const SIOCSIFMTU: c_ulong = 0x8922;
+pub const SIOCDEVPRIVATE: c_ulong = 0x89F0;
+extern "C" {
+    pub fn ioctl(__fd: c_int, __request: c_ulong, ...) -> c_int;
+}
+
+// sys/ipc.h
+
+// sys/kd.h
+
+// sys/klog.h
+extern "C" {
+    pub fn klogctl(__type: c_int, __bufp: *mut c_char, __len: c_int) -> c_int;
+}
+
+// sys/mman.h
+extern "C" {
+    pub fn mmap64(
+        __addr: *mut c_void,
+        __size: crate::size_t,
+        __prot: c_int,
+        __flags: c_int,
+        __fd: c_int,
+        __offset: crate::off64_t,
+    ) -> *mut c_void;
+    pub fn mprotect(__addr: *mut c_void, __size: crate::size_t, __prot: c_int) -> c_int;
+    pub fn posix_madvise(__addr: *mut c_void, __size: crate::size_t, __advise: c_int) -> c_int;
+    pub fn msync(__addr: *mut c_void, __size: crate::size_t, __flags: c_int) -> c_int;
+    pub fn shm_open(__name: *const c_char, __oflag: c_int, __mode: crate::mode_t) -> c_int;
+    pub fn shm_unlink(__name: *const c_char) -> c_int;
+    pub fn mremap(
+        __old_address: *mut c_void,
+        __old_size: crate::size_t,
+        __new_size: crate::size_t,
+        __flags: c_int,
+        ...
+    ) -> *mut c_void;
+    pub fn remap_file_pages(
+        __addr: *mut c_void,
+        __size: crate::size_t,
+        __prot: c_int,
+        __pgoff: crate::size_t,
+        __flags: c_int,
+    ) -> c_int;
+    pub fn memfd_create(__name: *const c_char, __flags: c_uint) -> c_int;
+    pub fn madvise(__addr: *mut c_void, __size: crate::size_t, __advise: c_int) -> c_int;
+}
+
+// sys/msg.h
+extern "C" {
+    pub fn msgget(__key: crate::key_t, __msgflg: c_int) -> c_int;
+    pub fn msgctl(__msqid: c_int, __cmd: c_int, __buf: *mut crate::msqid64_ds) -> c_int;
+    pub fn msgrcv(
+        __msqid: c_int,
+        __msgp: *mut c_void,
+        __size: crate::size_t,
+        __msgtyp: c_long,
+        __msgflg: c_int,
+    ) -> crate::ssize_t;
+    pub fn msgsnd(
+        __msqid: c_int,
+        __msgp: *const c_void,
+        __size: crate::size_t,
+        __msgflg: c_int,
+    ) -> c_int;
+}
+
+// sys/param.h
+pub const NBBY: c_int = CHAR_BIT;
+pub const NGROUPS: c_int = NGROUPS_MAX;
+pub const MAXNAMLEN: c_int = 255;
+pub const MAXPATHLEN: c_int = 4096;
+pub const MAXSYMLINKS: c_int = 20;
+
+// sys/personality.h
+extern "C" {
+    pub fn personality(__persona: c_ulong) -> c_int;
+}
+
+// sys/poll.h
+
+// sys/prctl.h
+pub const PR_SET_PDEATHSIG: c_int = 1;
+pub const PR_GET_PDEATHSIG: c_int = 2;
+pub const PR_GET_DUMPABLE: c_int = 3;
+pub const PR_SET_DUMPABLE: c_int = 4;
+pub const PR_GET_UNALIGN: c_int = 5;
+pub const PR_SET_UNALIGN: c_int = 6;
+pub const PR_UNALIGN_NOPRINT: c_int = 1;
+pub const PR_UNALIGN_SIGBUS: c_int = 2;
+pub const PR_GET_KEEPCAPS: c_int = 7;
+pub const PR_SET_KEEPCAPS: c_int = 8;
+pub const PR_GET_FPEMU: c_int = 9;
+pub const PR_SET_FPEMU: c_int = 10;
+pub const PR_FPEMU_NOPRINT: c_int = 1;
+pub const PR_FPEMU_SIGFPE: c_int = 2;
+pub const PR_GET_FPEXC: c_int = 11;
+pub const PR_SET_FPEXC: c_int = 12;
+pub const PR_FP_EXC_SW_ENABLE: c_int = 0x80;
+pub const PR_FP_EXC_DIV: c_int = 0x010000;
+pub const PR_FP_EXC_OVF: c_int = 0x020000;
+pub const PR_FP_EXC_UND: c_int = 0x040000;
+pub const PR_FP_EXC_RES: c_int = 0x080000;
+pub const PR_FP_EXC_INV: c_int = 0x100000;
+pub const PR_FP_EXC_DISABLED: c_int = 0;
+pub const PR_FP_EXC_NONRECOV: c_int = 1;
+pub const PR_FP_EXC_ASYNC: c_int = 2;
+pub const PR_FP_EXC_PRECISE: c_int = 3;
+pub const PR_GET_TIMING: c_int = 13;
+pub const PR_SET_TIMING: c_int = 14;
+pub const PR_TIMING_STATISTICAL: c_int = 0;
+pub const PR_TIMING_TIMESTAMP: c_int = 1;
+pub const PR_SET_NAME: c_int = 15;
+pub const PR_GET_NAME: c_int = 16;
+pub const PR_GET_ENDIAN: c_int = 19;
+pub const PR_SET_ENDIAN: c_int = 20;
+pub const PR_ENDIAN_BIG: c_int = 0;
+pub const PR_ENDIAN_LITTLE: c_int = 1;
+pub const PR_ENDIAN_PPC_LITTLE: c_int = 2;
+pub const PR_GET_SECCOMP: c_int = 21;
+pub const PR_SET_SECCOMP: c_int = 22;
+pub const PR_CAPBSET_READ: c_int = 23;
+pub const PR_CAPBSET_DROP: c_int = 24;
+pub const PR_GET_TSC: c_int = 25;
+pub const PR_SET_TSC: c_int = 26;
+pub const PR_TSC_ENABLE: c_int = 1;
+pub const PR_TSC_SIGSEGV: c_int = 2;
+pub const PR_GET_SECUREBITS: c_int = 27;
+pub const PR_SET_SECUREBITS: c_int = 28;
+pub const PR_SET_TIMERSLACK: c_int = 29;
+pub const PR_GET_TIMERSLACK: c_int = 30;
+pub const PR_TASK_PERF_EVENTS_DISABLE: c_int = 31;
+pub const PR_TASK_PERF_EVENTS_ENABLE: c_int = 32;
+pub const PR_MCE_KILL: c_int = 33;
+pub const PR_MCE_KILL_CLEAR: c_int = 0;
+pub const PR_MCE_KILL_SET: c_int = 1;
+pub const PR_MCE_KILL_LATE: c_int = 0;
+pub const PR_MCE_KILL_EARLY: c_int = 1;
+pub const PR_MCE_KILL_DEFAULT: c_int = 2;
+pub const PR_MCE_KILL_GET: c_int = 34;
+pub const PR_SET_MM: c_int = 35;
+pub const PR_SET_MM_START_CODE: c_int = 1;
+pub const PR_SET_MM_END_CODE: c_int = 2;
+pub const PR_SET_MM_START_DATA: c_int = 3;
+pub const PR_SET_MM_END_DATA: c_int = 4;
+pub const PR_SET_MM_START_STACK: c_int = 5;
+pub const PR_SET_MM_START_BRK: c_int = 6;
+pub const PR_SET_MM_BRK: c_int = 7;
+pub const PR_SET_MM_ARG_START: c_int = 8;
+pub const PR_SET_MM_ARG_END: c_int = 9;
+pub const PR_SET_MM_ENV_START: c_int = 10;
+pub const PR_SET_MM_ENV_END: c_int = 11;
+pub const PR_SET_MM_AUXV: c_int = 12;
+pub const PR_SET_MM_EXE_FILE: c_int = 13;
+pub const PR_SET_MM_MAP: c_int = 14;
+pub const PR_SET_MM_MAP_SIZE: c_int = 15;
+pub const PR_SET_CHILD_SUBREAPER: c_int = 36;
+pub const PR_GET_CHILD_SUBREAPER: c_int = 37;
+pub const PR_SET_NO_NEW_PRIVS: c_int = 38;
+pub const PR_GET_NO_NEW_PRIVS: c_int = 39;
+pub const PR_GET_TID_ADDRESS: c_int = 40;
+pub const PR_SET_THP_DISABLE: c_int = 41;
+pub const PR_GET_THP_DISABLE: c_int = 42;
+pub const PR_MPX_ENABLE_MANAGEMENT: c_int = 43;
+pub const PR_MPX_DISABLE_MANAGEMENT: c_int = 44;
+pub const PR_SET_FP_MODE: c_int = 45;
+pub const PR_GET_FP_MODE: c_int = 46;
+pub const PR_FP_MODE_FR: c_int = 1 << 0;
+pub const PR_FP_MODE_FRE: c_int = 1 << 1;
+pub const PR_CAP_AMBIENT: c_int = 47;
+pub const PR_CAP_AMBIENT_IS_SET: c_int = 1;
+pub const PR_CAP_AMBIENT_RAISE: c_int = 2;
+pub const PR_CAP_AMBIENT_LOWER: c_int = 3;
+pub const PR_CAP_AMBIENT_CLEAR_ALL: c_int = 4;
+extern "C" {
+    pub fn prctl(__op: c_int, ...) -> c_int;
+}
+
+// sys/ptrace.h
+pub const PTRACE_TRACEME: c_int = 0;
+pub const PT_TRACE_ME: c_int = PTRACE_TRACEME;
+pub const PT_READ_I: c_int = PTRACE_PEEKTEXT;
+pub const PT_READ_D: c_int = PTRACE_PEEKDATA;
+pub const PT_READ_U: c_int = PTRACE_PEEKUSER;
+pub const PT_WRITE_I: c_int = PTRACE_POKETEXT;
+pub const PT_WRITE_D: c_int = PTRACE_POKEDATA;
+pub const PT_WRITE_U: c_int = PTRACE_POKEUSER;
+pub const PT_CONTINUE: c_int = PTRACE_CONT;
+pub const PT_KILL: c_int = PTRACE_KILL;
+pub const PT_STEP: c_int = PTRACE_SINGLESTEP;
+pub const PT_GETREGS: c_int = PTRACE_GETREGS;
+pub const PT_SETREGS: c_int = PTRACE_SETREGS;
+pub const PT_GETFPREGS: c_int = PTRACE_GETFPREGS;
+pub const PT_SETFPREGS: c_int = PTRACE_SETFPREGS;
+pub const PT_ATTACH: c_int = PTRACE_ATTACH;
+pub const PT_DETACH: c_int = PTRACE_DETACH;
+pub const PT_GETFPXREGS: c_int = PTRACE_GETFPXREGS;
+pub const PT_SETFPXREGS: c_int = PTRACE_SETFPXREGS;
+pub const PT_SYSCALL: c_int = PTRACE_SYSCALL;
+pub const PT_SETOPTIONS: c_int = PTRACE_SETOPTIONS;
+pub const PT_GETEVENTMSG: c_int = PTRACE_GETEVENTMSG;
+pub const PT_GETSIGINFO: c_int = PTRACE_GETSIGINFO;
+pub const PT_SETSIGINFO: c_int = PTRACE_SETSIGINFO;
+s! {
+    pub struct ptrace_peeksiginfo_args {
+        pub offset: u64,
+        pub flags: u32,
+        pub nr: i32,
+    }
+}
+extern "C" {
+    pub fn ptrace(__op: c_int, ...) -> c_long;
+}
+
+// sys/quota.h
+extern "C" {
+    pub fn quotactl(
+        __cmd: c_int,
+        __special: *const c_char,
+        __id: c_int,
+        __addr: crate::caddr_t,
+    ) -> c_int;
+}
+
+// sys/random.h
+extern "C" {
+    pub fn getrandom(
+        __buffer: *mut c_void,
+        __max_size: crate::size_t,
+        __flags: c_uint,
+    ) -> crate::ssize_t;
+}
+
+// sys/reboot.h
+extern "C" {
+    pub fn reboot(__arg: c_int) -> c_int;
+}
+
+// sys/reg.h
+pub const R15: c_int = 0;
+pub const R14: c_int = 1;
+pub const R13: c_int = 2;
+pub const R12: c_int = 3;
+pub const RBP: c_int = 4;
+pub const RBX: c_int = 5;
+pub const R11: c_int = 6;
+pub const R10: c_int = 7;
+pub const R9: c_int = 8;
+pub const R8: c_int = 9;
+pub const RAX: c_int = 10;
+pub const RCX: c_int = 11;
+pub const RDX: c_int = 12;
+pub const RSI: c_int = 13;
+pub const RDI: c_int = 14;
+pub const ORIG_RAX: c_int = 15;
+pub const RIP: c_int = 16;
+pub const CS: c_int = 17;
+pub const EFLAGS: c_int = 18;
+pub const RSP: c_int = 19;
+pub const SS: c_int = 20;
+pub const FS_BASE: c_int = 21;
+pub const GS_BASE: c_int = 22;
+pub const DS: c_int = 23;
+pub const ES: c_int = 24;
+pub const FS: c_int = 25;
+pub const GS: c_int = 26;
+
+// sys/resource.h
+pub const PRIO_PROCESS: c_int = 1;
+pub const PRIO_PGRP: c_int = 2;
+pub const PRIO_USER: c_int = 3;
+pub const RLIM_NLIMITS: c_int = RLIMIT_NLIMITS;
+s! {
+    pub struct rlimit {
+        pub rlim_cur: crate::rlim_t,
+        pub rlim_max: crate::rlim_t,
+    }
+}
+extern "C" {
+    pub fn getpriority(__which: c_int, __who: crate::id_t) -> c_int;
+    pub fn setpriority(__which: c_int, __who: crate::id_t, __prio: c_int) -> c_int;
+    pub fn getrlimit(__resource: c_int, __rlim: *mut crate::rlimit) -> c_int;
+    pub fn getrlimit64(__resource: c_int, __rlim: *mut crate::rlimit) -> c_int;
+    pub fn setrlimit(__resource: c_int, __rlim: *const crate::rlimit) -> c_int;
+    pub fn setrlimit64(__resource: c_int, __rlim: *const crate::rlimit) -> c_int;
+    pub fn prlimit(
+        __pid: crate::pid_t,
+        __resource: c_int,
+        __new_limits: *const crate::rlimit,
+        __old_limits: *mut crate::rlimit,
+    ) -> c_int;
+}
+
+// sys/select.h
+
+// sys/sem.h
+pub const GETPID: c_int = 11;
+pub const GETVAL: c_int = 12;
+pub const GETALL: c_int = 13;
+pub const SETVAL: c_int = 16;
+pub const SETALL: c_int = 17;
+pub const SEM_UNDO: c_int = 0x1000;
+s! {
+    pub struct sembuf {
+        pub sem_num: c_ushort,
+        pub sem_op: c_short,
+        pub sem_flg: c_short,
+    }
+    pub struct semid_ds {
+        pub sem_perm: crate::ipc64_perm,
+        pub sem_otime: crate::time_t,
+        pub sem_ctime: crate::time_t,
+        pub sem_nsems: c_ulong,
+    }
+}
+extern "C" {
+    pub fn semget(__key: crate::key_t, __nsems: c_int, __semflg: c_int) -> c_int;
+    pub fn semop(__semid: c_int, __sops: *mut crate::sembuf, __nsops: crate::size_t) -> c_int;
+    pub fn semctl(__semid: c_int, __semnum: c_int, __op: c_int, ...) -> c_int;
+}
+
+// sys/sendfile.h
+extern "C" {
+    pub fn sendfile(
+        __out_fd: c_int,
+        __in_fd: c_int,
+        __offset: *mut crate::off_t,
+        __size: crate::size_t,
+    ) -> crate::ssize_t;
+}
+
+// sys/shm.h
+extern "C" {
+    pub fn shmat(__shmid: c_int, __shmaddr: *const c_void, __shmflg: c_int) -> *mut c_void;
+    pub fn shmctl(__shmid: c_int, __cmd: c_int, __buf: *mut crate::shmid_ds) -> c_int;
+    pub fn shmdt(__shmaddr: *const c_void) -> c_int;
+    pub fn shmget(__key: crate::key_t, __size: crate::size_t, __shmflg: c_int) -> c_int;
+}
+
+// sys/signal.h
+
+// sys/signalfd.h
+pub const SFD_CLOEXEC: c_int = O_CLOEXEC;
+pub const SFD_NONBLOCK: c_int = O_NONBLOCK;
+s! {
+    pub struct signalfd_siginfo {
+        pub ssi_signo: u32,
+        pub ssi_errno: i32,
+        pub ssi_code: i32,
+        pub ssi_pid: u32,
+        pub ssi_uid: u32,
+        pub ssi_fd: i32,
+        pub ssi_tid: u32,
+        pub ssi_band: u32,
+        pub ssi_overrun: u32,
+        pub ssi_trapno: u32,
+        pub ssi_status: i32,
+        pub ssi_int: i32,
+        pub ssi_ptr: u64,
+        pub ssi_utime: u64,
+        pub ssi_stime: u64,
+        pub ssi_addr: u64,
+        pub ssi_addr_lsb: u16,
+        pub pad: [u8; 46],
+    }
+}
+extern "C" {
+    pub fn signalfd(__fd: c_int, __mask: *const crate::sigset_t, __flags: c_int) -> c_int;
+}
+
+// sys/socket.h
+
+// sys/stat.h
+extern "C" {
+    pub fn fstat64(__fd: c_int, __result: *mut crate::stat) -> c_int;
+    pub fn lstat64(__pathname: *const c_char, __buf: *mut crate::stat) -> c_int;
+    pub fn mkfifoat(__dirfd: c_int, __pathname: *const c_char, __mode: crate::mode_t) -> c_int;
+}
+
+// sys/statfs.h
+extern "C" {
+    pub fn fstatfs64(__fd: c_int, __buf: *mut crate::statfs64) -> c_int;
+}
+
+// sys/statvfs.h
+extern "C" {
+    pub fn statvfs64(__pathname: *const c_char, __buf: *mut crate::statvfs64) -> c_int;
+    pub fn fstatvfs64(__fd: c_int, __buf: *mut crate::statvfs64) -> c_int;
+}
+
+// sys/swap.h
+extern "C" {
+    pub fn swapon(__path: *const c_char, __flags: c_int) -> c_int;
+    pub fn swapoff(__path: *const c_char) -> c_int;
+}
+
+// sys/sysinfo.h
+s! {
+    pub struct sysinfo {
+        pub uptime: c_long,
+        pub loads: [c_ulong; 3],
+        pub totalram: c_ulong,
+        pub freeram: c_ulong,
+        pub sharedram: c_ulong,
+        pub bufferram: c_ulong,
+        pub totalswap: c_ulong,
+        pub freeswap: c_ulong,
+        pub procs: c_ushort,
+        pub totalhigh: c_ulong,
+        pub freehigh: c_ulong,
+        pub mem_unit: c_uint,
+        pub _f: [c_char; 0],
+    }
+}
+extern "C" {
+    pub fn sysinfo(__info: *mut crate::sysinfo) -> c_int;
+    pub fn get_nprocs() -> c_int;
+    pub fn get_nprocs_conf() -> c_int;
+}
+
+// sys/syslog.h
+
+// sys/sysmacros.h
+
+// sys/termios.h
+pub const B0: crate::speed_t = 0;
+pub const B50: crate::speed_t = 1;
+pub const B75: crate::speed_t = 2;
+pub const B110: crate::speed_t = 3;
+pub const B134: crate::speed_t = 4;
+pub const B150: crate::speed_t = 5;
+pub const B200: crate::speed_t = 6;
+pub const B300: crate::speed_t = 7;
+pub const B600: crate::speed_t = 8;
+pub const B1200: crate::speed_t = 9;
+pub const B1800: crate::speed_t = 10;
+pub const B2400: crate::speed_t = 11;
+pub const B4800: crate::speed_t = 12;
+pub const B9600: crate::speed_t = 13;
+pub const B19200: crate::speed_t = 14;
+pub const B38400: crate::speed_t = 15;
+pub const B57600: crate::speed_t = 0o010001;
+pub const B115200: crate::speed_t = 0o010002;
+pub const B230400: crate::speed_t = 0o010003;
+pub const B460800: crate::speed_t = 0o010004;
+pub const B500000: crate::speed_t = 0o010005;
+pub const B576000: crate::speed_t = 0o010006;
+pub const B921600: crate::speed_t = 0o010007;
+pub const B1000000: crate::speed_t = 0o010010;
+pub const B1152000: crate::speed_t = 0o010011;
+pub const B1500000: crate::speed_t = 0o010012;
+pub const B2000000: crate::speed_t = 0o010013;
+pub const B2500000: crate::speed_t = 0o010014;
+pub const B3000000: crate::speed_t = 0o010015;
+pub const B3500000: crate::speed_t = 0o010016;
+pub const B4000000: crate::speed_t = 0o010017;
+pub const TCSANOW: c_int = 0;
+pub const TCSADRAIN: c_int = 1;
+pub const TCSAFLUSH: c_int = 2;
+pub const TIOCM_DTR: c_int = 0x002;
+pub const TIOCM_RTS: c_int = 0x004;
+pub const TIOCSCTTY: c_ulong = 0x540E;
+pub const TIOCGPGRP: c_int = 0x540F;
+pub const TIOCSPGRP: c_int = 0x5410;
+pub const TIOCGWINSZ: c_ulong = 0x5413;
+pub const TIOCSWINSZ: c_ulong = 0x5414;
+pub const TIOCGSID: c_int = 0x5429;
+
+// sys/time.h
+s! {
+    pub struct timezone {
+        pub tz_minuteswest: c_int,
+        pub tz_dsttime: c_int,
+    }
+}
+extern "C" {
+    pub fn gettimeofday(__result: *mut crate::timeval, __unused: *mut c_void) -> c_int;
+    pub fn settimeofday(__result: *const crate::timeval, __zone: *const crate::timezone) -> c_int;
+    pub fn timeradd(
+        __a: *const crate::timeval,
+        __b: *const crate::timeval,
+        __res: *mut crate::timeval,
+    );
+    pub fn timersub(
+        __a: *const crate::timeval,
+        __b: *const crate::timeval,
+        __res: *mut crate::timeval,
+    );
+    pub fn timerclear(__tvp: *mut crate::timeval);
+    pub fn timerisset(__tvp: *mut crate::timeval) -> c_int;
+    pub fn getitimer(__which: c_int, __curr_value: *mut crate::itimerval) -> c_int;
+    pub fn setitimer(
+        __which: c_int,
+        __new_value: *const crate::itimerval,
+        __old_value: *mut crate::itimerval,
+    ) -> c_int;
+}
+
+// sys/timeb.h
+
+// sys/timerfd.h
+pub const TFD_NONBLOCK: c_int = O_NONBLOCK;
+pub const TFD_CLOEXEC: c_int = O_CLOEXEC;
+pub const TFD_TIMER_ABSTIME: c_int = 1;
+pub const TFD_TIMER_CANCEL_ON_SET: c_int = 1 << 1;
+extern "C" {
+    pub fn timerfd_create(__clockid: c_int, __flags: c_int) -> c_int;
+    pub fn timerfd_settime(
+        __fd: c_int,
+        __flags: c_int,
+        __value: *const crate::itimerspec,
+        __oldvalue: *mut crate::itimerspec,
+    ) -> c_int;
+    pub fn timerfd_gettime(__fd: c_int, __value: *mut crate::itimerspec) -> c_int;
+}
+
+// sys/times.h
+s! {
+    pub struct tms {
+        pub tms_utime: crate::clock_t,
+        pub tms_stime: crate::clock_t,
+        pub tms_cutime: crate::clock_t,
+        pub tms_cstime: crate::clock_t,
+    }
+}
+
+// sys/timex.h
+pub const ADJ_OFFSET: c_int = 0x0001;
+pub const ADJ_FREQUENCY: c_int = 0x0002;
+pub const ADJ_MAXERROR: c_int = 0x0004;
+pub const ADJ_ESTERROR: c_int = 0x0008;
+pub const ADJ_STATUS: c_int = 0x0010;
+pub const ADJ_TIMECONST: c_int = 0x0020;
+pub const ADJ_TAI: c_int = 0x0080;
+pub const ADJ_SETOFFSET: c_int = 0x0100;
+pub const ADJ_MICRO: c_int = 0x1000;
+pub const ADJ_NANO: c_int = 0x2000;
+pub const ADJ_TICK: c_int = 0x4000;
+pub const ADJ_OFFSET_SINGLESHOT: c_int = 0x8001;
+pub const ADJ_OFFSET_SS_READ: c_int = 0xa001;
+pub const STA_PLL: c_int = 0x0001;
+pub const STA_PPSFREQ: c_int = 0x0002;
+pub const STA_PPSTIME: c_int = 0x0004;
+pub const STA_FLL: c_int = 0x0008;
+pub const STA_INS: c_int = 0x0010;
+pub const STA_DEL: c_int = 0x0020;
+pub const STA_UNSYNC: c_int = 0x0040;
+pub const STA_FREQHOLD: c_int = 0x0080;
+pub const STA_PPSSIGNAL: c_int = 0x0100;
+pub const STA_PPSJITTER: c_int = 0x0200;
+pub const STA_PPSWANDER: c_int = 0x0400;
+pub const STA_PPSERROR: c_int = 0x0800;
+pub const STA_CLOCKERR: c_int = 0x1000;
+pub const STA_NANO: c_int = 0x2000;
+pub const STA_MODE: c_int = 0x4000;
+pub const STA_CLK: c_int = 0x8000;
+s! {
+    pub struct timex {
+        pub modes: c_int,
+        pub offset: c_long,
+        pub freq: c_long,
+        pub maxerror: c_long,
+        pub esterror: c_long,
+        pub status: c_int,
+        pub constant: c_long,
+        pub precision: c_long,
+        pub tolerance: c_long,
+        pub time: crate::timeval,
+        pub tick: c_long,
+        pub ppsfreq: c_long,
+        pub jitter: c_long,
+        pub shift: c_int,
+        pub stabil: c_long,
+        pub jitcnt: c_long,
+        pub calcnt: c_long,
+        pub errcnt: c_long,
+        pub stbcnt: c_long,
+        pub tai: c_int,
+        pub __padding: [c_int; 11],
+    }
+}
+extern "C" {
+    pub fn adjtimex(__buf: *mut crate::timex) -> c_int;
+    pub fn clock_adjtime(__clockid: crate::clockid_t, __buf: *mut crate::timex) -> c_int;
+    pub fn ntp_adjtime(__buf: *mut crate::timex) -> c_int;
+}
+
+// sys/types.h
+
+// sys/ucontext.h
+
+// sys/uio.h
+extern "C" {
+    pub fn preadv(
+        __fd: c_int,
+        __iov: *const crate::iovec,
+        __iovcnt: c_int,
+        __offset: crate::off_t,
+    ) -> crate::ssize_t;
+    pub fn pwritev(
+        __fd: c_int,
+        __iov: *const crate::iovec,
+        __iovcnt: c_int,
+        __offset: crate::off_t,
+    ) -> crate::ssize_t;
+}
+
+// sys/un.h
+
+// sys/utsname.h
+
+// sys/vfs.h
+
+// sys/vt.h
+
+// sys/wait.h
+
+// sys/xattr.h
+extern "C" {
+    pub fn setxattr(
+        __path: *const c_char,
+        __name: *const c_char,
+        __val: *const c_void,
+        __size: crate::size_t,
+        __flags: c_int,
+    ) -> c_int;
+    pub fn lsetxattr(
+        __path: *const c_char,
+        __name: *const c_char,
+        __val: *const c_void,
+        __size: crate::size_t,
+        __flags: c_int,
+    ) -> c_int;
+    pub fn fsetxattr(
+        __fd: c_int,
+        __name: *const c_char,
+        __val: *const c_void,
+        __size: crate::size_t,
+        __flags: c_int,
+    ) -> c_int;
+    pub fn getxattr(
+        __path: *const c_char,
+        __name: *const c_char,
+        __val: *mut c_void,
+        __size: crate::size_t,
+    ) -> crate::ssize_t;
+    pub fn lgetxattr(
+        __path: *const c_char,
+        __name: *const c_char,
+        __val: *mut c_void,
+        __size: crate::size_t,
+    ) -> crate::ssize_t;
+    pub fn fgetxattr(
+        __fd: c_int,
+        __name: *const c_char,
+        __val: *mut c_void,
+        __size: crate::size_t,
+    ) -> crate::ssize_t;
+    pub fn listxattr(
+        __path: *const c_char,
+        __list: *mut c_char,
+        __size: crate::size_t,
+    ) -> crate::ssize_t;
+    pub fn llistxattr(
+        __path: *const c_char,
+        __list: *mut c_char,
+        __size: crate::size_t,
+    ) -> crate::ssize_t;
+    pub fn flistxattr(__fd: c_int, __list: *mut c_char, __size: crate::size_t) -> crate::ssize_t;
+    pub fn removexattr(__path: *const c_char, __name: *const c_char) -> c_int;
+    pub fn lremovexattr(__path: *const c_char, __name: *const c_char) -> c_int;
+    pub fn fremovexattr(__fd: c_int, __name: *const c_char) -> c_int;
+}
+
+// termios.h
+
+// time.h
+
+// uchar.h
+pub type char16_t = c_ushort;
+pub type char32_t = c_uint;
+extern "C" {
+    pub fn c32rtomb(
+        __pmb: *mut c_char,
+        __c32: crate::char32_t,
+        __ps: *mut crate::mbstate_t,
+    ) -> crate::size_t;
+    pub fn mbrtoc32(
+        __pc32: *mut crate::char32_t,
+        __pmb: *const c_char,
+        __max: crate::size_t,
+        __ps: *mut crate::mbstate_t,
+    ) -> crate::size_t;
+}
+
+// ucontext.h
+extern "C" {
+    pub fn getcontext(__uctx: *mut crate::ucontext_t) -> c_int;
+    pub fn setcontext(__uctx: *const crate::ucontext_t) -> c_int;
+    pub fn makecontext(
+        __uctx: *mut crate::ucontext_t,
+        __fn: Option<unsafe extern "C" fn() -> c_void>,
+        __argc: c_int,
+        ...
+    );
+    pub fn swapcontext(__uctx: *mut crate::ucontext_t, __newctx: *const crate::ucontext_t)
+        -> c_int;
+}
+
+// unistd.h
+
+// utmp.h
+pub const EMPTY: c_int = 0;
+pub const RUN_LVL: c_int = 1;
+pub const BOOT_TIME: c_int = 2;
+pub const NEW_TIME: c_int = 3;
+pub const OLD_TIME: c_int = 4;
+pub const INIT_PROCESS: c_int = 5;
+pub const LOGIN_PROCESS: c_int = 6;
+pub const USER_PROCESS: c_int = 7;
+pub const DEAD_PROCESS: c_int = 8;
+pub const ACCOUNTING: c_int = 9;
+pub const UT_LINESIZE: c_int = 32;
+pub const UT_NAMESIZE: c_int = 32;
+pub const UT_HOSTSIZE: c_int = 256;
+s! {
+    pub struct exit_status {
+        pub e_termination: c_short,
+        pub e_exit: c_short,
+    }
+    pub struct utmp {
+        pub ut_type: c_short,
+        pub ut_pid: crate::pid_t,
+        pub ut_line: [c_char; 32],
+        pub ut_id: [c_char; 4],
+        pub ut_user: [c_char; 32],
+        pub ut_host: [c_char; 256],
+        pub ut_exit: crate::exit_status,
+        pub ut_session: c_long,
+        pub ut_tv: crate::timeval,
+        pub ut_addr_v6: [i32; 4],
+        pub __unused: [c_char; 20],
+    }
+    pub struct lastlog {
+        pub ll_time: crate::time_t,
+        pub ll_line: [c_char; 32],
+        pub ll_host: [c_char; 256],
+    }
+}
+extern "C" {
+    pub fn setutent();
+    pub fn getutent() -> *mut crate::utmp;
+    pub fn getutent_r(__buf: *mut crate::utmp, __res: *mut *mut crate::utmp) -> c_int;
+    pub fn endutent();
+    pub fn pututline(__line: *const crate::utmp) -> *mut crate::utmp;
+    pub fn getutline(__line: *const crate::utmp) -> *mut crate::utmp;
+    pub fn getutid(__id: *const crate::utmp) -> *mut crate::utmp;
+    pub fn utmpname(__file: *const c_char) -> c_int;
+}
+
+// utmpx.h
+s! {
+    pub struct utmpx {
+        pub ut_type: c_short,
+        pub __ut_pad1: c_short,
+        pub ut_pid: crate::pid_t,
+        pub ut_line: [c_char; 32],
+        pub ut_id: [c_char; 4],
+        pub ut_user: [c_char; 32],
+        pub ut_host: [c_char; 256],
+        pub ut_exit: anon_utmpx_line21,
+        pub ut_session: c_int,
+        pub __ut_pad2: c_int,
+        pub ut_tv: crate::timeval,
+        pub ut_addr_v6: [c_uint; 4],
+        pub __unused: [c_char; 20],
+    }
+    pub struct anon_utmpx_line21 {
+        pub __e_termination: c_short,
+        pub __e_exit: c_short,
+    }
+}
+extern "C" {
+    pub fn updwtmpx(__wtmp_file: *const c_char, __ut: *const crate::utmpx);
+    pub fn utmpxname(__file: *const c_char) -> c_int;
+    pub fn pututxline(__line: *const crate::utmpx) -> *mut crate::utmpx;
+    pub fn getutxent() -> *mut crate::utmpx;
+    pub fn getutxid(__id: *const crate::utmpx) -> *mut crate::utmpx;
+    pub fn setutxent();
+    pub fn endutxent();
+}
-- 
2.48.1

