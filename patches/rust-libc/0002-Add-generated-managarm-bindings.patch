From 2ac0ca58c126271a8577cfa725443cae888f63dd Mon Sep 17 00:00:00 2001
From: no92 <no92.mail@gmail.com>
Date: Fri, 29 Mar 2024 13:59:27 +0100
Subject: [PATCH 2/2] Add generated managarm bindings

---
 src/unix/linux_like/managarm/mod.rs | 4058 +++++++++++++++++++++++++++
 1 file changed, 4058 insertions(+)
 create mode 100644 src/unix/linux_like/managarm/mod.rs

diff --git a/src/unix/linux_like/managarm/mod.rs b/src/unix/linux_like/managarm/mod.rs
new file mode 100644
index 0000000..ecf7b8a
--- /dev/null
+++ b/src/unix/linux_like/managarm/mod.rs
@@ -0,0 +1,4058 @@
+// This file is autogenerated!
+// All changes made will be lost (eventually)!
+
+use sighandler_t;
+
+pub type c_char = i8;
+pub type c_long = i64;
+pub type c_ulong = u64;
+pub type rlim64_t = ::rlim_t;
+pub type dirent64 = ::dirent;
+pub type stat64 = ::stat;
+pub type statfs64 = ::statfs;
+pub type statvfs64 = ::statvfs;
+pub type idtype_t = ::c_uint;
+pub const RTLD_DEFAULT: *mut ::c_void = 0i64 as *mut ::c_void;
+
+pub type Elf32_Half = u16;
+pub type Elf32_Word = u32;
+pub type Elf32_Off = u32;
+pub type Elf32_Addr = u32;
+
+pub type Elf64_Half = u16;
+pub type Elf64_Word = u32;
+pub type Elf64_Off = u64;
+pub type Elf64_Addr = u64;
+pub type Elf64_Xword = u64;
+
+s! {
+    pub struct Elf32_Phdr {
+        pub p_type: Elf32_Word,
+        pub p_offset: Elf32_Off,
+        pub p_vaddr: Elf32_Addr,
+        pub p_paddr: Elf32_Addr,
+        pub p_filesz: Elf32_Word,
+        pub p_memsz: Elf32_Word,
+        pub p_flags: Elf32_Word,
+        pub p_align: Elf32_Word,
+    }
+
+    pub struct Elf64_Phdr {
+        pub p_type: Elf64_Word,
+        pub p_flags: Elf64_Word,
+        pub p_offset: Elf64_Off,
+        pub p_vaddr: Elf64_Addr,
+        pub p_paddr: Elf64_Addr,
+        pub p_filesz: Elf64_Xword,
+        pub p_memsz: Elf64_Xword,
+        pub p_align: Elf64_Xword,
+    }
+}
+
+s! {
+    pub struct dl_phdr_info {
+        #[cfg(target_pointer_width = "64")]
+        pub dlpi_addr: Elf64_Addr,
+        #[cfg(target_pointer_width = "32")]
+        pub dlpi_addr: Elf32_Addr,
+
+        pub dlpi_name: *const ::c_char,
+
+        #[cfg(target_pointer_width = "64")]
+        pub dlpi_phdr: *const Elf64_Phdr,
+        #[cfg(target_pointer_width = "32")]
+        pub dlpi_phdr: *const Elf32_Phdr,
+
+        #[cfg(target_pointer_width = "64")]
+        pub dlpi_phnum: Elf64_Half,
+        #[cfg(target_pointer_width = "32")]
+        pub dlpi_phnum: Elf32_Half,
+
+        pub dlpi_adds: ::c_ulonglong,
+        pub dlpi_subs: ::c_ulonglong,
+        pub dlpi_tls_modid: ::size_t,
+        pub dlpi_tls_data: *mut ::c_void,
+    }
+}
+
+f! {
+    pub fn CMSG_NXTHDR(mhdr: *const msghdr, cmsg: *const cmsghdr) -> *mut cmsghdr {
+        if ((*cmsg).cmsg_len as usize) < ::mem::size_of::<cmsghdr>() {
+            return 0 as *mut cmsghdr;
+        };
+        let next = (cmsg as usize + super::CMSG_ALIGN((*cmsg).cmsg_len as usize)) as *mut cmsghdr;
+        let max = (*mhdr).msg_control as usize + (*mhdr).msg_controllen as usize;
+        if (next.offset(1)) as usize > max ||
+            next as usize + super::CMSG_ALIGN((*next).cmsg_len as usize) > max {
+            0 as *mut cmsghdr
+        } else {
+            next as *mut cmsghdr
+        }
+    }
+}
+
+align_const! {
+    pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {
+        size: [0; 16],
+    };
+    pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {
+        size: [0; 12],
+    };
+    pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t {
+        size: [0; 12],
+    };
+}
+s_no_extra_traits! {
+    pub struct ifreq {
+        pub ifru_addr: ::sockaddr,
+        pub ifru_dstaddr: ::sockaddr,
+        pub ifru_broadaddr: ::sockaddr,
+        pub ifru_netmask: ::sockaddr,
+        pub ifru_hwaddr: ::sockaddr,
+        pub ifru_flags: ::c_short,
+        pub ifru_ivalue: ::c_int,
+        pub ifru_mtu: ::c_int,
+        pub ifru_map: ::ifmap,
+        pub ifru_slave: [::c_char; 16],
+        pub ifru_newname: [::c_char; 16],
+        pub ifru_data: *mut ::c_char,
+    }
+}
+
+impl ::fmt::Debug for ifreq {
+    fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
+        f.debug_struct("ifreq").finish()
+    }
+}
+
+// abi-bits/access.h
+
+// abi-bits/auxv.h
+pub const AT_SECURE: ::c_int = 23;
+pub const AT_RANDOM: ::c_int = 25;
+pub const AT_EXECFN: ::c_int = 31;
+pub const AT_SYSINFO_EHDR: ::c_int = 33;
+pub const AT_XPIPE: ::c_int = 0x1000;
+pub const AT_OPENFILES: ::c_int = 0x1001;
+pub const AT_FS_SERVER: ::c_int = 0x1102;
+pub const AT_MBUS_SERVER: ::c_int = 0x1103;
+
+// abi-bits/blkcnt_t.h
+pub type blkcnt_t = i64;
+
+// abi-bits/blksize_t.h
+pub type blksize_t = ::c_long;
+
+// abi-bits/clockid_t.h
+
+// abi-bits/dev_t.h
+pub type dev_t = u64;
+
+// abi-bits/epoll.h
+pub const EPOLL_CLOEXEC: ::c_int = 0o2000000;
+
+// abi-bits/errno.h
+pub const EPERM: ::c_int = 1;
+pub const ENOENT: ::c_int = 2;
+pub const ESRCH: ::c_int = 3;
+pub const EINTR: ::c_int = 4;
+pub const EIO: ::c_int = 5;
+pub const ENXIO: ::c_int = 6;
+pub const E2BIG: ::c_int = 7;
+pub const ENOEXEC: ::c_int = 8;
+pub const EBADF: ::c_int = 9;
+pub const ECHILD: ::c_int = 10;
+pub const EAGAIN: ::c_int = 11;
+pub const ENOMEM: ::c_int = 12;
+pub const EACCES: ::c_int = 13;
+pub const EFAULT: ::c_int = 14;
+pub const ENOTBLK: ::c_int = 15;
+pub const EBUSY: ::c_int = 16;
+pub const EEXIST: ::c_int = 17;
+pub const EXDEV: ::c_int = 18;
+pub const ENODEV: ::c_int = 19;
+pub const ENOTDIR: ::c_int = 20;
+pub const EISDIR: ::c_int = 21;
+pub const EINVAL: ::c_int = 22;
+pub const ENFILE: ::c_int = 23;
+pub const EMFILE: ::c_int = 24;
+pub const ENOTTY: ::c_int = 25;
+pub const ETXTBSY: ::c_int = 26;
+pub const EFBIG: ::c_int = 27;
+pub const ENOSPC: ::c_int = 28;
+pub const ESPIPE: ::c_int = 29;
+pub const EROFS: ::c_int = 30;
+pub const EMLINK: ::c_int = 31;
+pub const EPIPE: ::c_int = 32;
+pub const EDOM: ::c_int = 33;
+pub const ERANGE: ::c_int = 34;
+pub const EDEADLK: ::c_int = 35;
+pub const ENAMETOOLONG: ::c_int = 36;
+pub const ENOLCK: ::c_int = 37;
+pub const ENOSYS: ::c_int = 38;
+pub const ENOTEMPTY: ::c_int = 39;
+pub const ELOOP: ::c_int = 40;
+pub const EWOULDBLOCK: ::c_int = EAGAIN;
+pub const ENOMSG: ::c_int = 42;
+pub const EIDRM: ::c_int = 43;
+pub const ECHRNG: ::c_int = 44;
+pub const EL2NSYNC: ::c_int = 45;
+pub const EL3HLT: ::c_int = 46;
+pub const EL3RST: ::c_int = 47;
+pub const ELNRNG: ::c_int = 48;
+pub const EUNATCH: ::c_int = 49;
+pub const ENOCSI: ::c_int = 50;
+pub const EL2HLT: ::c_int = 51;
+pub const EBADE: ::c_int = 52;
+pub const EBADR: ::c_int = 53;
+pub const EXFULL: ::c_int = 54;
+pub const ENOANO: ::c_int = 55;
+pub const EBADRQC: ::c_int = 56;
+pub const EBADSLT: ::c_int = 57;
+pub const EDEADLOCK: ::c_int = EDEADLK;
+pub const EBFONT: ::c_int = 59;
+pub const ENOSTR: ::c_int = 60;
+pub const ENODATA: ::c_int = 61;
+pub const ETIME: ::c_int = 62;
+pub const ENOSR: ::c_int = 63;
+pub const ENONET: ::c_int = 64;
+pub const ENOPKG: ::c_int = 65;
+pub const EREMOTE: ::c_int = 66;
+pub const ENOLINK: ::c_int = 67;
+pub const EADV: ::c_int = 68;
+pub const ESRMNT: ::c_int = 69;
+pub const ECOMM: ::c_int = 70;
+pub const EPROTO: ::c_int = 71;
+pub const EMULTIHOP: ::c_int = 72;
+pub const EDOTDOT: ::c_int = 73;
+pub const EBADMSG: ::c_int = 74;
+pub const EOVERFLOW: ::c_int = 75;
+pub const ENOTUNIQ: ::c_int = 76;
+pub const EBADFD: ::c_int = 77;
+pub const EREMCHG: ::c_int = 78;
+pub const ELIBACC: ::c_int = 79;
+pub const ELIBBAD: ::c_int = 80;
+pub const ELIBSCN: ::c_int = 81;
+pub const ELIBMAX: ::c_int = 82;
+pub const ELIBEXEC: ::c_int = 83;
+pub const EILSEQ: ::c_int = 84;
+pub const ERESTART: ::c_int = 85;
+pub const ESTRPIPE: ::c_int = 86;
+pub const EUSERS: ::c_int = 87;
+pub const ENOTSOCK: ::c_int = 88;
+pub const EDESTADDRREQ: ::c_int = 89;
+pub const EMSGSIZE: ::c_int = 90;
+pub const EPROTOTYPE: ::c_int = 91;
+pub const ENOPROTOOPT: ::c_int = 92;
+pub const EPROTONOSUPPORT: ::c_int = 93;
+pub const ESOCKTNOSUPPORT: ::c_int = 94;
+pub const EOPNOTSUPP: ::c_int = 95;
+pub const ENOTSUP: ::c_int = EOPNOTSUPP;
+pub const EPFNOSUPPORT: ::c_int = 96;
+pub const EAFNOSUPPORT: ::c_int = 97;
+pub const EADDRINUSE: ::c_int = 98;
+pub const EADDRNOTAVAIL: ::c_int = 99;
+pub const ENETDOWN: ::c_int = 100;
+pub const ENETUNREACH: ::c_int = 101;
+pub const ENETRESET: ::c_int = 102;
+pub const ECONNABORTED: ::c_int = 103;
+pub const ECONNRESET: ::c_int = 104;
+pub const ENOBUFS: ::c_int = 105;
+pub const EISCONN: ::c_int = 106;
+pub const ENOTCONN: ::c_int = 107;
+pub const ESHUTDOWN: ::c_int = 108;
+pub const ETOOMANYREFS: ::c_int = 109;
+pub const ETIMEDOUT: ::c_int = 110;
+pub const ECONNREFUSED: ::c_int = 111;
+pub const EHOSTDOWN: ::c_int = 112;
+pub const EHOSTUNREACH: ::c_int = 113;
+pub const EALREADY: ::c_int = 114;
+pub const EINPROGRESS: ::c_int = 115;
+pub const ESTALE: ::c_int = 116;
+pub const EUCLEAN: ::c_int = 117;
+pub const ENOTNAM: ::c_int = 118;
+pub const ENAVAIL: ::c_int = 119;
+pub const EISNAM: ::c_int = 120;
+pub const EREMOTEIO: ::c_int = 121;
+pub const EDQUOT: ::c_int = 122;
+pub const ENOMEDIUM: ::c_int = 123;
+pub const EMEDIUMTYPE: ::c_int = 124;
+pub const ECANCELED: ::c_int = 125;
+pub const ENOKEY: ::c_int = 126;
+pub const EKEYEXPIRED: ::c_int = 127;
+pub const EKEYREVOKED: ::c_int = 128;
+pub const EKEYREJECTED: ::c_int = 129;
+pub const EOWNERDEAD: ::c_int = 130;
+pub const ENOTRECOVERABLE: ::c_int = 131;
+pub const ERFKILL: ::c_int = 132;
+pub const EHWPOISON: ::c_int = 133;
+pub const EIEIO: ::c_int = 4095;
+
+// abi-bits/fcntl.h
+pub const O_PATH: ::c_int = 0o10000000;
+pub const O_ACCMODE: ::c_int = 0o3 | O_PATH;
+pub const O_CREAT: ::c_int = 0o100;
+pub const O_EXCL: ::c_int = 0o200;
+pub const O_NOCTTY: ::c_int = 0o400;
+pub const O_TRUNC: ::c_int = 0o1000;
+pub const O_APPEND: ::c_int = 0o2000;
+pub const O_NONBLOCK: ::c_int = 0o4000;
+pub const O_DSYNC: ::c_int = 0o10000;
+pub const O_ASYNC: ::c_int = 0o20000;
+pub const O_DIRECT: ::c_int = 0o40000;
+pub const O_DIRECTORY: ::c_int = 0o200000;
+pub const O_NOFOLLOW: ::c_int = 0o400000;
+pub const O_CLOEXEC: ::c_int = 0o2000000;
+pub const O_SYNC: ::c_int = 0o4010000;
+pub const O_RSYNC: ::c_int = 0o4010000;
+pub const O_LARGEFILE: ::c_int = 0o100000;
+pub const O_NOATIME: ::c_int = 0o1000000;
+pub const O_TMPFILE: ::c_int = 0o20000000;
+pub const O_EXEC: ::c_int = O_PATH;
+pub const O_SEARCH: ::c_int = O_PATH;
+pub const F_SETOWN: ::c_int = 8;
+pub const F_GETOWN: ::c_int = 9;
+pub const F_SETSIG: ::c_int = 10;
+pub const F_GETSIG: ::c_int = 11;
+pub const F_GETLK: ::c_int = 5;
+pub const F_SETLK: ::c_int = 6;
+pub const F_SETLKW: ::c_int = 7;
+pub const F_SETOWN_EX: ::c_int = 15;
+pub const F_GETOWN_EX: ::c_int = 16;
+pub const F_GETOWNER_UIDS: ::c_int = 17;
+pub const F_RDLCK: ::c_int = 0;
+pub const F_WRLCK: ::c_int = 1;
+pub const F_UNLCK: ::c_int = 2;
+pub const AT_EACCESS: ::c_int = 0x200;
+pub const AT_STATX_FORCE_SYNC: ::c_int = 0x2000;
+pub const AT_STATX_DONT_SYNC: ::c_int = 0x4000;
+pub const AT_STATX_SYNC_TYPE: ::c_int = 0x6000;
+pub const POSIX_FADV_DONTNEED: ::c_int = 4;
+pub const POSIX_FADV_NOREUSE: ::c_int = 5;
+s! {
+    pub struct f_owner_ex {
+        pub r#type: ::c_int,
+        pub pid: ::pid_t,
+    }
+}
+
+// abi-bits/fsblkcnt_t.h
+pub type fsblkcnt_t = u64;
+
+// abi-bits/fsfilcnt_t.h
+pub type fsfilcnt_t = u64;
+
+// abi-bits/gid_t.h
+
+// abi-bits/in.h
+pub const SOCK_STREAM: ::c_int = 1;
+pub const SOCK_DGRAM: ::c_int = 2;
+pub const SOCK_SEQPACKET: ::c_int = 5;
+pub const SOCK_DCCP: ::c_int = 6;
+pub const SOCK_PACKET: ::c_int = 10;
+pub const SOCK_NONBLOCK: ::c_int = 0o4000;
+pub const PF_LOCAL: ::c_int = 1;
+pub const PF_FILE: ::c_int = PF_LOCAL;
+pub const PF_IB: ::c_int = 27;
+pub const PF_MPLS: ::c_int = 28;
+pub const PF_NFC: ::c_int = 39;
+pub const PF_VSOCK: ::c_int = 40;
+pub const PF_KCM: ::c_int = 41;
+pub const PF_QIPCRTR: ::c_int = 42;
+pub const PF_SMC: ::c_int = 43;
+pub const PF_XDP: ::c_int = 44;
+pub const PF_MAX: ::c_int = 45;
+pub const AF_LOCAL: ::c_int = PF_LOCAL;
+pub const AF_FILE: ::c_int = AF_LOCAL;
+pub const AF_IB: ::c_int = PF_IB;
+pub const AF_MPLS: ::c_int = PF_MPLS;
+pub const AF_NFC: ::c_int = PF_NFC;
+pub const AF_VSOCK: ::c_int = PF_VSOCK;
+pub const AF_KCM: ::c_int = PF_KCM;
+pub const AF_QIPCRTR: ::c_int = PF_QIPCRTR;
+pub const AF_SMC: ::c_int = PF_SMC;
+pub const AF_XDP: ::c_int = PF_XDP;
+pub const AF_MAX: ::c_int = PF_MAX;
+pub const SO_REUSEADDR: ::c_int = 2;
+pub const SO_TYPE: ::c_int = 3;
+pub const SO_ERROR: ::c_int = 4;
+pub const SO_DONTROUTE: ::c_int = 5;
+pub const SO_BROADCAST: ::c_int = 6;
+pub const SO_SNDBUF: ::c_int = 7;
+pub const SO_RCVBUF: ::c_int = 8;
+pub const SO_KEEPALIVE: ::c_int = 9;
+pub const SO_OOBINLINE: ::c_int = 10;
+pub const SO_NO_CHECK: ::c_int = 11;
+pub const SO_PRIORITY: ::c_int = 12;
+pub const SO_LINGER: ::c_int = 13;
+pub const SO_BSDCOMPAT: ::c_int = 14;
+pub const SO_REUSEPORT: ::c_int = 15;
+pub const SO_PASSCRED: ::c_int = 16;
+pub const SO_PEERCRED: ::c_int = 17;
+pub const SO_RCVLOWAT: ::c_int = 18;
+pub const SO_SNDLOWAT: ::c_int = 19;
+pub const SO_ACCEPTCONN: ::c_int = 30;
+pub const SO_PEERSEC: ::c_int = 31;
+pub const SO_SNDBUFFORCE: ::c_int = 32;
+pub const SO_RCVBUFFORCE: ::c_int = 33;
+pub const SO_PROTOCOL: ::c_int = 38;
+pub const SO_DOMAIN: ::c_int = 39;
+pub const SO_RCVTIMEO: ::c_int = 20;
+pub const SO_SNDTIMEO: ::c_int = 21;
+pub const SO_TIMESTAMP: ::c_int = 29;
+pub const SO_TIMESTAMPNS: ::c_int = 35;
+pub const SO_TIMESTAMPING: ::c_int = 37;
+pub const SO_SECURITY_AUTHENTICATION: ::c_int = 22;
+pub const SO_SECURITY_ENCRYPTION_TRANSPORT: ::c_int = 23;
+pub const SO_SECURITY_ENCRYPTION_NETWORK: ::c_int = 24;
+pub const SO_BINDTODEVICE: ::c_int = 25;
+pub const SO_ATTACH_FILTER: ::c_int = 26;
+pub const SO_DETACH_FILTER: ::c_int = 27;
+pub const SO_GET_FILTER: ::c_int = SO_ATTACH_FILTER;
+pub const SO_PEERNAME: ::c_int = 28;
+pub const SO_PASSSEC: ::c_int = 34;
+pub const SCM_TIMESTAMPNS: ::c_int = SO_TIMESTAMPNS;
+pub const SO_MARK: ::c_int = 36;
+pub const SCM_TIMESTAMPING: ::c_int = SO_TIMESTAMPING;
+pub const SO_RXQ_OVFL: ::c_int = 40;
+pub const SO_WIFI_STATUS: ::c_int = 41;
+pub const SCM_WIFI_STATUS: ::c_int = SO_WIFI_STATUS;
+pub const SO_PEEK_OFF: ::c_int = 42;
+pub const SO_NOFCS: ::c_int = 43;
+pub const SO_LOCK_FILTER: ::c_int = 44;
+pub const SO_SELECT_ERR_QUEUE: ::c_int = 45;
+pub const SO_BUSY_POLL: ::c_int = 46;
+pub const SO_MAX_PACING_RATE: ::c_int = 47;
+pub const SO_BPF_EXTENSIONS: ::c_int = 48;
+pub const SO_INCOMING_CPU: ::c_int = 49;
+pub const SO_ATTACH_BPF: ::c_int = 50;
+pub const SO_DETACH_BPF: ::c_int = SO_DETACH_FILTER;
+pub const SO_ATTACH_REUSEPORT_CBPF: ::c_int = 51;
+pub const SO_ATTACH_REUSEPORT_EBPF: ::c_int = 52;
+pub const SO_CNX_ADVICE: ::c_int = 53;
+pub const SCM_TIMESTAMPING_OPT_STATS: ::c_int = 54;
+pub const SO_MEMINFO: ::c_int = 55;
+pub const SO_INCOMING_NAPI_ID: ::c_int = 56;
+pub const SO_COOKIE: ::c_int = 57;
+pub const SCM_TIMESTAMPING_PKTINFO: ::c_int = 58;
+pub const SO_PEERGROUPS: ::c_int = 59;
+pub const SO_ZEROCOPY: ::c_int = 60;
+pub const SO_TXTIME: ::c_int = 61;
+pub const SCM_TXTIME: ::c_int = SO_TXTIME;
+pub const SO_BINDTOIFINDEX: ::c_int = 62;
+pub const SO_DETACH_REUSEPORT_BPF: ::c_int = 68;
+pub const SOL_SOCKET: ::c_int = 1;
+pub const SOL_RXRPC: ::c_int = 272;
+pub const SOL_PPPOL2TP: ::c_int = 273;
+pub const SOL_PNPIPE: ::c_int = 275;
+pub const SOL_RDS: ::c_int = 276;
+pub const SOL_IUCV: ::c_int = 277;
+pub const SOL_CAIF: ::c_int = 278;
+pub const SOL_NFC: ::c_int = 280;
+pub const SOL_KCM: ::c_int = 281;
+pub const SOL_TLS: ::c_int = 282;
+pub const SOL_XDP: ::c_int = 283;
+pub const SOMAXCONN: ::c_int = 128;
+pub const MSG_PROXY: ::c_int = 0x0010;
+pub const MSG_BATCH: ::c_int = 0x40000;
+pub const MSG_ZEROCOPY: ::c_int = 0x4000000;
+pub const INET_ADDRSTRLEN: ::c_int = 16;
+pub const INET6_ADDRSTRLEN: ::c_int = 46;
+pub const IPPORT_RESERVED: ::c_int = 1024;
+pub const IPPROTO_MAX: ::c_int = 256;
+pub const IPV6_JOIN_GROUP: ::c_int = 20;
+pub const IPV6_LEAVE_GROUP: ::c_int = 21;
+pub type socklen_t = ::c_uint;
+s! {
+    pub struct iovec {
+        pub iov_base: *mut ::c_void,
+        pub iov_len: usize,
+    }
+}
+s! {
+    pub struct msghdr {
+        pub msg_name: *mut ::c_void,
+        pub msg_namelen: ::socklen_t,
+        pub msg_iov: *mut ::iovec,
+        pub msg_iovlen: ::size_t,
+        pub msg_control: *mut ::c_void,
+        pub msg_controllen: ::size_t,
+        pub msg_flags: ::c_int,
+    }
+    pub struct cmsghdr {
+        pub cmsg_len: ::size_t,
+        pub cmsg_level: ::c_int,
+        pub cmsg_type: ::c_int,
+    }
+    pub struct ipv6_mreq {
+        pub ipv6mr_multiaddr: ::in6_addr,
+        pub ipv6mr_interface: ::c_uint,
+    }
+    pub struct in6_pktinfo {
+        pub ipi6_addr: ::in6_addr,
+        pub ipi6_ifindex: u32,
+    }
+    pub struct group_req {
+        pub gr_interface: u32,
+        pub gr_group: ::sockaddr_storage,
+    }
+    pub struct group_source_req {
+        pub gsr_interface: u32,
+        pub gsr_group: ::sockaddr_storage,
+        pub gsr_source: ::sockaddr_storage,
+    }
+}
+
+// abi-bits/ino_t.h
+pub type ino_t = u64;
+
+// abi-bits/inotify.h
+pub const IN_CLOEXEC: ::c_int = O_CLOEXEC;
+pub const IN_NONBLOCK: ::c_int = O_NONBLOCK;
+
+// abi-bits/ioctls.h
+pub const SIOCPROTOPRIVATE: ::c_int = 0x89E0;
+pub const SIOCGIFNAME: ::c_int = 0x8910;
+pub const SIOCGIFCONF: ::c_int = 0x8912;
+pub const SIOCGIFFLAGS: ::c_int = 0x8913;
+pub const SIOCSIFFLAGS: ::c_int = 0x8914;
+pub const SIOCGIFINDEX: ::c_int = 0x8933;
+pub const SIOCATMARK: ::c_int = 0x8905;
+pub const SIOCGIFHWADDR: ::c_int = 0x8927;
+pub const SIOCGIFBRDADDR: ::c_int = 0x8919;
+pub const SIOCGIFNETMASK: ::c_int = 0x891B;
+
+// abi-bits/mode_t.h
+pub type mode_t = ::c_uint;
+
+// abi-bits/mqueue.h
+s! {
+    pub struct mq_attr {
+        pub mq_flags: ::c_long,
+        pub mq_maxmsg: ::c_long,
+        pub mq_msgsize: ::c_long,
+        pub mq_curmsgs: ::c_long,
+        pub __pad: [::c_long; 4],
+    }
+}
+
+// abi-bits/msg.h
+pub const IPC_CREAT: ::c_int = 0o1000;
+pub const IPC_EXCL: ::c_int = 0o2000;
+pub const IPC_NOWAIT: ::c_int = 0o4000;
+pub const IPC_RMID: ::c_int = 0;
+pub const IPC_SET: ::c_int = 1;
+pub const IPC_STAT: ::c_int = 2;
+pub const IPC_INFO: ::c_int = 3;
+pub const IPC_64: ::c_int = 0;
+s! {
+    pub struct ipc64_perm {
+        pub __ipc_perm_key: ::key_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+        pub cuid: ::uid_t,
+        pub cgid: ::gid_t,
+        pub mode: ::mode_t,
+        pub __ipc_perm_seq: ::c_short,
+        pub __pad: ::c_short,
+        pub __unused: [::c_ulong; 2],
+    }
+}
+extern "C" {
+    pub fn ftok(arg0: *const ::c_char, arg1: ::c_int) -> ::key_t;
+}
+pub type time_t = ::c_long;
+pub type msglen_t = ::c_ulong;
+pub type msgqnum_t = ::c_ulong;
+s! {
+    pub struct msqid64_ds {
+        pub msg_perm: ::ipc64_perm,
+        pub msg_stime: ::time_t,
+        pub msg_rtime: ::time_t,
+        pub msg_ctime: ::time_t,
+        pub msg_cbytes: ::c_ulong,
+        pub msg_qnum: ::msgqnum_t,
+        pub msg_qbytes: ::msglen_t,
+        pub msg_lspid: ::pid_t,
+        pub msg_lrpid: ::pid_t,
+        pub __unused: [::c_ulong; 2],
+    }
+}
+
+// abi-bits/nlink_t.h
+pub type nlink_t = ::c_ulong;
+
+// abi-bits/packet.h
+pub const PACKET_HOST: ::c_int = 0;
+
+// abi-bits/pid_t.h
+
+// abi-bits/poll.h
+pub const POLLWRNORM: ::c_int = 0x0100;
+pub const POLLWRBAND: ::c_int = 0x0200;
+
+// abi-bits/ptrace.h
+pub const PTRACE_PEEKTEXT: ::c_int = 1;
+pub const PTRACE_PEEKDATA: ::c_int = 2;
+pub const PTRACE_PEEKUSER: ::c_int = 3;
+pub const PTRACE_POKETEXT: ::c_int = 4;
+pub const PTRACE_POKEDATA: ::c_int = 5;
+pub const PTRACE_POKEUSER: ::c_int = 6;
+pub const PTRACE_CONT: ::c_int = 7;
+pub const PTRACE_KILL: ::c_int = 8;
+pub const PTRACE_SINGLESTEP: ::c_int = 9;
+pub const PTRACE_GETREGS: ::c_int = 12;
+pub const PTRACE_SETREGS: ::c_int = 13;
+pub const PTRACE_GETFPREGS: ::c_int = 14;
+pub const PTRACE_SETFPREGS: ::c_int = 15;
+pub const PTRACE_ATTACH: ::c_int = 16;
+pub const PTRACE_DETACH: ::c_int = 17;
+pub const PTRACE_GETFPXREGS: ::c_int = 18;
+pub const PTRACE_SETFPXREGS: ::c_int = 19;
+pub const PTRACE_SYSCALL: ::c_int = 24;
+pub const PTRACE_SETOPTIONS: ::c_int = 0x4200;
+pub const PTRACE_GETEVENTMSG: ::c_int = 0x4201;
+pub const PTRACE_GETSIGINFO: ::c_int = 0x4202;
+pub const PTRACE_SETSIGINFO: ::c_int = 0x4203;
+pub const PTRACE_GETREGSET: ::c_int = 0x4204;
+pub const PTRACE_SETREGSET: ::c_int = 0x4205;
+pub const PTRACE_SEIZE: ::c_int = 0x4206;
+pub const PTRACE_INTERRUPT: ::c_int = 0x4207;
+pub const PTRACE_LISTEN: ::c_int = 0x4208;
+pub const PTRACE_PEEKSIGINFO: ::c_int = 0x4209;
+pub const PTRACE_GETSIGMASK: ::c_int = 0x420A;
+pub const PTRACE_SETSIGMASK: ::c_int = 0x420B;
+pub const PTRACE_SECCOMP_GET_FILTER: ::c_int = 0x420C;
+pub const PTRACE_EVENT_STOP: ::c_int = 128;
+pub const PTRACE_PEEKSIGINFO_SHARED: ::c_int = 1;
+
+// abi-bits/reboot.h
+pub const RB_AUTOBOOT: ::c_int = 0x01234567;
+pub const RB_HALT_SYSTEM: ::c_int = 0xcdef0123;
+pub const RB_ENABLE_CAD: ::c_int = 0x89abcdef;
+pub const RB_DISABLE_CAD: ::c_int = 0;
+pub const RB_POWER_OFF: ::c_int = 0x4321fedc;
+pub const RB_SW_SUSPEND: ::c_int = 0xd000fce2;
+pub const RB_KEXEC: ::c_int = 0x45584543;
+
+// abi-bits/resource.h
+pub const RUSAGE_CHILDREN: ::c_int = 1;
+pub const RLIMIT_CPU: ::c_int = 0;
+pub const RLIMIT_FSIZE: ::c_int = 1;
+pub const RLIMIT_DATA: ::c_int = 2;
+pub const RLIMIT_STACK: ::c_int = 3;
+pub const RLIMIT_CORE: ::c_int = 4;
+pub const RLIMIT_RSS: ::c_int = 5;
+pub const RLIMIT_NPROC: ::c_int = 6;
+pub const RLIMIT_NOFILE: ::c_int = 7;
+pub const RLIMIT_MEMLOCK: ::c_int = 8;
+pub const RLIMIT_AS: ::c_int = 9;
+pub const RLIMIT_LOCKS: ::c_int = 10;
+pub const RLIMIT_SIGPENDING: ::c_int = 11;
+pub const RLIMIT_MSGQUEUE: ::c_int = 12;
+pub const RLIMIT_NICE: ::c_int = 13;
+pub const RLIMIT_RTPRIO: ::c_int = 14;
+pub const RLIMIT_NLIMITS: ::c_int = 16;
+pub type suseconds_t = ::c_long;
+s! {
+    pub struct timeval {
+        pub tv_sec: ::time_t,
+        pub tv_usec: ::suseconds_t,
+    }
+    pub struct rusage {
+        pub ru_utime: ::timeval,
+        pub ru_stime: ::timeval,
+        pub ru_maxrss: ::c_long,
+        pub ru_ixrss: ::c_long,
+        pub ru_idrss: ::c_long,
+        pub ru_isrss: ::c_long,
+        pub ru_minflt: ::c_long,
+        pub ru_majflt: ::c_long,
+        pub ru_nswap: ::c_long,
+        pub ru_inblock: ::c_long,
+        pub ru_oublock: ::c_long,
+        pub ru_msgsnd: ::c_long,
+        pub ru_msgrcv: ::c_long,
+        pub ru_nsignals: ::c_long,
+        pub ru_nvcsw: ::c_long,
+        pub ru_nivcsw: ::c_long,
+    }
+}
+
+// abi-bits/seek-whence.h
+pub const SEEK_DATA: ::c_int = 3;
+pub const SEEK_HOLE: ::c_int = 4;
+
+// abi-bits/shm.h
+pub const _POSIX_VERSION: ::c_long = 200809;
+pub const _XOPEN_VERSION: ::c_int = 700;
+pub const _POSIX_JOB_CONTROL: ::c_int = 1;
+pub const _POSIX_SAVED_IDS: ::c_int = 1;
+pub const _POSIX_SHELL: ::c_int = 1;
+pub const _POSIX_MONOTONIC_CLOCK: ::c_int = 0;
+pub const _CS_PATH: ::c_int = 0;
+pub const _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS: ::c_int = 1;
+pub const _CS_GNU_LIBC_VERSION: ::c_int = 2;
+pub const _CS_GNU_LIBPTHREAD_VERSION: ::c_int = 3;
+pub const _CS_POSIX_V5_WIDTH_RESTRICTED_ENVS: ::c_int = 4;
+pub const _CS_POSIX_V7_WIDTH_RESTRICTED_ENVS: ::c_int = 5;
+pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: ::c_int = 1116;
+pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: ::c_int = 1117;
+pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: ::c_int = 1118;
+pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: ::c_int = 1119;
+pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: ::c_int = 1120;
+pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: ::c_int = 1121;
+pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: ::c_int = 1122;
+pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: ::c_int = 1123;
+pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: ::c_int = 1124;
+pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: ::c_int = 1125;
+pub const _CS_POSIX_V6_LP64_OFF64_LIBS: ::c_int = 1126;
+pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: ::c_int = 1127;
+pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: ::c_int = 1128;
+pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: ::c_int = 1129;
+pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: ::c_int = 1130;
+pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: ::c_int = 1131;
+pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: ::c_int = 1132;
+pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: ::c_int = 1133;
+pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: ::c_int = 1134;
+pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: ::c_int = 1135;
+pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: ::c_int = 1136;
+pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: ::c_int = 1137;
+pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: ::c_int = 1138;
+pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: ::c_int = 1139;
+pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: ::c_int = 1140;
+pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: ::c_int = 1141;
+pub const _CS_POSIX_V7_LP64_OFF64_LIBS: ::c_int = 1142;
+pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: ::c_int = 1143;
+pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: ::c_int = 1144;
+pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: ::c_int = 1145;
+pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: ::c_int = 1146;
+pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: ::c_int = 1147;
+pub const _CS_V6_ENV: ::c_int = 1148;
+pub const _CS_V7_ENV: ::c_int = 1149;
+pub const F_LOCK: ::c_int = 1;
+pub const F_TEST: ::c_int = 2;
+pub const F_TLOCK: ::c_int = 3;
+pub const F_ULOCK: ::c_int = 4;
+pub const _PC_LINK_MAX: ::c_int = 0;
+pub const _PC_MAX_CANON: ::c_int = 1;
+pub const _PC_MAX_INPUT: ::c_int = 2;
+pub const _PC_NAME_MAX: ::c_int = 3;
+pub const _PC_PATH_MAX: ::c_int = 4;
+pub const _PC_PIPE_BUF: ::c_int = 5;
+pub const _PC_CHOWN_RESTRICTED: ::c_int = 6;
+pub const _PC_NO_TRUNC: ::c_int = 7;
+pub const _PC_VDISABLE: ::c_int = 8;
+pub const _PC_FILESIZEBITS: ::c_int = 9;
+pub const _PC_SYMLINK_MAX: ::c_int = 10;
+pub const _SC_ARG_MAX: ::c_int = 0;
+pub const _SC_CHILD_MAX: ::c_int = 1;
+pub const _SC_CLK_TCK: ::c_int = 2;
+pub const _SC_NGROUPS_MAX: ::c_int = 3;
+pub const _SC_OPEN_MAX: ::c_int = 4;
+pub const _SC_STREAM_MAX: ::c_int = 5;
+pub const _SC_TZNAME_MAX: ::c_int = 6;
+pub const _SC_JOB_CONTROL: ::c_int = 7;
+pub const _SC_SAVED_IDS: ::c_int = 8;
+pub const _SC_REALTIME_SIGNALS: ::c_int = 9;
+pub const _SC_PRIORITY_SCHEDULING: ::c_int = 10;
+pub const _SC_TIMERS: ::c_int = 11;
+pub const _SC_ASYNCHRONOUS_IO: ::c_int = 12;
+pub const _SC_PRIORITIZED_IO: ::c_int = 13;
+pub const _SC_SYNCHRONIZED_IO: ::c_int = 14;
+pub const _SC_FSYNC: ::c_int = 15;
+pub const _SC_MAPPED_FILES: ::c_int = 16;
+pub const _SC_MEMLOCK: ::c_int = 17;
+pub const _SC_MEMLOCK_RANGE: ::c_int = 18;
+pub const _SC_MEMORY_PROTECTION: ::c_int = 19;
+pub const _SC_MESSAGE_PASSING: ::c_int = 20;
+pub const _SC_SEMAPHORES: ::c_int = 21;
+pub const _SC_SHARED_MEMORY_OBJECTS: ::c_int = 22;
+pub const _SC_AIO_LISTIO_MAX: ::c_int = 23;
+pub const _SC_AIO_MAX: ::c_int = 24;
+pub const _SC_AIO_PRIO_DELTA_MAX: ::c_int = 25;
+pub const _SC_DELAYTIMER_MAX: ::c_int = 26;
+pub const _SC_MQ_OPEN_MAX: ::c_int = 27;
+pub const _SC_MQ_PRIO_MAX: ::c_int = 28;
+pub const _SC_VERSION: ::c_int = 29;
+pub const _SC_PAGE_SIZE: ::c_int = 30;
+pub const _SC_PAGESIZE: ::c_int = _SC_PAGE_SIZE;
+pub const _SC_RTSIG_MAX: ::c_int = 31;
+pub const _SC_SEM_NSEMS_MAX: ::c_int = 32;
+pub const _SC_SEM_VALUE_MAX: ::c_int = 33;
+pub const _SC_SIGQUEUE_MAX: ::c_int = 34;
+pub const _SC_TIMER_MAX: ::c_int = 35;
+pub const _SC_BC_BASE_MAX: ::c_int = 36;
+pub const _SC_BC_DIM_MAX: ::c_int = 37;
+pub const _SC_BC_SCALE_MAX: ::c_int = 38;
+pub const _SC_BC_STRING_MAX: ::c_int = 39;
+pub const _SC_COLL_WEIGHTS_MAX: ::c_int = 40;
+pub const _SC_EXPR_NEST_MAX: ::c_int = 42;
+pub const _SC_LINE_MAX: ::c_int = 43;
+pub const _SC_RE_DUP_MAX: ::c_int = 44;
+pub const _SC_2_VERSION: ::c_int = 46;
+pub const _SC_2_C_BIND: ::c_int = 47;
+pub const _SC_2_C_DEV: ::c_int = 48;
+pub const _SC_2_FORT_DEV: ::c_int = 49;
+pub const _SC_2_FORT_RUN: ::c_int = 50;
+pub const _SC_2_SW_DEV: ::c_int = 51;
+pub const _SC_2_LOCALEDEF: ::c_int = 52;
+pub const _SC_IOV_MAX: ::c_int = 60;
+pub const _SC_UIO_MAXIOV: ::c_int = _SC_IOV_MAX;
+pub const _SC_THREADS: ::c_int = 67;
+pub const _SC_THREAD_SAFE_FUNCTIONS: ::c_int = 68;
+pub const _SC_GETGR_R_SIZE_MAX: ::c_int = 69;
+pub const _SC_GETPW_R_SIZE_MAX: ::c_int = 70;
+pub const _SC_LOGIN_NAME_MAX: ::c_int = 71;
+pub const _SC_TTY_NAME_MAX: ::c_int = 72;
+pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: ::c_int = 73;
+pub const _SC_THREAD_KEYS_MAX: ::c_int = 74;
+pub const _SC_THREAD_STACK_MIN: ::c_int = 75;
+pub const _SC_THREAD_THREADS_MAX: ::c_int = 76;
+pub const _SC_THREAD_ATTR_STACKADDR: ::c_int = 77;
+pub const _SC_THREAD_ATTR_STACKSIZE: ::c_int = 78;
+pub const _SC_THREAD_PRIORITY_SCHEDULING: ::c_int = 79;
+pub const _SC_THREAD_PRIO_INHERIT: ::c_int = 80;
+pub const _SC_THREAD_PRIO_PROTECT: ::c_int = 81;
+pub const _SC_THREAD_PROCESS_SHARED: ::c_int = 82;
+pub const _SC_NPROCESSORS_CONF: ::c_int = 83;
+pub const _SC_NPROCESSORS_ONLN: ::c_int = 84;
+pub const _SC_PHYS_PAGES: ::c_int = 85;
+pub const _SC_AVPHYS_PAGES: ::c_int = 86;
+pub const _SC_ATEXIT_MAX: ::c_int = 87;
+pub const _SC_PASS_MAX: ::c_int = 88;
+pub const _SC_XOPEN_VERSION: ::c_int = 89;
+pub const _SC_XOPEN_XCU_VERSION: ::c_int = 90;
+pub const _SC_XOPEN_UNIX: ::c_int = 91;
+pub const _SC_XOPEN_CRYPT: ::c_int = 92;
+pub const _SC_XOPEN_ENH_I18N: ::c_int = 93;
+pub const _SC_XOPEN_SHM: ::c_int = 94;
+pub const _SC_2_CHAR_TERM: ::c_int = 95;
+pub const _SC_2_UPE: ::c_int = 97;
+pub const _SC_XOPEN_XPG2: ::c_int = 98;
+pub const _SC_XOPEN_XPG3: ::c_int = 99;
+pub const _SC_XOPEN_XPG4: ::c_int = 100;
+pub const _SC_NZERO: ::c_int = 109;
+pub const _SC_XBS5_ILP32_OFF32: ::c_int = 125;
+pub const _SC_XBS5_ILP32_OFFBIG: ::c_int = 126;
+pub const _SC_XBS5_LP64_OFF64: ::c_int = 127;
+pub const _SC_XBS5_LPBIG_OFFBIG: ::c_int = 128;
+pub const _SC_XOPEN_LEGACY: ::c_int = 129;
+pub const _SC_XOPEN_REALTIME: ::c_int = 130;
+pub const _SC_XOPEN_REALTIME_THREADS: ::c_int = 131;
+pub const _SC_ADVISORY_INFO: ::c_int = 132;
+pub const _SC_BARRIERS: ::c_int = 133;
+pub const _SC_CLOCK_SELECTION: ::c_int = 137;
+pub const _SC_CPUTIME: ::c_int = 138;
+pub const _SC_THREAD_CPUTIME: ::c_int = 139;
+pub const _SC_MONOTONIC_CLOCK: ::c_int = 149;
+pub const _SC_READER_WRITER_LOCKS: ::c_int = 153;
+pub const _SC_SPIN_LOCKS: ::c_int = 154;
+pub const _SC_REGEXP: ::c_int = 155;
+pub const _SC_SHELL: ::c_int = 157;
+pub const _SC_SPAWN: ::c_int = 159;
+pub const _SC_SPORADIC_SERVER: ::c_int = 160;
+pub const _SC_THREAD_SPORADIC_SERVER: ::c_int = 161;
+pub const _SC_TIMEOUTS: ::c_int = 164;
+pub const _SC_TYPED_MEMORY_OBJECTS: ::c_int = 165;
+pub const _SC_2_PBS: ::c_int = 168;
+pub const _SC_2_PBS_ACCOUNTING: ::c_int = 169;
+pub const _SC_2_PBS_LOCATE: ::c_int = 170;
+pub const _SC_2_PBS_MESSAGE: ::c_int = 171;
+pub const _SC_2_PBS_TRACK: ::c_int = 172;
+pub const _SC_SYMLOOP_MAX: ::c_int = 173;
+pub const _SC_STREAMS: ::c_int = 174;
+pub const _SC_2_PBS_CHECKPOINT: ::c_int = 175;
+pub const _SC_V6_ILP32_OFF32: ::c_int = 176;
+pub const _SC_V6_ILP32_OFFBIG: ::c_int = 177;
+pub const _SC_V6_LP64_OFF64: ::c_int = 178;
+pub const _SC_V6_LPBIG_OFFBIG: ::c_int = 179;
+pub const _SC_HOST_NAME_MAX: ::c_int = 180;
+pub const _SC_TRACE: ::c_int = 181;
+pub const _SC_TRACE_EVENT_FILTER: ::c_int = 182;
+pub const _SC_TRACE_INHERIT: ::c_int = 183;
+pub const _SC_TRACE_LOG: ::c_int = 184;
+pub const L_ctermid: ::c_int = 20;
+pub type off_t = ::c_long;
+pub type off64_t = ::c_long;
+extern "C" {
+    pub fn confstr(arg0: ::c_int, arg1: *mut ::c_char, arg2: ::size_t) -> ::ssize_t;
+    pub fn ctermid(s: *mut ::c_char) -> *mut ::c_char;
+    pub fn endusershell();
+    pub fn faccessat(arg0: ::c_int, arg1: *const ::c_char, arg2: ::c_int, arg3: ::c_int)
+        -> ::c_int;
+    pub fn ftruncate64(arg0: ::c_int, arg1: ::off64_t) -> ::c_int;
+    pub fn gethostid() -> ::c_long;
+    pub fn sethostname(buffer: *const ::c_char, max_length: ::size_t) -> ::c_int;
+    pub fn getlogin_r(arg0: *mut ::c_char, arg1: ::size_t) -> ::c_int;
+    pub fn getpass(arg0: *const ::c_char) -> *mut ::c_char;
+    pub fn getusershell() -> *mut ::c_char;
+    pub fn setpgrp() -> ::pid_t;
+    pub fn setusershell();
+    pub fn swab(arg0: *const ::c_void, arg1: *mut ::c_void, arg2: ::ssize_t);
+    pub fn sync();
+    pub fn truncate64(arg0: *const ::c_char, arg1: ::off64_t) -> ::c_int;
+}
+pub type useconds_t = u64;
+extern "C" {
+    pub fn getpagesize() -> ::c_int;
+    pub fn get_current_dir_name() -> *mut ::c_char;
+    pub fn daemon(arg0: ::c_int, arg1: ::c_int) -> ::c_int;
+    pub fn gettid() -> ::pid_t;
+    pub fn getentropy(arg0: *mut ::c_void, arg1: ::size_t) -> ::c_int;
+    pub fn getdomainname(name: *mut ::c_char, len: ::size_t) -> ::c_int;
+    pub fn setdomainname(name: *const ::c_char, len: ::size_t) -> ::c_int;
+    pub fn dup3(fd: ::c_int, newfd: ::c_int, flags: ::c_int) -> ::c_int;
+    pub fn vhangup() -> ::c_int;
+    pub fn getdtablesize() -> ::c_int;
+    pub fn syncfs(fd: ::c_int) -> ::c_int;
+}
+s! {
+    pub struct shm_info {
+        pub used_ids: ::c_int,
+        pub shm_tot: ::c_ulong,
+        pub shm_rss: ::c_ulong,
+        pub shm_swp: ::c_ulong,
+        pub swap_attempts: ::c_ulong,
+        pub swap_successes: ::c_ulong,
+    }
+}
+
+// abi-bits/signal.h
+pub const TIME_UTC: ::c_int = 1;
+pub const POLL_IN: ::c_int = 1;
+pub const POLL_OUT: ::c_int = 2;
+pub const POLL_MSG: ::c_int = 3;
+pub const POLL_ERR: ::c_int = 4;
+pub const POLL_PRI: ::c_int = 5;
+pub const POLL_HUP: ::c_int = 6;
+pub const SA_NOCLDSTOP: ::c_ulong = 1;
+pub const SA_NOCLDWAIT: ::c_ulong = 2;
+pub const SA_SIGINFO: ::c_ulong = 4;
+pub const SA_ONSTACK: ::c_ulong = 0x08000000;
+pub const SA_RESTART: ::c_ulong = 0x10000000;
+pub const SA_NODEFER: ::c_ulong = 0x40000000;
+pub const SA_RESETHAND: ::c_ulong = 0x80000000;
+pub const SA_RESTORER: ::c_int = 0x04000000;
+pub const SIGPROF: ::c_int = 27;
+pub const SIGIO: ::c_int = 29;
+pub const SIGPWR: ::c_int = 30;
+pub const SIG_BLOCK: ::c_int = 0;
+pub const SIG_UNBLOCK: ::c_int = 1;
+pub const SIG_SETMASK: ::c_int = 2;
+pub const SIGBUS: ::c_int = 7;
+pub const SIGUSR1: ::c_int = 10;
+pub const SIGUSR2: ::c_int = 12;
+pub const SIGSTKFLT: ::c_int = 16;
+pub const SIGCHLD: ::c_int = 17;
+pub const SIGCONT: ::c_int = 18;
+pub const SIGSTOP: ::c_int = 19;
+pub const SIGTSTP: ::c_int = 20;
+pub const SIGTTIN: ::c_int = 21;
+pub const SIGTTOU: ::c_int = 22;
+pub const SIGURG: ::c_int = 23;
+pub const SIGXCPU: ::c_int = 24;
+pub const SIGXFSZ: ::c_int = 25;
+pub const SIGVTALRM: ::c_int = 26;
+pub const SIGWINCH: ::c_int = 28;
+pub const SIGPOLL: ::c_int = 29;
+pub const SIGSYS: ::c_int = 31;
+pub const SIGUNUSED: ::c_int = SIGSYS;
+pub const SIGCANCEL: ::c_int = 32;
+pub const MINSIGSTKSZ: ::c_int = 2048;
+pub const SIGSTKSZ: ::c_int = 8192;
+pub const SIGEV_THREAD_ID: ::c_int = 4;
+pub const SEGV_MAPERR: ::c_int = 1;
+pub const SEGV_ACCERR: ::c_int = 2;
+pub const ILL_ILLOPC: ::c_int = 1;
+pub const ILL_ILLOPN: ::c_int = 2;
+pub const ILL_ILLADR: ::c_int = 3;
+pub const ILL_ILLTRP: ::c_int = 4;
+pub const ILL_PRVOPC: ::c_int = 5;
+pub const ILL_PRVREG: ::c_int = 6;
+pub const ILL_COPROC: ::c_int = 7;
+pub const ILL_BADSTK: ::c_int = 8;
+pub const ILL_BADIADDR: ::c_int = 9;
+pub const NSIG: ::c_int = 65;
+pub const SI_ASYNCNL: ::c_int = 60;
+pub const SI_TKILL: ::c_int = 6;
+pub const SI_SIGIO: ::c_int = 5;
+pub const SI_ASYNCIO: ::c_int = 4;
+pub const SI_MESGQ: ::c_int = 3;
+pub const SI_TIMER: ::c_int = 2;
+pub const SI_QUEUE: ::c_int = 1;
+pub const SI_USER: ::c_int = 0;
+pub const SI_KERNEL: ::c_int = 128;
+pub const REG_R8: ::c_int = 0;
+pub const REG_R9: ::c_int = 1;
+pub const REG_R10: ::c_int = 2;
+pub const REG_R11: ::c_int = 3;
+pub const REG_R12: ::c_int = 4;
+pub const REG_R13: ::c_int = 5;
+pub const REG_R14: ::c_int = 6;
+pub const REG_R15: ::c_int = 7;
+pub const REG_RDI: ::c_int = 8;
+pub const REG_RSI: ::c_int = 9;
+pub const REG_RBP: ::c_int = 10;
+pub const REG_RBX: ::c_int = 11;
+pub const REG_RDX: ::c_int = 12;
+pub const REG_RAX: ::c_int = 13;
+pub const REG_RCX: ::c_int = 14;
+pub const REG_RSP: ::c_int = 15;
+pub const REG_RIP: ::c_int = 16;
+pub const REG_EFL: ::c_int = 17;
+pub const REG_CSGSFS: ::c_int = 18;
+pub const REG_ERR: ::c_int = 19;
+pub const REG_TRAPNO: ::c_int = 20;
+pub const REG_OLDMASK: ::c_int = 21;
+pub const REG_CR2: ::c_int = 22;
+pub const NGREG: ::c_int = 23;
+pub const CPU_SETSIZE: ::c_int = 1024;
+pub const __MLIBC_THREAD_CREATE_JOINABLE: ::c_int = 0;
+pub const __MLIBC_THREAD_CREATE_DETACHED: ::c_int = 1;
+pub const __MLIBC_THREAD_MUTEX_DEFAULT: ::c_int = 0;
+pub const __MLIBC_THREAD_MUTEX_NORMAL: ::c_int = 0;
+pub const __MLIBC_THREAD_MUTEX_ERRORCHECK: ::c_int = 1;
+pub const __MLIBC_THREAD_MUTEX_RECURSIVE: ::c_int = 2;
+pub const __MLIBC_THREAD_PROCESS_PRIVATE: ::c_int = 0;
+pub const __MLIBC_THREAD_PROCESS_SHARED: ::c_int = 1;
+pub const __MLIBC_THREAD_MUTEX_STALLED: ::c_int = 0;
+pub const __MLIBC_THREAD_MUTEX_ROBUST: ::c_int = 1;
+pub const __MLIBC_THREAD_PRIO_NONE: ::c_int = 0;
+pub const __MLIBC_THREAD_PRIO_INHERIT: ::c_int = 1;
+pub const __MLIBC_THREAD_PRIO_PROTECT: ::c_int = 2;
+s! {
+    pub struct timespec {
+        pub tv_sec: ::time_t,
+        pub tv_nsec: ::c_long,
+    }
+}
+pub type clock_t = ::c_long;
+extern "C" {
+    pub fn clock() -> ::clock_t;
+    pub fn timespec_get(ptr: *mut ::timespec, base: ::c_int) -> ::c_int;
+    pub fn asctime(ptr: *const ::tm) -> *mut ::c_char;
+    pub fn ctime(timer: *const ::time_t) -> *mut ::c_char;
+    pub fn strftime(
+        dest: *mut ::c_char,
+        max_size: ::size_t,
+        format: *const ::c_char,
+        ptr: *const ::tm,
+    ) -> ::size_t;
+    pub fn tzset();
+}
+extern "C" {
+    pub fn timer_getoverrun(timerid: ::timer_t) -> ::c_int;
+    pub fn futimes(arg0: ::c_int, arg1: *const ::timeval) -> ::c_int;
+    pub fn lutimes(filename: *const ::c_char, tv: *const ::timeval) -> ::c_int;
+}
+extern "C" {
+    pub fn clock_nanosleep(
+        arg0: ::clockid_t,
+        arg1: ::c_int,
+        arg2: *const ::timespec,
+        arg3: *mut ::timespec,
+    ) -> ::c_int;
+    pub fn asctime_r(tm: *const ::tm, buf: *mut ::c_char) -> *mut ::c_char;
+    pub fn ctime_r(arg0: *const ::time_t, arg1: *mut ::c_char) -> *mut ::c_char;
+    pub fn strptime(arg0: *const ::c_char, arg1: *const ::c_char, arg2: *mut ::tm)
+        -> *mut ::c_char;
+    pub fn timelocal(arg0: *mut ::tm) -> ::time_t;
+}
+s! {
+    pub struct itimerspec {
+        pub it_interval: ::timespec,
+        pub it_value: ::timespec,
+    }
+}
+s_no_extra_traits! {
+#[repr(C)]
+    pub union sigval {
+        pub sival_int: ::c_int,
+        pub sival_ptr: *mut ::c_void,
+    }
+}
+s! {
+    pub struct siginfo_t {
+        pub si_signo: ::c_int,
+        pub si_errno: ::c_int,
+        pub si_code: ::c_int,
+        pub __si_fields: [::c_char; 124],
+    }
+}
+pub type __sighandler = ::Option<unsafe extern "C" fn(::c_int) -> ::c_void>;
+s! {
+    pub struct sigset_t {
+        pub sig: [::c_ulong; 16],
+    }
+}
+s! {
+    pub struct __stack {
+        pub ss_sp: *mut ::c_void,
+        pub ss_flags: ::c_int,
+        pub ss_size: ::size_t,
+    }
+}
+pub type stack_t = ::__stack;
+pub type __cpu_mask = ::c_ulong;
+s! {
+    pub struct cpu_set_t {
+        pub __bits: [::__cpu_mask; 16],
+    }
+}
+s! {
+    pub struct __mlibc_thread_data {
+    }
+    pub struct __mlibc_threadattr {
+        pub __mlibc_guardsize: ::size_t,
+        pub __mlibc_stacksize: ::size_t,
+        pub __mlibc_stackaddr: *mut ::c_void,
+        pub __mlibc_detachstate: ::c_int,
+        pub __mlibc_scope: ::c_int,
+        pub __mlibc_inheritsched: ::c_int,
+        pub __mlibc_schedparam: ::sched_param,
+        pub __mlibc_schedpolicy: ::c_int,
+        pub __mlibc_cpuset: *mut ::cpu_set_t,
+        pub __mlibc_cpusetsize: ::size_t,
+        pub __mlibc_sigmask: ::sigset_t,
+        pub __mlibc_sigmaskset: ::c_int,
+    }
+    pub struct __mlibc_mutex {
+        #[doc(hidden)]
+        size: [u8; 16],
+    }
+    pub struct __mlibc_mutexattr {
+        pub __mlibc_type: ::c_int,
+        pub __mlibc_robust: ::c_int,
+        pub __mlibc_protocol: ::c_int,
+        pub __mlibc_pshared: ::c_int,
+        pub __mlibc_prioceiling: ::c_int,
+    }
+    pub struct __mlibc_cond {
+        #[doc(hidden)]
+        size: [u8; 12],
+    }
+    pub struct __mlibc_condattr {
+        pub __mlibc_pshared: ::c_int,
+        pub __mlibc_clock: ::clockid_t,
+    }
+    pub struct sigaction {
+        pub sa_sigaction: sighandler_t,
+        pub sa_flags: ::c_ulong,
+        pub sa_restorer: ::Option<unsafe extern "C" fn() -> ::c_void>,
+        pub sa_mask: ::sigset_t,
+    }
+    pub struct _fpreg {
+        pub significand: [::c_ushort; 4],
+        pub exponent: ::c_ushort,
+    }
+    pub struct _fpxreg {
+        pub significand: [::c_ushort; 4],
+        pub exponent: ::c_ushort,
+        pub padding: [::c_ushort; 3],
+    }
+    pub struct _xmmreg {
+        pub element: [u32; 4],
+    }
+    pub struct _fpstate {
+        pub cwd: u16,
+        pub swd: u16,
+        pub ftw: u16,
+        pub fop: u16,
+        pub rip: u64,
+        pub rdp: u64,
+        pub mxcsr: u32,
+        pub mxcr_mask: u32,
+        pub _st: [::_fpxreg; 8],
+        pub _xmm: [::_xmmreg; 16],
+        pub padding: [u32; 24],
+    }
+    pub struct mcontext_t {
+        pub gregs: [::c_ulong; 23],
+        pub fpregs: *mut ::_fpstate,
+        pub __reserved1: [::c_ulong; 8],
+    }
+}
+s! {
+    pub struct __ucontext {
+        pub uc_flags: ::c_ulong,
+        pub uc_link: *mut ::__ucontext,
+        pub uc_stack: ::stack_t,
+        pub uc_mcontext: ::mcontext_t,
+        pub uc_sigmask: ::sigset_t,
+    }
+}
+pub type ucontext_t = ::__ucontext;
+
+// abi-bits/socket.h
+
+// abi-bits/socklen_t.h
+
+// abi-bits/stat.h
+s! {
+    pub struct stat {
+        pub st_dev: ::dev_t,
+        pub st_ino: ::ino_t,
+        pub st_nlink: ::nlink_t,
+        pub st_mode: ::mode_t,
+        pub st_uid: ::uid_t,
+        pub st_gid: ::gid_t,
+        pub __pad0: ::c_uint,
+        pub st_rdev: ::dev_t,
+        pub st_size: ::off_t,
+        pub st_blksize: ::blksize_t,
+        pub st_blocks: ::blkcnt_t,
+        pub st_atime: ::time_t,
+        pub st_atime_nsec: i64,
+        pub st_mtime: ::time_t,
+        pub st_mtime_nsec: i64,
+        pub st_ctime: ::time_t,
+        pub st_ctime_nsec: i64,
+        pub __unused: [::c_long; 3],
+    }
+}
+
+// abi-bits/statfs.h
+s! {
+    pub struct __mlibc_fsid {
+        pub __val: [::c_int; 2],
+    }
+}
+pub type fsid_t = ::__mlibc_fsid;
+s! {
+    pub struct statfs {
+        pub f_type: ::c_ulong,
+        pub f_bsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_fsid: ::fsid_t,
+        pub f_namelen: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_flags: ::c_ulong,
+        pub __f_spare: [::c_ulong; 4],
+    }
+}
+
+// abi-bits/statvfs.h
+pub const ST_RDONLY: ::c_int = 1;
+pub const ST_NOSUID: ::c_int = 2;
+pub const ST_MANDLOCK: ::c_int = 64;
+s! {
+    pub struct statvfs {
+        pub f_bsize: ::c_ulong,
+        pub f_frsize: ::c_ulong,
+        pub f_blocks: ::fsblkcnt_t,
+        pub f_bfree: ::fsblkcnt_t,
+        pub f_bavail: ::fsblkcnt_t,
+        pub f_files: ::fsfilcnt_t,
+        pub f_ffree: ::fsfilcnt_t,
+        pub f_favail: ::fsfilcnt_t,
+        pub f_fsid: ::c_ulong,
+        pub f_flag: ::c_ulong,
+        pub f_namemax: ::c_ulong,
+    }
+}
+
+// abi-bits/statx.h
+pub const STATX_TYPE: ::c_int = 0x1;
+pub const STATX_MODE: ::c_int = 0x2;
+pub const STATX_NLINK: ::c_int = 0x4;
+pub const STATX_UID: ::c_int = 0x8;
+pub const STATX_GID: ::c_int = 0x10;
+pub const STATX_ATIME: ::c_int = 0x20;
+pub const STATX_MTIME: ::c_int = 0x40;
+pub const STATX_CTIME: ::c_int = 0x80;
+pub const STATX_INO: ::c_int = 0x100;
+pub const STATX_SIZE: ::c_int = 0x200;
+pub const STATX_BLOCKS: ::c_int = 0x400;
+pub const STATX_BASIC_STATS: ::c_int = 0x7ff;
+pub const STATX_BTIME: ::c_int = 0x800;
+pub const STATX_MNT_ID: ::c_int = 0x1000;
+pub const STATX_DIOALIGN: ::c_int = 0x2000;
+pub const STATX_ALL: ::c_int = 0xfff;
+pub const STATX_ATTR_COMPRESSED: ::c_int = 0x4;
+pub const STATX_ATTR_IMMUTABLE: ::c_int = 0x10;
+pub const STATX_ATTR_APPEND: ::c_int = 0x20;
+pub const STATX_ATTR_NODUMP: ::c_int = 0x40;
+pub const STATX_ATTR_ENCRYPTED: ::c_int = 0x800;
+pub const STATX_ATTR_AUTOMOUNT: ::c_int = 0x1000;
+pub const STATX_ATTR_MOUNT_ROOT: ::c_int = 0x2000;
+pub const STATX_ATTR_VERITY: ::c_int = 0x100000;
+pub const STATX_ATTR_DAX: ::c_int = 0x200000;
+s! {
+    pub struct statx_timestamp {
+        pub tv_sec: i64,
+        pub tv_nsec: u32,
+        pub __padding: u32,
+    }
+    pub struct statx {
+        pub stx_mask: u32,
+        pub stx_blksize: u32,
+        pub stx_attributes: u64,
+        pub stx_nlink: u32,
+        pub stx_uid: u32,
+        pub stx_gid: u32,
+        pub stx_mode: u16,
+        pub __padding: u16,
+        pub stx_ino: u64,
+        pub stx_size: u64,
+        pub stx_blocks: u64,
+        pub stx_attributes_mask: u64,
+        pub stx_atime: ::statx_timestamp,
+        pub stx_btime: ::statx_timestamp,
+        pub stx_ctime: ::statx_timestamp,
+        pub stx_mtime: ::statx_timestamp,
+        pub stx_rdev_major: u32,
+        pub stx_rdev_minor: u32,
+        pub stx_dev_major: u32,
+        pub stx_dev_minor: u32,
+        pub stx_mnt_id: u64,
+        pub stx_dio_mem_align: u32,
+        pub stx_dio_offset_align: u32,
+        pub __padding1: [u64; 12],
+    }
+}
+
+// abi-bits/suseconds_t.h
+
+// abi-bits/termios.h
+pub const NCCS: usize = 32;
+pub const VEOF: usize = 4;
+pub const VTIME: ::c_int = 5;
+pub const VMIN: ::c_int = 6;
+pub const VSWTC: ::c_int = 7;
+pub const VSTART: ::c_int = 8;
+pub const VSTOP: ::c_int = 9;
+pub const VSUSP: ::c_int = 10;
+pub const VEOL: ::c_int = 11;
+pub const VREPRINT: ::c_int = 12;
+pub const VDISCARD: ::c_int = 13;
+pub const VWERASE: ::c_int = 14;
+pub const VEOL2: ::c_int = 16;
+pub const IUCLC: ::c_uint = 0o001000;
+pub const IXON: ::c_uint = 0o002000;
+pub const IXOFF: ::c_uint = 0o010000;
+pub const IUTF8: ::c_int = 0o040000;
+pub const OLCUC: ::c_int = 0o000002;
+pub const ONLCR: ::c_int = 0o000004;
+pub const VTDLY: ::c_int = 0o040000;
+pub const VT1: ::c_int = 0o040000;
+pub const CSIZE: ::c_int = 0o000060;
+pub const CS6: ::c_int = 0o000020;
+pub const CS7: ::c_int = 0o000040;
+pub const CS8: ::c_int = 0o000060;
+pub const CSTOPB: ::c_int = 0o000100;
+pub const CREAD: ::c_int = 0o000200;
+pub const PARENB: ::c_int = 0o000400;
+pub const PARODD: ::c_int = 0o001000;
+pub const HUPCL: ::c_int = 0o002000;
+pub const CLOCAL: ::c_int = 0o004000;
+pub const ISIG: ::c_int = 0o000001;
+pub const ICANON: ::c_int = 0o000002;
+pub const ECHOE: ::c_int = 0o000020;
+pub const ECHOK: ::c_int = 0o000040;
+pub const ECHONL: ::c_int = 0o000100;
+pub const NOFLSH: ::c_int = 0o000200;
+pub const TOSTOP: ::c_int = 0o000400;
+pub const IEXTEN: ::c_int = 0o100000;
+pub const NCC: ::c_int = 8;
+s! {
+    pub struct termios {
+        pub c_iflag: ::tcflag_t,
+        pub c_oflag: ::tcflag_t,
+        pub c_cflag: ::tcflag_t,
+        pub c_lflag: ::tcflag_t,
+        pub c_line: ::cc_t,
+        pub c_cc: [::cc_t; 32],
+        pub ibaud: ::speed_t,
+        pub obaud: ::speed_t,
+    }
+    pub struct termio {
+        pub c_iflag: ::c_ushort,
+        pub c_oflag: ::c_ushort,
+        pub c_cflag: ::c_ushort,
+        pub c_lflag: ::c_ushort,
+        pub c_line: ::c_uchar,
+        pub c_cc: [::c_uchar; 8],
+    }
+}
+
+// abi-bits/time.h
+pub const ITIMER_REAL: ::c_int = 0;
+pub const ITIMER_VIRTUAL: ::c_int = 1;
+pub const ITIMER_PROF: ::c_int = 2;
+s! {
+    pub struct itimerval {
+        pub it_interval: ::timeval,
+        pub it_value: ::timeval,
+    }
+}
+
+// abi-bits/uid_t.h
+
+// abi-bits/utsname.h
+
+// abi-bits/vm-flags.h
+pub const MAP_ANON: ::c_int = 0x20;
+pub const MAP_ANONYMOUS: ::c_int = 0x20;
+pub const MAP_GROWSDOWN: ::c_int = 0x100;
+pub const MAP_DENYWRITE: ::c_int = 0x800;
+pub const MAP_EXECUTABLE: ::c_int = 0x1000;
+pub const MAP_LOCKED: ::c_int = 0x2000;
+pub const MAP_NORESERVE: ::c_int = 0x4000;
+pub const MAP_POPULATE: ::c_int = 0x8000;
+pub const MAP_NONBLOCK: ::c_int = 0x10000;
+pub const MAP_STACK: ::c_int = 0x20000;
+pub const MAP_HUGETLB: ::c_int = 0x40000;
+pub const MAP_SYNC: ::c_int = 0x80000;
+pub const MAP_FIXED_NOREPLACE: ::c_int = 0x100000;
+pub const MCL_CURRENT: ::c_int = 0x01;
+pub const MCL_FUTURE: ::c_int = 0x02;
+pub const POSIX_MADV_NORMAL: ::c_int = 0;
+pub const POSIX_MADV_RANDOM: ::c_int = 1;
+pub const POSIX_MADV_SEQUENTIAL: ::c_int = 2;
+pub const POSIX_MADV_WILLNEED: ::c_int = 3;
+pub const POSIX_MADV_DONTNEED: ::c_int = 4;
+pub const MADV_SOFT_OFFLINE: ::c_int = 101;
+pub const MREMAP_MAYMOVE: ::c_int = 1;
+pub const MREMAP_FIXED: ::c_int = 2;
+pub const MFD_CLOEXEC: ::c_uint = 1;
+pub const MFD_ALLOW_SEALING: ::c_uint = 2;
+pub const MFD_HUGETLB: ::c_uint = 4;
+
+// alloca.h
+
+// arpa/inet.h
+pub const IN_CLASSA_NET: ::c_int = 0xff000000;
+pub const IN_CLASSA_NSHIFT: ::c_int = 24;
+pub const IN_CLASSA_MAX: ::c_int = 128;
+pub const IN_CLASSB_NET: ::c_int = 0xffff0000;
+pub const IN_CLASSB_NSHIFT: ::c_int = 16;
+pub const IN_CLASSB_MAX: ::c_int = 65536;
+pub const IN_CLASSC_NET: ::c_int = 0xffffff00;
+pub const IN_CLASSC_NSHIFT: ::c_int = 8;
+pub const IN_LOOPBACKNET: ::c_int = 127;
+s! {
+    pub struct linger {
+        pub l_onoff: ::c_int,
+        pub l_linger: ::c_int,
+    }
+    pub struct ucred {
+        pub pid: ::pid_t,
+        pub uid: ::uid_t,
+        pub gid: ::gid_t,
+    }
+}
+extern "C" {
+    pub fn accept4(
+        arg0: ::c_int,
+        arg1: *mut ::sockaddr,
+        arg2: *mut ::socklen_t,
+        arg3: ::c_int,
+    ) -> ::c_int;
+    pub fn recvfrom(
+        arg0: ::c_int,
+        arg1: *mut ::c_void,
+        arg2: ::size_t,
+        arg3: ::c_int,
+        arg4: *mut ::sockaddr,
+        arg5: *mut ::socklen_t,
+    ) -> ::ssize_t;
+    pub fn recvmmsg(
+        sockfd: ::c_int,
+        msgvec: *mut ::mmsghdr,
+        vlen: ::c_uint,
+        flags: ::c_int,
+        timeout: *mut ::timespec,
+    ) -> ::c_int;
+    pub fn sendmmsg(
+        sockfd: ::c_int,
+        msgvec: *mut ::mmsghdr,
+        vlen: ::c_uint,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn sockatmark(arg0: ::c_int) -> ::c_int;
+}
+extern "C" {
+    pub fn htonl(arg0: u32) -> u32;
+    pub fn htons(arg0: u16) -> u16;
+    pub fn ntohl(arg0: u32) -> u32;
+    pub fn ntohs(arg0: u16) -> u16;
+    pub fn inet_addr(arg0: *const ::c_char) -> ::in_addr_t;
+    pub fn inet_ntoa(arg0: ::in_addr) -> *mut ::c_char;
+    pub fn inet_aton(arg0: *const ::c_char, arg1: *mut ::in_addr) -> ::c_int;
+    pub fn inet_ntop(
+        arg0: ::c_int,
+        arg1: *const ::c_void,
+        arg2: *mut ::c_char,
+        arg3: ::socklen_t,
+    ) -> *const ::c_char;
+    pub fn inet_pton(arg0: ::c_int, arg1: *const ::c_char, arg2: *mut ::c_void) -> ::c_int;
+    pub fn inet_makeaddr(net: ::in_addr_t, host: ::in_addr_t) -> ::in_addr;
+    pub fn inet_netof(r#in: ::in_addr) -> ::in_addr_t;
+}
+
+// arpa/nameser_compat.h
+
+// assert.h
+
+// bits/ansi/fenv.h
+pub const FE_DENORMAL: ::c_int = 2;
+pub const FE_DIVBYZERO: ::c_int = 4;
+pub const FE_INEXACT: ::c_int = 32;
+pub const FE_INVALID: ::c_int = 1;
+pub const FE_OVERFLOW: ::c_int = 8;
+pub const FE_UNDERFLOW: ::c_int = 16;
+pub const FE_TONEAREST: ::c_int = 0;
+pub const FE_DOWNWARD: ::c_int = 0x400;
+pub const FE_UPWARD: ::c_int = 0x800;
+pub const FE_TOWARDZERO: ::c_int = 0xC00;
+
+// bits/ansi/time_t.h
+
+// bits/ansi/timespec.h
+
+// bits/bsd/bsd_unistd.h
+
+// bits/cpu_set.h
+
+// bits/ether_addr.h
+s! {
+    #[repr(packed)]
+    pub struct ether_addr {
+        pub ether_addr_octet: [u8; 6],
+    }
+}
+
+// bits/glibc/glibc_icmp6.h
+pub const ND_OPT_SOURCE_LINKADDR: ::c_int = 1;
+pub const ND_OPT_TARGET_LINKADDR: ::c_int = 2;
+pub const ND_OPT_PREFIX_INFORMATION: ::c_int = 3;
+pub const ND_OPT_REDIRECTED_HEADER: ::c_int = 4;
+pub const ND_OPT_MTU: ::c_int = 5;
+pub const ND_OPT_RTR_ADV_INTERVAL: ::c_int = 7;
+pub const ND_OPT_HOME_AGENT_INFO: ::c_int = 8;
+
+// bits/glibc/glibc_malloc.h
+extern "C" {
+    pub fn malloc_usable_size(ptr: *mut ::c_void) -> ::size_t;
+}
+
+// bits/inline-definition.h
+
+// bits/linux/cpu_set.h
+pub const CHAR_BIT: ::c_int = 8;
+pub const MB_LEN_MAX: ::c_int = 4;
+pub const LONG_BIT: ::c_int = 64;
+pub const NAME_MAX: ::c_int = 255;
+pub const LINE_MAX: ::c_int = 4096;
+pub const CHARCLASS_NAME_MAX: ::c_int = 14;
+pub const RE_DUP_MAX: ::c_int = 255;
+pub const NGROUPS_MAX: ::c_int = 8;
+pub const NL_ARGMAX: ::c_int = 9;
+pub const _POSIX_ARG_MAX: ::c_int = 4096;
+pub const _POSIX_OPEN_MAX: ::c_int = 16;
+pub const _POSIX_HOST_NAME_MAX: ::c_int = 255;
+pub const _POSIX_NAME_MAX: ::c_int = 14;
+pub const _POSIX_TZNAME_MAX: ::c_int = 6;
+pub const _XOPEN_NAME_MAX: ::c_int = 255;
+pub const PTHREAD_STACK_MIN: usize = 16384;
+pub const PTHREAD_KEYS_MAX: ::c_int = 1024;
+pub type wchar_t = ::c_int;
+extern "C" {
+    pub fn rand() -> ::c_int;
+    pub fn rand_r(arg0: *mut ::c_uint) -> ::c_int;
+    pub fn srand(arg0: ::c_uint);
+    pub fn aligned_alloc(alignment: ::size_t, size: ::size_t) -> *mut ::c_void;
+    pub fn at_quick_exit(func: ::Option<unsafe extern "C" fn() -> ::c_void>) -> ::c_int;
+    pub fn _Exit(status: ::c_int);
+    pub fn quick_exit(status: ::c_int);
+    pub fn mktemp(arg0: *mut ::c_char) -> *mut ::c_char;
+    pub fn qsort_r(
+        base: *mut ::c_void,
+        nmemb: ::size_t,
+        size: ::size_t,
+        compar: ::Option<
+            unsafe extern "C" fn(*const ::c_void, *const ::c_void, *mut ::c_void) -> ::c_int,
+        >,
+        arg: *mut ::c_void,
+    );
+    pub fn abs(number: ::c_int) -> ::c_int;
+    pub fn labs(number: ::c_long) -> ::c_long;
+    pub fn llabs(number: ::c_longlong) -> ::c_longlong;
+    pub fn mblen(arg0: *const ::c_char, arg1: ::size_t) -> ::c_int;
+    pub fn mbtowc(wc: *mut ::wchar_t, mb_chr: *const ::c_char, max_size: ::size_t) -> ::c_int;
+    pub fn wctomb(mb_chr: *mut ::c_char, wc: ::wchar_t) -> ::c_int;
+    pub fn mbstowcs(
+        wc_string: *mut ::wchar_t,
+        mb_string: *const ::c_char,
+        max_size: ::size_t,
+    ) -> ::size_t;
+}
+pub type comparison_fn_t =
+    ::Option<unsafe extern "C" fn(*const ::c_void, *const ::c_void) -> ::c_int>;
+extern "C" {
+    pub fn random() -> ::c_long;
+    pub fn drand48() -> ::c_double;
+    pub fn srand48(arg0: ::c_long);
+    pub fn initstate(arg0: ::c_uint, arg1: *mut ::c_char, arg2: ::size_t) -> *mut ::c_char;
+    pub fn setstate(arg0: *mut ::c_char) -> *mut ::c_char;
+    pub fn srandom(arg0: ::c_uint);
+    pub fn mkstemps(pattern: *mut ::c_char, suffixlen: ::c_int) -> ::c_int;
+    pub fn mkostemp(arg0: *mut ::c_char, flags: ::c_int) -> ::c_int;
+    pub fn mkostemps(pattern: *mut ::c_char, suffixlen: ::c_int, flags: ::c_int) -> ::c_int;
+    pub fn strtod_l(
+        nptr: *const ::c_char,
+        endptr: *mut *mut ::c_char,
+        loc: ::locale_t,
+    ) -> ::c_double;
+    pub fn strtof_l(string: *const ::c_char, end: *mut *mut ::c_char, loc: ::locale_t)
+        -> ::c_float;
+    pub fn getloadavg(arg0: *mut ::c_double, arg1: ::c_int) -> ::c_int;
+    pub fn secure_getenv(arg0: *const ::c_char) -> *mut ::c_char;
+    pub fn canonicalize_file_name(arg0: *const ::c_char) -> *mut ::c_char;
+    pub fn reallocarray(arg0: *mut ::c_void, arg1: ::size_t, arg2: ::size_t) -> *mut ::c_void;
+}
+
+// bits/linux/linux_sched.h
+extern "C" {
+    pub fn sched_getscheduler(pid: ::pid_t) -> ::c_int;
+    pub fn sched_setaffinity(
+        pid: ::pid_t,
+        cpusetsize: ::size_t,
+        mask: *const ::cpu_set_t,
+    ) -> ::c_int;
+    pub fn sched_getaffinity(pid: ::pid_t, cpusetsize: ::size_t, mask: *mut ::cpu_set_t)
+        -> ::c_int;
+    pub fn unshare(flags: ::c_int) -> ::c_int;
+    pub fn clone(
+        arg0: ::Option<unsafe extern "C" fn(*mut ::c_void) -> ::c_int>,
+        arg1: *mut ::c_void,
+        arg2: ::c_int,
+        arg3: *mut ::c_void,
+        ...
+    ) -> ::c_int;
+    pub fn sched_getcpu() -> ::c_int;
+}
+
+// bits/linux/linux_stat.h
+extern "C" {
+    pub fn statx(
+        arg0: ::c_int,
+        arg1: *const ::c_char,
+        arg2: ::c_int,
+        arg3: ::c_uint,
+        arg4: *mut ::statx,
+    ) -> ::c_int;
+}
+
+// bits/linux/linux_unistd.h
+
+// bits/machine.h
+
+// bits/mbstate.h
+s! {
+    pub struct __mlibc_mbstate {
+        pub __progress: ::c_short,
+        pub __shift: ::c_short,
+        pub __cpoint: ::c_uint,
+    }
+}
+
+// bits/nl_item.h
+pub const ABDAY_1: ::c_int = 0x60000;
+pub const ABDAY_2: ::c_int = 0x60001;
+pub const ABDAY_3: ::c_int = 0x60002;
+pub const ABDAY_4: ::c_int = 0x60003;
+pub const ABDAY_5: ::c_int = 0x60004;
+pub const ABDAY_6: ::c_int = 0x60005;
+pub const ABDAY_7: ::c_int = 0x60006;
+pub const DAY_1: ::c_int = 0x60007;
+pub const DAY_2: ::c_int = 0x60008;
+pub const DAY_3: ::c_int = 0x60009;
+pub const DAY_4: ::c_int = 0x6000A;
+pub const DAY_5: ::c_int = 0x6000B;
+pub const DAY_6: ::c_int = 0x6000C;
+pub const DAY_7: ::c_int = 0x6000D;
+pub const ABMON_1: ::c_int = 0x6000E;
+pub const ABMON_2: ::c_int = 0x6000F;
+pub const ABMON_3: ::c_int = 0x60010;
+pub const ABMON_4: ::c_int = 0x60011;
+pub const ABMON_5: ::c_int = 0x60012;
+pub const ABMON_6: ::c_int = 0x60013;
+pub const ABMON_7: ::c_int = 0x60014;
+pub const ABMON_8: ::c_int = 0x60015;
+pub const ABMON_9: ::c_int = 0x60016;
+pub const ABMON_10: ::c_int = 0x60017;
+pub const ABMON_11: ::c_int = 0x60018;
+pub const ABMON_12: ::c_int = 0x60019;
+pub const MON_1: ::c_int = 0x6001A;
+pub const MON_2: ::c_int = 0x6001B;
+pub const MON_3: ::c_int = 0x6001C;
+pub const MON_4: ::c_int = 0x6001D;
+pub const MON_5: ::c_int = 0x6001E;
+pub const MON_6: ::c_int = 0x6001F;
+pub const MON_7: ::c_int = 0x60020;
+pub const MON_8: ::c_int = 0x60021;
+pub const MON_9: ::c_int = 0x60022;
+pub const MON_10: ::c_int = 0x60023;
+pub const MON_11: ::c_int = 0x60024;
+pub const MON_12: ::c_int = 0x60025;
+pub const AM_STR: ::c_int = 0x60026;
+pub const PM_STR: ::c_int = 0x60027;
+pub const D_T_FMT: ::c_int = 0x60028;
+pub const D_FMT: ::c_int = 0x60029;
+pub const T_FMT: ::c_int = 0x6002A;
+pub const T_FMT_AMPM: ::c_int = 0x6002B;
+pub const ERA: ::c_int = 0x6002C;
+pub const ERA_D_FMT: ::c_int = 0x6002D;
+pub const ALT_DIGITS: ::c_int = 0x6002E;
+pub const ERA_D_T_FMT: ::c_int = 0x6002F;
+pub const ERA_T_FMT: ::c_int = 0x60030;
+pub const CODESET: ::c_int = 0x30000;
+pub const CRNCYSTR: ::c_int = 0x40000;
+pub const RADIXCHAR: ::c_int = 0x50000;
+pub const THOUSEP: ::c_int = 0x50001;
+pub const YESEXPR: ::c_int = 0x70000;
+pub const NOEXPR: ::c_int = 0x70001;
+pub type nl_item = ::c_int;
+
+// bits/off_t.h
+
+// bits/posix/fd_set.h
+
+// bits/posix/id_t.h
+
+// bits/posix/in_addr_t.h
+
+// bits/posix/in_port_t.h
+
+// bits/posix/iovec.h
+
+// bits/posix/locale_t.h
+
+// bits/posix/posix_ctype.h
+extern "C" {
+    pub fn isalnum_l(c: ::c_int, loc: ::locale_t) -> ::c_int;
+    pub fn isalpha_l(c: ::c_int, loc: ::locale_t) -> ::c_int;
+    pub fn isblank_l(c: ::c_int, loc: ::locale_t) -> ::c_int;
+    pub fn iscntrl_l(c: ::c_int, loc: ::locale_t) -> ::c_int;
+    pub fn isdigit_l(c: ::c_int, loc: ::locale_t) -> ::c_int;
+    pub fn isgraph_l(c: ::c_int, loc: ::locale_t) -> ::c_int;
+    pub fn islower_l(c: ::c_int, loc: ::locale_t) -> ::c_int;
+    pub fn isprint_l(c: ::c_int, loc: ::locale_t) -> ::c_int;
+    pub fn ispunct_l(c: ::c_int, loc: ::locale_t) -> ::c_int;
+    pub fn isspace_l(c: ::c_int, loc: ::locale_t) -> ::c_int;
+    pub fn isupper_l(c: ::c_int, loc: ::locale_t) -> ::c_int;
+    pub fn isxdigit_l(c: ::c_int, loc: ::locale_t) -> ::c_int;
+    pub fn isascii_l(c: ::c_int, loc: ::locale_t) -> ::c_int;
+    pub fn tolower_l(c: ::c_int, loc: ::locale_t) -> ::c_int;
+    pub fn toupper_l(c: ::c_int, loc: ::locale_t) -> ::c_int;
+}
+
+// bits/posix/posix_locale.h
+
+// bits/posix/posix_signal.h
+pub const FPE_INTDIV: ::c_int = 1;
+pub const FPE_INTOVF: ::c_int = 2;
+pub const FPE_FLTDIV: ::c_int = 3;
+pub const FPE_FLTOVF: ::c_int = 4;
+pub const FPE_FLTUND: ::c_int = 5;
+pub const FPE_FLTRES: ::c_int = 6;
+pub const FPE_FLTINV: ::c_int = 7;
+pub const FPE_FLTSUB: ::c_int = 8;
+pub const TRAP_BRKPT: ::c_int = 1;
+pub const TRAP_TRACE: ::c_int = 2;
+pub type pthread_t = *mut ::__mlibc_thread_data;
+s! {
+    pub struct _libc_fpxreg {
+        pub significand: [::c_ushort; 4],
+        pub exponent: ::c_ushort,
+        pub __glibc_reserved1: [::c_ushort; 3],
+    }
+    pub struct _libc_xmmreg {
+        pub element: [u32; 4],
+    }
+    pub struct _libc_fpstate {
+        pub cwd: u16,
+        pub swd: i16,
+        pub ftw: u16,
+        pub fop: u16,
+        pub rip: u64,
+        pub dp: u64,
+        pub mxcsr: u32,
+        pub mxcr_mask: u32,
+        pub _st: [::_libc_fpxreg; 8],
+        pub _xmm: [::_libc_xmmreg; 16],
+        pub __glibc_reserved1: [u32; 24],
+    }
+}
+pub type fpregset_t = *mut ::_libc_fpstate;
+pub type greg_t = ::c_ulong;
+extern "C" {
+    pub fn sigsuspend(arg0: *const ::sigset_t) -> ::c_int;
+    pub fn pthread_sigmask(
+        arg0: ::c_int,
+        arg1: *const ::sigset_t,
+        arg2: *mut ::sigset_t,
+    ) -> ::c_int;
+    pub fn pthread_kill(arg0: ::pthread_t, arg1: ::c_int) -> ::c_int;
+    pub fn siginterrupt(sig: ::c_int, flag: ::c_int) -> ::c_int;
+    pub fn sigaltstack(ss: *const ::stack_t, oss: *mut ::stack_t) -> ::c_int;
+    pub fn sigtimedwait(
+        set: *const ::sigset_t,
+        info: *mut ::siginfo_t,
+        timeout: *const ::timespec,
+    ) -> ::c_int;
+    pub fn sigwait(set: *const ::sigset_t, sig: *mut ::c_int) -> ::c_int;
+    pub fn sigwaitinfo(set: *const ::sigset_t, info: *mut ::siginfo_t) -> ::c_int;
+    pub fn sigisemptyset(set: *const ::sigset_t) -> ::c_int;
+    pub fn sigqueue(pid: ::pid_t, sig: ::c_int, value: ::sigval) -> ::c_int;
+}
+
+// bits/posix/posix_stdio.h
+extern "C" {
+    pub fn popen(arg0: *const ::c_char, arg1: *const ::c_char) -> *mut ::FILE;
+    pub fn fseeko64(stream: *mut ::FILE, offset: ::off64_t, whence: ::c_int) -> ::c_int;
+    pub fn ftello64(stream: *mut ::FILE) -> ::off64_t;
+    pub fn dprintf(fd: ::c_int, format: *const ::c_char, ...) -> ::c_int;
+    pub fn vdprintf(fd: ::c_int, format: *const ::c_char, args: *mut c_char) -> ::c_int;
+    pub fn fgetln(arg0: *mut ::FILE, arg1: *mut ::size_t) -> *mut ::c_char;
+}
+
+// bits/posix/posix_stdlib.h
+
+// bits/posix/posix_string.h
+extern "C" {
+    pub fn strsep(stringp: *mut *mut ::c_char, delim: *const ::c_char) -> *mut ::c_char;
+    pub fn memccpy(
+        dest: *mut ::c_void,
+        src: *const ::c_void,
+        c: ::c_int,
+        n: ::size_t,
+    ) -> *mut ::c_void;
+    pub fn strcoll_l(s1: *const ::c_char, s2: *const ::c_char, locale: ::locale_t) -> ::c_int;
+    pub fn strlcpy(d: *mut ::c_char, s: *const ::c_char, n: ::size_t) -> ::c_ulong;
+    pub fn strlcat(d: *mut ::c_char, s: *const ::c_char, n: ::size_t) -> ::c_ulong;
+}
+
+// bits/posix/posix_time.h
+
+// bits/posix/posix_wctype.h
+pub type wint_t = ::c_uint;
+pub type wctype_t = ::c_ulong;
+pub type wctrans_t = ::c_ulong;
+extern "C" {
+    pub fn iswalnum_l(arg0: ::wint_t, arg1: ::locale_t) -> ::c_int;
+    pub fn iswblank_l(arg0: ::wint_t, arg1: ::locale_t) -> ::c_int;
+    pub fn iswcntrl_l(arg0: ::wint_t, arg1: ::locale_t) -> ::c_int;
+    pub fn iswdigit_l(arg0: ::wint_t, arg1: ::locale_t) -> ::c_int;
+    pub fn iswgraph_l(arg0: ::wint_t, arg1: ::locale_t) -> ::c_int;
+    pub fn iswlower_l(arg0: ::wint_t, arg1: ::locale_t) -> ::c_int;
+    pub fn iswprint_l(arg0: ::wint_t, arg1: ::locale_t) -> ::c_int;
+    pub fn iswpunct_l(arg0: ::wint_t, arg1: ::locale_t) -> ::c_int;
+    pub fn iswspace_l(arg0: ::wint_t, arg1: ::locale_t) -> ::c_int;
+    pub fn iswupper_l(arg0: ::wint_t, arg1: ::locale_t) -> ::c_int;
+    pub fn iswxdigit_l(arg0: ::wint_t, arg1: ::locale_t) -> ::c_int;
+    pub fn iswalpha_l(arg0: ::wint_t, arg1: ::locale_t) -> ::c_int;
+    pub fn wctype_l(arg0: *const ::c_char, arg1: ::locale_t) -> ::wctype_t;
+    pub fn iswctype_l(arg0: ::wint_t, arg1: ::wctype_t, arg2: ::locale_t) -> ::c_int;
+    pub fn towlower_l(arg0: ::wint_t, arg1: ::locale_t) -> ::wint_t;
+    pub fn towupper_l(arg0: ::wint_t, arg1: ::locale_t) -> ::wint_t;
+    pub fn wctrans_l(arg0: *const ::c_char, arg1: ::locale_t) -> ::wctrans_t;
+    pub fn towctrans_l(arg0: ::wint_t, arg1: ::wctrans_t, arg2: ::locale_t) -> ::wint_t;
+}
+
+// bits/posix/pthread_t.h
+
+// bits/posix/stat.h
+
+// bits/posix/timer_t.h
+
+// bits/posix/timeval.h
+
+// bits/sigset_t.h
+
+// bits/size_t.h
+
+// bits/ssize_t.h
+
+// bits/threads.h
+
+// bits/types.h
+
+// bits/wchar.h
+
+// bits/wchar_t.h
+
+// bits/winsize.h
+s! {
+    pub struct winsize {
+        pub ws_row: ::c_ushort,
+        pub ws_col: ::c_ushort,
+        pub ws_xpixel: ::c_ushort,
+        pub ws_ypixel: ::c_ushort,
+    }
+}
+
+// bits/wint_t.h
+
+// ctype.h
+extern "C" {
+    pub fn isascii(c: ::c_int) -> ::c_int;
+}
+
+// dirent.h
+pub const DT_WHT: ::c_int = 14;
+s! {
+    pub struct dirent {
+        pub d_ino: ::ino_t,
+        pub d_off: ::off_t,
+        pub d_reclen: ::c_ushort,
+        pub d_type: ::c_uchar,
+        pub d_name: [::c_char; 1024],
+    }
+    pub struct __mlibc_dir_struct {
+        pub __handle: ::c_int,
+        pub __ent_next: usize,
+        pub __ent_limit: usize,
+        pub __ent_buffer: [::c_char; 2048],
+        pub __current: ::dirent,
+    }
+}
+extern "C" {
+    pub fn alphasort(arg0: *const *mut ::dirent, arg1: *const *mut ::dirent) -> ::c_int;
+    pub fn readdir64(arg0: *mut ::DIR) -> *mut ::dirent64;
+    pub fn scandir(
+        arg0: *const ::c_char,
+        arg1: *mut *mut *mut ::dirent,
+        arg2: ::Option<unsafe extern "C" fn(*const ::dirent) -> ::c_int>,
+        arg3: ::Option<unsafe extern "C" fn(*const *mut ::dirent, *const *mut ::dirent) -> ::c_int>,
+    ) -> ::c_int;
+    pub fn seekdir(arg0: *mut ::DIR, arg1: ::c_long);
+    pub fn telldir(arg0: *mut ::DIR) -> ::c_long;
+    pub fn versionsort(arg0: *const *mut ::dirent, arg1: *const *mut ::dirent) -> ::c_int;
+}
+
+// errno.h
+extern "C" {
+    pub fn __errno_location() -> *mut ::c_int;
+}
+
+// error.h
+extern "C" {
+    pub fn error(status: ::c_int, errnum: ::c_int, format: *const ::c_char, ...);
+    pub fn error_at_line(
+        status: ::c_int,
+        errnum: ::c_int,
+        filename: *const ::c_char,
+        linenum: ::c_uint,
+        format: *const ::c_char,
+        ...
+    );
+}
+
+// execinfo.h
+extern "C" {
+    pub fn backtrace(arg0: *mut *mut ::c_void, arg1: ::c_int) -> ::c_int;
+    pub fn backtrace_symbols(arg0: *mut *mut ::c_void, arg1: ::c_int) -> *mut *mut ::c_char;
+    pub fn backtrace_symbols_fd(arg0: *mut *mut ::c_void, arg1: ::c_int, arg2: ::c_int);
+}
+
+// fcntl.h
+pub const O_NDELAY: ::c_int = O_NONBLOCK;
+pub const AT_STATX_SYNC_AS_STAT: ::c_int = 0x0000;
+pub const FALLOC_FL_KEEP_SIZE: ::c_int = 1;
+pub const FALLOC_FL_PUNCH_HOLE: ::c_int = 2;
+s! {
+    pub struct flock {
+        pub l_type: ::c_short,
+        pub l_whence: ::c_short,
+        pub l_start: ::off_t,
+        pub l_len: ::off_t,
+        pub l_pid: ::pid_t,
+    }
+}
+extern "C" {
+    pub fn fallocate(fd: ::c_int, mode: ::c_int, offset: ::off_t, len: ::off_t) -> ::c_int;
+    pub fn posix_fallocate(arg0: ::c_int, arg1: ::off_t, arg2: ::off_t) -> ::c_int;
+}
+s! {
+    pub struct file_handle {
+        pub handle_bytes: ::c_uint,
+        pub handle_type: ::c_int,
+        pub f_handle: [::c_uchar; 0],
+    }
+}
+extern "C" {
+    pub fn name_to_handle_at(
+        arg0: ::c_int,
+        arg1: *const ::c_char,
+        arg2: *mut ::file_handle,
+        arg3: *mut ::c_int,
+        arg4: ::c_int,
+    ) -> ::c_int;
+    pub fn open_by_handle_at(arg0: ::c_int, arg1: *mut ::file_handle, arg2: ::c_int) -> ::c_int;
+    pub fn splice(
+        fd_in: ::c_int,
+        off_in: *mut ::off_t,
+        fd_out: ::c_int,
+        off_out: *mut ::off_t,
+        len: ::size_t,
+        flags: ::c_uint,
+    ) -> ::ssize_t;
+    pub fn vmsplice(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        nr_segs: ::size_t,
+        flags: ::c_uint,
+    ) -> ::ssize_t;
+}
+
+// features.h
+
+// getopt.h
+pub const no_argument: ::c_int = 0;
+pub const required_argument: ::c_int = 1;
+pub const optional_argument: ::c_int = 2;
+s! {
+    pub struct option {
+        pub name: *const ::c_char,
+        pub has_arg: ::c_int,
+        pub flag: *mut ::c_int,
+        pub val: ::c_int,
+    }
+}
+extern "C" {
+    pub fn getopt_long(
+        arg0: ::c_int,
+        arg1: *mut *mut ::c_char,
+        arg2: *const ::c_char,
+        arg3: *const option,
+        arg4: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn getopt_long_only(
+        arg0: ::c_int,
+        arg1: *mut *mut ::c_char,
+        arg2: *const ::c_char,
+        arg3: *const option,
+        arg4: *mut ::c_int,
+    ) -> ::c_int;
+}
+
+// glob.h
+pub const GLOB_APPEND: ::c_int = 0x01;
+pub const GLOB_DOOFFS: ::c_int = 0x02;
+pub const GLOB_ERR: ::c_int = 0x04;
+pub const GLOB_MARK: ::c_int = 0x08;
+pub const GLOB_NOCHECK: ::c_int = 0x10;
+pub const GLOB_NOESCAPE: ::c_int = 0x20;
+pub const GLOB_NOSORT: ::c_int = 0x40;
+pub const GLOB_PERIOD: ::c_int = 0x80;
+pub const GLOB_TILDE: ::c_int = 0x100;
+pub const GLOB_TILDE_CHECK: ::c_int = 0x200;
+pub const GLOB_BRACE: ::c_int = 0x400;
+pub const GLOB_NOMAGIC: ::c_int = 0x800;
+pub const GLOB_ALTDIRFUNC: ::c_int = 0x1000;
+pub const GLOB_ONLYDIR: ::c_int = 0x2000;
+pub const GLOB_MAGCHAR: ::c_int = 0x4000;
+pub const GLOB_ABORTED: ::c_int = 1;
+pub const GLOB_NOMATCH: ::c_int = 2;
+pub const GLOB_NOSPACE: ::c_int = 3;
+pub const GLOB_NOSYS: ::c_int = 4;
+s! {
+    pub struct glob_t {
+        pub gl_pathc: ::size_t,
+        pub gl_pathv: *mut *mut ::c_char,
+        pub gl_offs: ::size_t,
+        pub gl_flags: ::c_int,
+        pub gl_closedir: ::Option<unsafe extern "C" fn(*mut ::c_void) -> ::c_void>,
+        pub gl_readdir: ::Option<unsafe extern "C" fn(*mut ::c_void) -> *mut ::dirent>,
+        pub gl_opendir: ::Option<unsafe extern "C" fn(*const ::c_char) -> *mut ::c_void>,
+        pub gl_lstat: ::Option<unsafe extern "C" fn(*const ::c_char, *mut ::stat) -> ::c_int>,
+        pub gl_stat: ::Option<unsafe extern "C" fn(*const ::c_char, *mut ::stat) -> ::c_int>,
+    }
+}
+extern "C" {
+    pub fn glob(
+        arg0: *const ::c_char,
+        arg1: ::c_int,
+        arg2: ::Option<unsafe extern "C" fn(*const ::c_char, ::c_int) -> ::c_int>,
+        arg3: *mut ::glob_t,
+    ) -> ::c_int;
+    pub fn globfree(arg0: *mut ::glob_t);
+}
+
+// grp.h
+pub const BUFSIZ: ::c_int = 512;
+pub const FOPEN_MAX: ::c_int = 1024;
+pub const FILENAME_MAX: ::c_int = 256;
+pub const L_tmpnam: ::c_int = 256;
+pub const TMP_MAX: ::c_int = 1024;
+s! {
+    pub struct __mlibc_file_base {
+        pub __buffer_ptr: *mut ::c_char,
+        pub __buffer_size: ::size_t,
+        pub __offset: ::size_t,
+        pub __io_offset: ::size_t,
+        pub __valid_limit: ::size_t,
+        pub __dirty_begin: ::size_t,
+        pub __dirty_end: ::size_t,
+        pub __unget_ptr: *mut ::c_char,
+        pub __io_mode: ::c_int,
+        pub __status_bits: ::c_int,
+    }
+}
+extern "C" {
+    pub fn setlinebuf(stream: *mut ::FILE);
+    pub fn setbuffer(arg0: *mut ::FILE, arg1: *mut ::c_char, arg2: ::size_t);
+    pub fn vfprintf(stream: *mut ::FILE, format: *const ::c_char, args: *mut c_char) -> ::c_int;
+    pub fn vfscanf(stream: *mut ::FILE, format: *const ::c_char, args: *mut c_char) -> ::c_int;
+    pub fn vprintf(format: *const ::c_char, args: *mut c_char) -> ::c_int;
+    pub fn vscanf(format: *const ::c_char, args: *mut c_char) -> ::c_int;
+    pub fn vsnprintf(
+        buffer: *mut ::c_char,
+        max_size: ::size_t,
+        format: *const ::c_char,
+        args: *mut c_char,
+    ) -> ::c_int;
+    pub fn vsprintf(buffer: *mut ::c_char, format: *const ::c_char, args: *mut c_char) -> ::c_int;
+    pub fn vsscanf(buffer: *const ::c_char, format: *const ::c_char, args: *mut c_char) -> ::c_int;
+    pub fn vasprintf(
+        arg0: *mut *mut ::c_char,
+        arg1: *const ::c_char,
+        arg_list: *mut c_char,
+    ) -> ::c_int;
+    pub fn gets(s: *mut ::c_char) -> *mut ::c_char;
+    pub fn getc(stream: *mut ::FILE) -> ::c_int;
+    pub fn putc(c: ::c_int, stream: *mut ::FILE) -> ::c_int;
+    pub fn getc_unlocked(arg0: *mut ::FILE) -> ::c_int;
+    pub fn putc_unlocked(arg0: ::c_int, arg1: *mut ::FILE) -> ::c_int;
+    pub fn getdelim(
+        arg0: *mut *mut ::c_char,
+        arg1: *mut ::size_t,
+        arg2: ::c_int,
+        arg3: *mut ::FILE,
+    ) -> ::ssize_t;
+    pub fn asprintf(arg0: *mut *mut ::c_char, arg1: *const ::c_char, ...) -> ::c_int;
+    pub fn flockfile(arg0: *mut ::FILE);
+    pub fn funlockfile(arg0: *mut ::FILE);
+    pub fn ftrylockfile(arg0: *mut ::FILE) -> ::c_int;
+    pub fn clearerr_unlocked(arg0: *mut ::FILE);
+    pub fn feof_unlocked(arg0: *mut ::FILE) -> ::c_int;
+    pub fn ferror_unlocked(arg0: *mut ::FILE) -> ::c_int;
+    pub fn fileno_unlocked(arg0: *mut ::FILE) -> ::c_int;
+    pub fn fflush_unlocked(arg0: *mut ::FILE) -> ::c_int;
+    pub fn fgetc_unlocked(arg0: *mut ::FILE) -> ::c_int;
+    pub fn fputc_unlocked(arg0: ::c_int, arg1: *mut ::FILE) -> ::c_int;
+    pub fn fread_unlocked(
+        arg0: *mut ::c_void,
+        arg1: ::size_t,
+        arg2: ::size_t,
+        arg3: *mut ::FILE,
+    ) -> ::size_t;
+    pub fn fwrite_unlocked(
+        arg0: *const ::c_void,
+        arg1: ::size_t,
+        arg2: ::size_t,
+        arg3: *mut ::FILE,
+    ) -> ::size_t;
+    pub fn fgets_unlocked(arg0: *mut ::c_char, arg1: ::c_int, arg2: *mut ::FILE) -> *mut ::c_char;
+    pub fn fputs_unlocked(arg0: *const ::c_char, arg1: *mut ::FILE) -> ::c_int;
+}
+s! {
+    pub struct group {
+        pub gr_name: *mut ::c_char,
+        pub gr_passwd: *mut ::c_char,
+        pub gr_gid: ::gid_t,
+        pub gr_mem: *mut *mut ::c_char,
+    }
+}
+extern "C" {
+    pub fn endgrent();
+    pub fn getgrent() -> *mut ::group;
+    pub fn getgrgid(arg0: ::gid_t) -> *mut ::group;
+    pub fn getgrgid_r(
+        arg0: ::gid_t,
+        arg1: *mut ::group,
+        arg2: *mut ::c_char,
+        arg3: ::size_t,
+        arg4: *mut *mut ::group,
+    ) -> ::c_int;
+    pub fn getgrnam(arg0: *const ::c_char) -> *mut ::group;
+    pub fn getgrnam_r(
+        arg0: *const ::c_char,
+        arg1: *mut ::group,
+        arg2: *mut ::c_char,
+        arg3: ::size_t,
+        arg4: *mut *mut ::group,
+    ) -> ::c_int;
+    pub fn setgrent();
+    pub fn putgrent(arg0: *const ::group, arg1: *mut ::FILE) -> ::c_int;
+    pub fn fgetgrent(arg0: *mut ::FILE) -> *mut ::group;
+    pub fn initgroups(user: *const ::c_char, group: ::gid_t) -> ::c_int;
+    pub fn getgrouplist(
+        arg0: *const ::c_char,
+        arg1: ::gid_t,
+        arg2: *mut ::gid_t,
+        arg3: *mut ::c_int,
+    ) -> ::c_int;
+}
+
+// ifaddrs.h
+
+// langinfo.h
+extern "C" {
+    pub fn nl_langinfo(arg0: ::nl_item) -> *mut ::c_char;
+    pub fn nl_langinfo_l(arg0: ::nl_item, arg1: ::locale_t) -> *mut ::c_char;
+}
+
+// libgen.h
+extern "C" {
+    pub fn basename(arg0: *mut ::c_char) -> *mut ::c_char;
+    pub fn dirname(arg0: *mut ::c_char) -> *mut ::c_char;
+}
+
+// limits.h
+
+// link.h
+extern "C" {
+    pub fn dl_iterate_phdr(
+        callback: ::Option<
+            unsafe extern "C" fn(*mut ::dl_phdr_info, ::size_t, *mut ::c_void) -> ::c_int,
+        >,
+        data: *mut ::c_void,
+    ) -> ::c_int;
+}
+
+// linux/libc-compat.h
+
+// malloc.h
+
+// memory.h
+extern "C" {
+    pub fn strerror_r(arg0: ::c_int, arg1: *mut ::c_char, arg2: ::size_t) -> ::c_int;
+    pub fn mempcpy(arg0: *mut ::c_void, arg1: *const ::c_void, arg2: ::size_t) -> *mut ::c_void;
+    pub fn strverscmp(l0: *const ::c_char, r0: *const ::c_char) -> ::c_int;
+    pub fn ffsl(i: ::c_long) -> ::c_int;
+    pub fn ffsll(i: ::c_longlong) -> ::c_int;
+    pub fn memmem(
+        arg0: *const ::c_void,
+        arg1: ::size_t,
+        arg2: *const ::c_void,
+        arg3: ::size_t,
+    ) -> *mut ::c_void;
+}
+
+// mntent.h
+s! {
+    pub struct mntent {
+        pub mnt_fsname: *mut ::c_char,
+        pub mnt_dir: *mut ::c_char,
+        pub mnt_type: *mut ::c_char,
+        pub mnt_opts: *mut ::c_char,
+        pub mnt_freq: ::c_int,
+        pub mnt_passno: ::c_int,
+    }
+}
+extern "C" {
+    pub fn setmntent(arg0: *const ::c_char, arg1: *const ::c_char) -> *mut ::FILE;
+    pub fn getmntent(arg0: *mut ::FILE) -> *mut ::mntent;
+    pub fn addmntent(arg0: *mut ::FILE, arg1: *const ::mntent) -> ::c_int;
+    pub fn endmntent(arg0: *mut ::FILE) -> ::c_int;
+    pub fn hasmntopt(arg0: *const ::mntent, arg1: *const ::c_char) -> *mut ::c_char;
+    pub fn getmntent_r(
+        arg0: *mut ::FILE,
+        arg1: *mut ::mntent,
+        arg2: *mut ::c_char,
+        arg3: ::c_int,
+    ) -> *mut ::mntent;
+}
+
+// mqueue.h
+pub type mqd_t = ::c_int;
+extern "C" {
+    pub fn mq_getattr(mqdes: ::mqd_t, attr: *mut ::mq_attr) -> ::c_int;
+    pub fn mq_setattr(
+        mqdes: ::mqd_t,
+        newattr: *const ::mq_attr,
+        oldattr: *mut ::mq_attr,
+    ) -> ::c_int;
+    pub fn mq_unlink(name: *const ::c_char) -> ::c_int;
+    pub fn mq_open(name: *const ::c_char, flags: ::c_int, ...) -> ::mqd_t;
+}
+
+// net/if.h
+pub const ALTIFNAMSIZ: ::c_int = 128;
+pub const IFALIASZ: ::c_int = 256;
+pub const IFHWADDRLEN: ::c_int = 6;
+pub const IFF_BROADCAST: ::c_int = 0x2;
+pub const IFF_LOOPBACK: ::c_int = 0x8;
+pub const IFF_POINTOPOINT: ::c_int = 0x10;
+pub const IFF_RUNNING: ::c_int = 0x40;
+pub const IFF_MASTER: ::c_int = 0x400;
+pub const IFF_SLAVE: ::c_int = 0x800;
+pub const IFF_LOWER_UP: ::c_int = 0x10000;
+pub const IFF_DORMANT: ::c_int = 0x20000;
+pub const IFF_ECHO: ::c_int = 0x40000;
+pub const IFF_VOLATILE: ::c_int = IFF_LOOPBACK
+    | IFF_POINTOPOINT
+    | IFF_BROADCAST
+    | IFF_ECHO
+    | IFF_MASTER
+    | IFF_SLAVE
+    | IFF_RUNNING
+    | IFF_LOWER_UP
+    | IFF_DORMANT;
+s! {
+    pub struct if_nameindex {
+        pub if_index: ::c_uint,
+        pub if_name: *mut ::c_char,
+    }
+    pub struct ifmap {
+        pub mem_start: ::c_ulong,
+        pub mem_end: ::c_ulong,
+        pub base_addr: ::c_ushort,
+        pub irq: ::c_uchar,
+        pub dma: ::c_uchar,
+        pub port: ::c_uchar,
+    }
+}
+extern "C" {
+    pub fn if_freenameindex(arg0: *mut ::if_nameindex);
+    pub fn if_nameindex() -> *mut ::if_nameindex;
+}
+
+// net/route.h
+pub const RTF_HOST: ::c_int = 0x0004;
+pub const RTF_REJECT: ::c_int = 0x0200;
+s! {
+    pub struct rtentry {
+        pub rt_pad1: ::c_ulong,
+        pub rt_dst: ::sockaddr,
+        pub rt_gateway: ::sockaddr,
+        pub rt_genmask: ::sockaddr,
+        pub rt_flags: ::c_ushort,
+        pub rt_pad2: ::c_short,
+        pub rt_pad3: ::c_ulong,
+        pub rt_tos: ::c_uchar,
+        pub rt_class: ::c_uchar,
+        pub rt_pad4: [::c_short; 3],
+        pub rt_metric: ::c_short,
+        pub rt_dev: *mut ::c_char,
+        pub rt_mtu: ::c_ulong,
+        pub rt_window: ::c_ulong,
+        pub rt_irtt: ::c_ushort,
+    }
+}
+
+// netdb.h
+pub const AI_PASSIVE: ::c_int = 0x01;
+pub const AI_CANONNAME: ::c_int = 0x02;
+pub const AI_NUMERICHOST: ::c_int = 0x04;
+pub const AI_V4MAPPED: ::c_int = 0x08;
+pub const AI_ALL: ::c_int = 0x10;
+pub const AI_ADDRCONFIG: ::c_int = 0x20;
+pub const AI_NUMERICSERV: ::c_int = 0x40;
+pub const NI_NOFQDN: ::c_int = 0x01;
+pub const NI_NUMERICHOST: ::c_int = 0x02;
+pub const NI_NAMEREQD: ::c_int = 0x04;
+pub const NI_NUMERICSCOPE: ::c_int = 0x08;
+pub const NI_DGRAM: ::c_int = 0x10;
+pub const NI_NUMERICSERV: ::c_int = 2;
+pub const NI_MAXSERV: ::c_int = 32;
+pub const NI_IDN: ::c_int = 32;
+pub const NI_IDN_USE_STD3_ASCII_RULES: ::c_int = 128;
+pub const NI_MAXHOST: ::c_int = 1025;
+pub const EAI_AGAIN: ::c_int = 1;
+pub const EAI_BADFLAGS: ::c_int = 2;
+pub const EAI_FAIL: ::c_int = 3;
+pub const EAI_FAMILY: ::c_int = 4;
+pub const EAI_MEMORY: ::c_int = 5;
+pub const EAI_NONAME: ::c_int = 6;
+pub const EAI_SERVICE: ::c_int = 7;
+pub const EAI_SOCKTYPE: ::c_int = 8;
+pub const EAI_SYSTEM: ::c_int = 9;
+pub const EAI_OVERFLOW: ::c_int = 10;
+pub const EAI_NODATA: ::c_int = 11;
+pub const EAI_ADDRFAMILY: ::c_int = 12;
+pub const HOST_NOT_FOUND: ::c_int = 1;
+pub const TRY_AGAIN: ::c_int = 2;
+pub const NO_RECOVERY: ::c_int = 3;
+pub const NO_DATA: ::c_int = 4;
+pub const NO_ADDRESS: ::c_int = NO_DATA;
+s! {
+    pub struct hostent {
+        pub h_name: *mut ::c_char,
+        pub h_aliases: *mut *mut ::c_char,
+        pub h_addrtype: ::c_int,
+        pub h_length: ::c_int,
+        pub h_addr_list: *mut *mut ::c_char,
+    }
+    pub struct netent {
+        pub n_name: *mut ::c_char,
+        pub n_aliases: *mut *mut ::c_char,
+        pub n_addrtype: ::c_int,
+        pub n_net: u32,
+    }
+    pub struct protoent {
+        pub p_name: *mut ::c_char,
+        pub p_aliases: *mut *mut ::c_char,
+        pub p_proto: ::c_int,
+    }
+    pub struct servent {
+        pub s_name: *mut ::c_char,
+        pub s_aliases: *mut *mut ::c_char,
+        pub s_port: ::c_int,
+        pub s_proto: *mut ::c_char,
+    }
+}
+extern "C" {
+    pub fn endhostent();
+    pub fn endnetent();
+    pub fn endprotoent();
+    pub fn gethostent() -> *mut ::hostent;
+    pub fn gethostbyname(arg0: *const ::c_char) -> *mut ::hostent;
+    pub fn gethostbyname2(arg0: *const ::c_char, arg1: ::c_int) -> *mut ::hostent;
+    pub fn gethostbyaddr(arg0: *const ::c_void, arg1: ::socklen_t, arg2: ::c_int)
+        -> *mut ::hostent;
+    pub fn gethostbyaddr_r(
+        arg0: *const ::c_void,
+        arg1: ::socklen_t,
+        arg2: ::c_int,
+        arg3: *mut ::hostent,
+        arg4: *mut ::c_char,
+        arg5: ::size_t,
+        arg6: *mut *mut ::hostent,
+        arg7: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn gethostbyname_r(
+        arg0: *const ::c_char,
+        arg1: *mut ::hostent,
+        arg2: *mut ::c_char,
+        arg3: ::size_t,
+        arg4: *mut *mut ::hostent,
+        arg5: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn getnameinfo(
+        arg0: *const ::sockaddr,
+        arg1: ::socklen_t,
+        arg2: *mut ::c_char,
+        arg3: ::socklen_t,
+        arg4: *mut ::c_char,
+        arg5: ::socklen_t,
+        arg6: ::c_int,
+    ) -> ::c_int;
+    pub fn getnetbyaddr(arg0: u32, arg1: ::c_int) -> *mut ::netent;
+    pub fn getnetbyname(arg0: *const ::c_char) -> *mut ::netent;
+    pub fn getnetent() -> *mut ::netent;
+    pub fn getprotoent() -> *mut ::protoent;
+    pub fn sethostent(arg0: ::c_int);
+    pub fn setnetent(arg0: ::c_int);
+    pub fn setprotoent(arg0: ::c_int);
+}
+
+// netinet/ether.h
+pub const ETH_ALEN: ::c_int = 6;
+pub const ETH_HLEN: ::c_int = 14;
+pub const ETH_ZLEN: ::c_int = 60;
+pub const ETH_FRAME_LEN: ::c_int = 1514;
+pub const ETH_FCS_LEN: ::c_int = 4;
+pub const ETH_P_LOOP: ::c_int = 0x0060;
+pub const ETH_P_PUP: ::c_int = 0x0200;
+pub const ETH_P_PUPAT: ::c_int = 0x0201;
+pub const ETH_P_IP: ::c_int = 0x0800;
+pub const ETH_P_X25: ::c_int = 0x0805;
+pub const ETH_P_ARP: ::c_int = 0x0806;
+pub const ETH_P_BPQ: ::c_int = 0x08FF;
+pub const ETH_P_IEEEPUP: ::c_int = 0x0a00;
+pub const ETH_P_IEEEPUPAT: ::c_int = 0x0a01;
+pub const ETH_P_BATMAN: ::c_int = 0x4305;
+pub const ETH_P_DEC: ::c_int = 0x6000;
+pub const ETH_P_DNA_DL: ::c_int = 0x6001;
+pub const ETH_P_DNA_RC: ::c_int = 0x6002;
+pub const ETH_P_DNA_RT: ::c_int = 0x6003;
+pub const ETH_P_LAT: ::c_int = 0x6004;
+pub const ETH_P_DIAG: ::c_int = 0x6005;
+pub const ETH_P_CUST: ::c_int = 0x6006;
+pub const ETH_P_SCA: ::c_int = 0x6007;
+pub const ETH_P_TEB: ::c_int = 0x6558;
+pub const ETH_P_RARP: ::c_int = 0x8035;
+pub const ETH_P_ATALK: ::c_int = 0x809B;
+pub const ETH_P_AARP: ::c_int = 0x80F3;
+pub const ETH_P_8021Q: ::c_int = 0x8100;
+pub const ETH_P_IPX: ::c_int = 0x8137;
+pub const ETH_P_IPV6: ::c_int = 0x86DD;
+pub const ETH_P_PAUSE: ::c_int = 0x8808;
+pub const ETH_P_SLOW: ::c_int = 0x8809;
+pub const ETH_P_WCCP: ::c_int = 0x883E;
+pub const ETH_P_MPLS_UC: ::c_int = 0x8847;
+pub const ETH_P_MPLS_MC: ::c_int = 0x8848;
+pub const ETH_P_ATMMPOA: ::c_int = 0x884c;
+pub const ETH_P_PPP_DISC: ::c_int = 0x8863;
+pub const ETH_P_PPP_SES: ::c_int = 0x8864;
+pub const ETH_P_LINK_CTL: ::c_int = 0x886c;
+pub const ETH_P_ATMFATE: ::c_int = 0x8884;
+pub const ETH_P_PAE: ::c_int = 0x888E;
+pub const ETH_P_AOE: ::c_int = 0x88A2;
+pub const ETH_P_8021AD: ::c_int = 0x88A8;
+pub const ETH_P_802_EX1: ::c_int = 0x88B5;
+pub const ETH_P_TIPC: ::c_int = 0x88CA;
+pub const ETH_P_8021AH: ::c_int = 0x88E7;
+pub const ETH_P_MVRP: ::c_int = 0x88F5;
+pub const ETH_P_1588: ::c_int = 0x88F7;
+pub const ETH_P_PRP: ::c_int = 0x88FB;
+pub const ETH_P_FCOE: ::c_int = 0x8906;
+pub const ETH_P_TDLS: ::c_int = 0x890D;
+pub const ETH_P_FIP: ::c_int = 0x8914;
+pub const ETH_P_80221: ::c_int = 0x8917;
+pub const ETH_P_LOOPBACK: ::c_int = 0x9000;
+pub const ETH_P_QINQ1: ::c_int = 0x9100;
+pub const ETH_P_QINQ2: ::c_int = 0x9200;
+pub const ETH_P_QINQ3: ::c_int = 0x9300;
+pub const ETH_P_EDSA: ::c_int = 0xDADA;
+pub const ETH_P_AF_IUCV: ::c_int = 0xFBFB;
+pub const ETH_P_802_3_MIN: ::c_int = 0x0600;
+pub const ETH_P_802_3: ::c_int = 0x0001;
+pub const ETH_P_AX25: ::c_int = 0x0002;
+pub const ETH_P_ALL: ::c_int = 0x0003;
+pub const ETH_P_802_2: ::c_int = 0x0004;
+pub const ETH_P_SNAP: ::c_int = 0x0005;
+pub const ETH_P_DDCMP: ::c_int = 0x0006;
+pub const ETH_P_WAN_PPP: ::c_int = 0x0007;
+pub const ETH_P_PPP_MP: ::c_int = 0x0008;
+pub const ETH_P_LOCALTALK: ::c_int = 0x0009;
+pub const ETH_P_CAN: ::c_int = 0x000C;
+pub const ETH_P_CANFD: ::c_int = 0x000D;
+pub const ETH_P_PPPTALK: ::c_int = 0x0010;
+pub const ETH_P_TR_802_2: ::c_int = 0x0011;
+pub const ETH_P_MOBITEX: ::c_int = 0x0015;
+pub const ETH_P_CONTROL: ::c_int = 0x0016;
+pub const ETH_P_IRDA: ::c_int = 0x0017;
+pub const ETH_P_ECONET: ::c_int = 0x0018;
+pub const ETH_P_HDLC: ::c_int = 0x0019;
+pub const ETH_P_ARCNET: ::c_int = 0x001A;
+pub const ETH_P_DSA: ::c_int = 0x001B;
+pub const ETH_P_TRAILER: ::c_int = 0x001C;
+pub const ETH_P_PHONET: ::c_int = 0x00F5;
+pub const ETH_P_IEEE802154: ::c_int = 0x00F6;
+pub const ETH_P_CAIF: ::c_int = 0x00F7;
+pub type __fd_mask = ::c_long;
+pub type fd_mask = ::__fd_mask;
+pub type u_int = ::c_uint;
+pub type u_char = ::c_uchar;
+pub type u_short = ::c_ushort;
+pub type u_long = ::c_ulong;
+pub type caddr_t = *mut ::c_char;
+pub type loff_t = ::off64_t;
+pub type ulong = ::c_ulong;
+pub type ushort = ::c_ushort;
+pub type uint = ::c_uint;
+pub type u_int8_t = u8;
+pub type u_int16_t = u16;
+pub type u_int32_t = u32;
+pub type u_int64_t = u64;
+pub type quad_t = i64;
+pub type u_quad_t = u64;
+s! {
+    pub struct ether_arp {
+        pub ea_hdr: ::arphdr,
+        pub arp_sha: [u8; 6],
+        pub arp_spa: [u8; 4],
+        pub arp_tha: [u8; 6],
+        pub arp_tpa: [u8; 4],
+    }
+}
+extern "C" {
+    pub fn ether_ntoa_r(p_a: *const ::ether_addr, x: *mut ::c_char) -> *mut ::c_char;
+    pub fn ether_aton(asc: *const ::c_char) -> *mut ::ether_addr;
+}
+
+// netinet/if_ether.h
+
+// netinet/in.h
+
+// netinet/in_systm.h
+
+// netpacket/packet.h
+pub const PACKET_BROADCAST: ::c_int = 1;
+pub const PACKET_MULTICAST: ::c_int = 2;
+pub const PACKET_OTHERHOST: ::c_int = 3;
+pub const PACKET_OUTGOING: ::c_int = 4;
+pub const PACKET_LOOPBACK: ::c_int = 5;
+pub const PACKET_FASTROUTE: ::c_int = 6;
+pub const PACKET_ADD_MEMBERSHIP: ::c_int = 1;
+pub const PACKET_DROP_MEMBERSHIP: ::c_int = 2;
+pub const PACKET_MR_MULTICAST: ::c_int = 0;
+pub const PACKET_MR_PROMISC: ::c_int = 1;
+pub const PACKET_MR_ALLMULTI: ::c_int = 2;
+pub const PACKET_MR_UNICAST: ::c_int = 3;
+s! {
+    pub struct packet_mreq {
+        pub mr_ifindex: ::c_int,
+        pub mr_type: ::c_ushort,
+        pub mr_alen: ::c_ushort,
+        pub mr_address: [::c_uchar; 8],
+    }
+}
+
+// nl_types.h
+
+// poll.h
+pub type nfds_t = usize;
+s! {
+    pub struct pollfd {
+        pub fd: ::c_int,
+        pub events: ::c_short,
+        pub revents: ::c_short,
+    }
+}
+extern "C" {
+    pub fn ppoll(
+        fds: *mut ::pollfd,
+        nfds: ::nfds_t,
+        timeout_ts: *const ::timespec,
+        sigmask: *const ::sigset_t,
+    ) -> ::c_int;
+}
+
+// pthread.h
+pub const _NSIG: ::c_int = NSIG;
+pub const SCHED_OTHER: ::c_int = 0;
+pub const SCHED_FIFO: ::c_int = 1;
+pub const SCHED_RR: ::c_int = 2;
+pub const SCHED_BATCH: ::c_int = 3;
+pub const SCHED_IDLE: ::c_int = 5;
+pub const SCHED_DEADLINE: ::c_int = 6;
+pub const SCHED_RESET_ON_FORK: ::c_int = 0x40000000;
+pub const PTHREAD_SCOPE_SYSTEM: ::c_int = 0;
+pub const PTHREAD_SCOPE_PROCESS: ::c_int = 1;
+pub const PTHREAD_INHERIT_SCHED: ::c_int = 0;
+pub const PTHREAD_EXPLICIT_SCHED: ::c_int = 1;
+pub const PTHREAD_CANCEL_DEFERRED: ::c_int = 0;
+pub const PTHREAD_CANCEL_ASYNCHRONOUS: ::c_int = 1;
+pub const PTHREAD_CANCEL_ENABLE: ::c_int = 0;
+pub const PTHREAD_CANCEL_DISABLE: ::c_int = 1;
+pub const PTHREAD_MUTEX_DEFAULT: ::c_int = __MLIBC_THREAD_MUTEX_DEFAULT;
+pub const PTHREAD_MUTEX_NORMAL: ::c_int = __MLIBC_THREAD_MUTEX_NORMAL;
+pub const PTHREAD_MUTEX_ERRORCHECK: ::c_int = __MLIBC_THREAD_MUTEX_ERRORCHECK;
+pub const PTHREAD_MUTEX_RECURSIVE: ::c_int = __MLIBC_THREAD_MUTEX_RECURSIVE;
+pub const PTHREAD_MUTEX_STALLED: ::c_int = __MLIBC_THREAD_MUTEX_STALLED;
+pub const PTHREAD_MUTEX_ROBUST: ::c_int = __MLIBC_THREAD_MUTEX_ROBUST;
+pub const PTHREAD_PROCESS_PRIVATE: ::c_int = __MLIBC_THREAD_PROCESS_PRIVATE;
+pub const PTHREAD_PROCESS_SHARED: ::c_int = __MLIBC_THREAD_PROCESS_SHARED;
+pub const PTHREAD_PRIO_NONE: ::c_int = __MLIBC_THREAD_PRIO_NONE;
+pub const PTHREAD_PRIO_INHERIT: ::c_int = __MLIBC_THREAD_PRIO_INHERIT;
+pub const PTHREAD_PRIO_PROTECT: ::c_int = __MLIBC_THREAD_PRIO_PROTECT;
+pub const PTHREAD_BARRIER_SERIAL_THREAD: ::c_int = 1;
+pub const PTHREAD_DESTRUCTOR_ITERATIONS: ::c_int = 8;
+pub const PTHREAD_ATTR_NO_SIGMASK_NP: ::c_int = 1;
+pub type sig_atomic_t = ::c_int;
+extern "C" {
+    pub fn sched_get_priority_max(policy: ::c_int) -> ::c_int;
+    pub fn sched_get_priority_min(policy: ::c_int) -> ::c_int;
+    pub fn sched_setscheduler(
+        pid: ::pid_t,
+        policy: ::c_int,
+        param: *const ::sched_param,
+    ) -> ::c_int;
+    pub fn sched_getparam(pid: ::pid_t, param: *mut ::sched_param) -> ::c_int;
+}
+pub type pthread_attr_t = ::__mlibc_threadattr;
+pub type pthread_key_t = ::uintptr_t;
+s! {
+    pub struct __mlibc_once {
+        pub __mlibc_done: ::c_uint,
+    }
+}
+pub type pthread_once_t = ::__mlibc_once;
+pub type pthread_mutexattr_t = ::__mlibc_mutexattr;
+pub type pthread_mutex_t = ::__mlibc_mutex;
+pub type pthread_condattr_t = ::__mlibc_condattr;
+pub type pthread_cond_t = ::__mlibc_cond;
+s! {
+    pub struct __mlibc_barrierattr_struct {
+        pub __mlibc_pshared: ::c_int,
+    }
+}
+pub type pthread_barrierattr_t = ::__mlibc_barrierattr_struct;
+s! {
+    pub struct __mlibc_barrier {
+        pub __mlibc_waiting: ::c_uint,
+        pub __mlibc_inside: ::c_uint,
+        pub __mlibc_count: ::c_uint,
+        pub __mlibc_seq: ::c_uint,
+        pub __mlibc_flags: ::c_uint,
+    }
+}
+pub type pthread_barrier_t = ::__mlibc_barrier;
+s! {
+    pub struct __mlibc_fair_rwlock {
+        #[doc(hidden)]
+        size: [u8; 12],
+    }
+}
+pub type pthread_rwlock_t = ::__mlibc_fair_rwlock;
+s! {
+    pub struct __mlibc_rwlockattr {
+        pub __mlibc_pshared: ::c_int,
+    }
+}
+pub type pthread_rwlockattr_t = ::__mlibc_rwlockattr;
+extern "C" {
+    pub fn pthread_attr_getdetachstate(
+        arg0: *const ::pthread_attr_t,
+        arg1: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_attr_getstackaddr(
+        arg0: *const ::pthread_attr_t,
+        arg1: *mut *mut ::c_void,
+    ) -> ::c_int;
+    pub fn pthread_attr_setstackaddr(arg0: *mut ::pthread_attr_t, arg1: *mut ::c_void) -> ::c_int;
+    pub fn pthread_attr_setstack(
+        arg0: *mut ::pthread_attr_t,
+        arg1: *mut ::c_void,
+        arg2: ::size_t,
+    ) -> ::c_int;
+    pub fn pthread_attr_getguardsize(arg0: *const ::pthread_attr_t, arg1: *mut ::size_t)
+        -> ::c_int;
+    pub fn pthread_attr_setguardsize(arg0: *mut ::pthread_attr_t, arg1: ::size_t) -> ::c_int;
+    pub fn pthread_attr_getscope(arg0: *const ::pthread_attr_t, arg1: *mut ::c_int) -> ::c_int;
+    pub fn pthread_attr_setscope(arg0: *mut ::pthread_attr_t, arg1: ::c_int) -> ::c_int;
+    pub fn pthread_attr_getschedparam(
+        arg0: *const ::pthread_attr_t,
+        arg1: *mut ::sched_param,
+    ) -> ::c_int;
+    pub fn pthread_attr_setschedparam(
+        arg0: *mut ::pthread_attr_t,
+        arg1: *const ::sched_param,
+    ) -> ::c_int;
+    pub fn pthread_attr_getschedpolicy(
+        arg0: *const ::pthread_attr_t,
+        arg1: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_attr_setschedpolicy(arg0: *mut ::pthread_attr_t, arg1: ::c_int) -> ::c_int;
+    pub fn pthread_attr_getinheritsched(
+        arg0: *const ::pthread_attr_t,
+        arg1: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_attr_setinheritsched(arg0: *mut ::pthread_attr_t, arg1: ::c_int) -> ::c_int;
+    pub fn pthread_attr_getaffinity_np(
+        arg0: *const ::pthread_attr_t,
+        arg1: ::size_t,
+        arg2: *mut ::cpu_set_t,
+    ) -> ::c_int;
+    pub fn pthread_attr_setaffinity_np(
+        arg0: *mut ::pthread_attr_t,
+        arg1: ::size_t,
+        arg2: *const ::cpu_set_t,
+    ) -> ::c_int;
+    pub fn pthread_attr_getsigmask_np(
+        arg0: *const ::pthread_attr_t,
+        arg1: *mut ::sigset_t,
+    ) -> ::c_int;
+    pub fn pthread_attr_setsigmask_np(
+        arg0: *mut ::pthread_attr_t,
+        arg1: *const ::sigset_t,
+    ) -> ::c_int;
+    pub fn pthread_getaffinity_np(
+        thread: ::pthread_t,
+        cpusetsize: ::size_t,
+        cpuset: *mut ::cpu_set_t,
+    ) -> ::c_int;
+    pub fn pthread_setaffinity_np(
+        thread: ::pthread_t,
+        cpusetsize: ::size_t,
+        cpuset: *const ::cpu_set_t,
+    ) -> ::c_int;
+    pub fn pthread_create(
+        arg0: *mut ::pthread_t,
+        arg1: *const ::pthread_attr_t,
+        arg2: extern "C" fn(*mut ::c_void) -> *mut ::c_void,
+        arg3: *mut ::c_void,
+    ) -> ::c_int;
+    pub fn pthread_equal(arg0: ::pthread_t, arg1: ::pthread_t) -> ::c_int;
+    pub fn pthread_cleanup_push(
+        arg0: ::Option<unsafe extern "C" fn(*mut ::c_void) -> ::c_void>,
+        arg1: *mut ::c_void,
+    );
+    pub fn pthread_cleanup_pop(arg0: ::c_int);
+    pub fn pthread_setname_np(arg0: ::pthread_t, arg1: *const ::c_char) -> ::c_int;
+    pub fn pthread_getname_np(arg0: ::pthread_t, arg1: *mut ::c_char, arg2: ::size_t) -> ::c_int;
+    pub fn pthread_setschedparam(
+        arg0: ::pthread_t,
+        arg1: ::c_int,
+        arg2: *const ::sched_param,
+    ) -> ::c_int;
+    pub fn pthread_getschedparam(
+        arg0: ::pthread_t,
+        arg1: *mut ::c_int,
+        arg2: *mut ::sched_param,
+    ) -> ::c_int;
+    pub fn pthread_setcanceltype(arg0: ::c_int, arg1: *mut ::c_int) -> ::c_int;
+    pub fn pthread_setcancelstate(arg0: ::c_int, arg1: *mut ::c_int) -> ::c_int;
+    pub fn pthread_testcancel();
+    pub fn pthread_cancel(arg0: ::pthread_t) -> ::c_int;
+    pub fn pthread_atfork(
+        arg0: ::Option<unsafe extern "C" fn() -> ::c_void>,
+        arg1: ::Option<unsafe extern "C" fn() -> ::c_void>,
+        arg2: ::Option<unsafe extern "C" fn() -> ::c_void>,
+    ) -> ::c_int;
+    pub fn pthread_once(
+        arg0: *mut ::pthread_once_t,
+        arg1: ::Option<unsafe extern "C" fn() -> ::c_void>,
+    ) -> ::c_int;
+    pub fn pthread_mutexattr_gettype(
+        arg0: *const ::pthread_mutexattr_t,
+        arg1: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_mutexattr_getrobust(
+        arg0: *const ::pthread_mutexattr_t,
+        arg1: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_mutexattr_setrobust(arg0: *mut ::pthread_mutexattr_t, arg1: ::c_int) -> ::c_int;
+    pub fn pthread_mutexattr_getpshared(
+        arg0: *const ::pthread_mutexattr_t,
+        arg1: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_mutexattr_getprotocol(
+        arg0: *const ::pthread_mutexattr_t,
+        arg1: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_mutexattr_setprotocol(
+        arg0: *mut ::pthread_mutexattr_t,
+        arg1: ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_mutexattr_getprioceiling(
+        arg0: *const ::pthread_mutexattr_t,
+        arg1: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_mutexattr_setprioceiling(
+        arg0: *mut ::pthread_mutexattr_t,
+        arg1: ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_mutex_timedlock(
+        arg0: *mut ::pthread_mutex_t,
+        arg1: *const ::timespec,
+    ) -> ::c_int;
+    pub fn pthread_mutex_consistent(arg0: *mut ::pthread_mutex_t) -> ::c_int;
+    pub fn pthread_condattr_getpshared(
+        arg0: *const ::pthread_condattr_t,
+        arg1: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_barrierattr_init(arg0: *mut ::pthread_barrierattr_t) -> ::c_int;
+    pub fn pthread_barrierattr_destroy(arg0: *mut ::pthread_barrierattr_t) -> ::c_int;
+    pub fn pthread_barrierattr_setpshared(
+        arg0: *mut ::pthread_barrierattr_t,
+        arg1: ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_barrierattr_getpshared(
+        arg0: *const ::pthread_barrierattr_t,
+        arg1: *mut ::c_int,
+    ) -> ::c_int;
+    pub fn pthread_barrier_init(
+        arg0: *mut ::pthread_barrier_t,
+        arg1: *const ::pthread_barrierattr_t,
+        arg2: ::c_uint,
+    ) -> ::c_int;
+    pub fn pthread_barrier_destroy(arg0: *mut ::pthread_barrier_t) -> ::c_int;
+    pub fn pthread_barrier_wait(arg0: *mut ::pthread_barrier_t) -> ::c_int;
+    pub fn pthread_getcpuclockid(arg0: ::pthread_t, arg1: *mut ::clockid_t) -> ::c_int;
+}
+
+// pwd.h
+pub const NSS_BUFLEN_PASSWD: ::c_int = 512;
+s! {
+    pub struct passwd {
+        pub pw_name: *mut ::c_char,
+        pub pw_passwd: *mut ::c_char,
+        pub pw_uid: ::uid_t,
+        pub pw_gid: ::gid_t,
+        pub pw_gecos: *mut ::c_char,
+        pub pw_dir: *mut ::c_char,
+        pub pw_shell: *mut ::c_char,
+    }
+}
+extern "C" {
+    pub fn endpwent();
+    pub fn getpwent() -> *mut ::passwd;
+    pub fn getpwnam_r(
+        arg0: *const ::c_char,
+        arg1: *mut ::passwd,
+        arg2: *mut ::c_char,
+        arg3: ::size_t,
+        arg4: *mut *mut ::passwd,
+    ) -> ::c_int;
+    pub fn getpwuid_r(
+        arg0: ::uid_t,
+        arg1: *mut ::passwd,
+        arg2: *mut ::c_char,
+        arg3: ::size_t,
+        arg4: *mut *mut ::passwd,
+    ) -> ::c_int;
+    pub fn setpwent();
+    pub fn putpwent(arg0: *const ::passwd, arg1: *mut ::FILE) -> ::c_int;
+    pub fn fgetpwent(arg0: *mut ::FILE) -> *mut ::passwd;
+}
+
+// regex.h
+pub const REG_EXTENDED: ::c_int = 1;
+pub const REG_ICASE: ::c_int = 2;
+pub const REG_NEWLINE: ::c_int = 4;
+pub const REG_NOSUB: ::c_int = 8;
+pub const REG_NOTBOL: ::c_int = 1;
+pub const REG_NOTEOL: ::c_int = 2;
+pub const REG_OK: ::c_int = 0;
+pub const REG_NOMATCH: ::c_int = 1;
+pub const REG_BADPAT: ::c_int = 2;
+pub const REG_ECOLLATE: ::c_int = 3;
+pub const REG_ECTYPE: ::c_int = 4;
+pub const REG_EESCAPE: ::c_int = 5;
+pub const REG_ESUBREG: ::c_int = 6;
+pub const REG_EBRACK: ::c_int = 7;
+pub const REG_EPAREN: ::c_int = 8;
+pub const REG_EBRACE: ::c_int = 9;
+pub const REG_BADBR: ::c_int = 10;
+pub const REG_ERANGE: ::c_int = 11;
+pub const REG_ESPACE: ::c_int = 12;
+pub const REG_BADRPT: ::c_int = 13;
+pub const REG_ENOSYS: ::c_int = 1;
+pub type regoff_t = ::ptrdiff_t;
+s! {
+    pub struct re_pattern_buffer {
+        pub re_nsub: ::size_t,
+        pub __opaque: *mut ::c_void,
+        pub __padding: [*mut ::c_void; 4],
+        pub __nsub2: ::size_t,
+        pub __padding2: ::c_char,
+    }
+}
+pub type regex_t = ::re_pattern_buffer;
+s! {
+    pub struct regmatch_t {
+        pub rm_so: ::regoff_t,
+        pub rm_eo: ::regoff_t,
+    }
+}
+extern "C" {
+    pub fn regcomp(arg0: *mut ::regex_t, arg1: *const ::c_char, arg2: ::c_int) -> ::c_int;
+    pub fn regexec(
+        arg0: *const ::regex_t,
+        arg1: *const ::c_char,
+        arg2: ::size_t,
+        arg3: *mut ::regmatch_t,
+        arg4: ::c_int,
+    ) -> ::c_int;
+    pub fn regerror(
+        arg0: ::c_int,
+        arg1: *const ::regex_t,
+        arg2: *mut ::c_char,
+        arg3: ::size_t,
+    ) -> ::size_t;
+    pub fn regfree(arg0: *mut ::regex_t);
+}
+
+// sched.h
+
+// scsi/scsi_ioctl.h
+
+// semaphore.h
+pub const SEM_VALUE_MAX: ::c_int = 0x7FFFFFFF;
+s! {
+    pub struct sem_ {
+        pub __mlibc_count: ::c_uint,
+    }
+}
+pub type sem_t = ::sem_;
+extern "C" {
+    pub fn sem_open(arg0: *const ::c_char, arg1: ::c_int, ...) -> *mut ::sem_t;
+    pub fn sem_close(sem: *mut ::sem_t) -> ::c_int;
+    pub fn sem_unlink(arg0: *const ::c_char) -> ::c_int;
+    pub fn sem_timedwait(sem: *mut ::sem_t, abstime: *const ::timespec) -> ::c_int;
+    pub fn sem_getvalue(sem: *mut ::sem_t, sval: *mut ::c_int) -> ::c_int;
+}
+
+// shadow.h
+s! {
+    pub struct spwd {
+        pub sp_namp: *mut ::c_char,
+        pub sp_pwdp: *mut ::c_char,
+        pub sp_lstchg: i32,
+        pub sp_min: i32,
+        pub sp_max: i32,
+        pub sp_warn: i32,
+        pub sp_inact: i32,
+        pub sp_expire: i32,
+        pub sp_flag: u32,
+    }
+}
+extern "C" {
+    pub fn putspent(arg0: *const ::spwd, arg1: *mut ::FILE) -> ::c_int;
+    pub fn lckpwdf() -> ::c_int;
+    pub fn ulckpwdf() -> ::c_int;
+    pub fn getspnam(arg0: *const ::c_char) -> *mut ::spwd;
+    pub fn getspnam_r(
+        arg0: *const ::c_char,
+        arg1: *mut ::spwd,
+        arg2: *mut ::c_char,
+        arg3: ::size_t,
+        arg4: *mut *mut ::spwd,
+    ) -> ::c_int;
+    pub fn fgetspent(arg0: *mut ::FILE) -> *mut ::spwd;
+    pub fn endspent();
+}
+
+// signal.h
+
+// spawn.h
+pub const POSIX_SPAWN_RESETIDS: ::c_int = 1;
+pub const POSIX_SPAWN_SETPGROUP: ::c_int = 2;
+pub const POSIX_SPAWN_SETSIGDEF: ::c_int = 4;
+pub const POSIX_SPAWN_SETSIGMASK: ::c_int = 8;
+pub const POSIX_SPAWN_SETSCHEDPARAM: ::c_int = 16;
+pub const POSIX_SPAWN_SETSCHEDULER: ::c_int = 32;
+pub const POSIX_SPAWN_USEVFORK: ::c_int = 64;
+pub const POSIX_SPAWN_SETSID: ::c_int = 128;
+s! {
+    pub struct posix_spawnattr_t {
+        pub __flags: ::c_int,
+        pub __pgrp: ::pid_t,
+        pub __def: ::sigset_t,
+        pub __mask: ::sigset_t,
+        pub __prio: ::c_int,
+        pub __pol: ::c_int,
+        pub __fn: *mut ::c_void,
+        pub __pad: [::c_char; 56],
+    }
+}
+s! {
+    pub struct posix_spawn_file_actions_t {
+        pub __pad0: [::c_int; 2],
+        pub __actions: *mut ::c_void,
+        pub __pad: [::c_int; 16],
+    }
+}
+extern "C" {
+    pub fn posix_spawn(
+        pid: *mut ::pid_t,
+        path: *const ::c_char,
+        file_actions: *const ::posix_spawn_file_actions_t,
+        attrs: *const ::posix_spawnattr_t,
+        argv: *mut *mut ::c_char,
+        envp: *mut *mut ::c_char,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_init(attr: *mut ::posix_spawnattr_t) -> ::c_int;
+    pub fn posix_spawnattr_destroy(attr: *mut ::posix_spawnattr_t) -> ::c_int;
+    pub fn posix_spawnattr_setflags(attr: *mut ::posix_spawnattr_t, flags: ::c_short) -> ::c_int;
+    pub fn posix_spawnattr_setsigdefault(
+        attr: *mut ::posix_spawnattr_t,
+        sigdefault: *const ::sigset_t,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_setschedparam(
+        attr: *mut ::posix_spawnattr_t,
+        schedparam: *const ::sched_param,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_setschedpolicy(
+        attr: *mut ::posix_spawnattr_t,
+        schedpolicy: ::c_int,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_setsigmask(
+        attr: *mut ::posix_spawnattr_t,
+        sigmask: *const ::sigset_t,
+    ) -> ::c_int;
+    pub fn posix_spawnattr_setpgroup(attr: *mut ::posix_spawnattr_t, pgroup: ::pid_t) -> ::c_int;
+    pub fn posix_spawn_file_actions_init(
+        file_actions: *mut ::posix_spawn_file_actions_t,
+    ) -> ::c_int;
+    pub fn posix_spawn_file_actions_destroy(
+        file_actions: *mut ::posix_spawn_file_actions_t,
+    ) -> ::c_int;
+    pub fn posix_spawn_file_actions_adddup2(
+        file_actions: *mut ::posix_spawn_file_actions_t,
+        fildes: ::c_int,
+        newfildes: ::c_int,
+    ) -> ::c_int;
+    pub fn posix_spawn_file_actions_addclose(
+        file_actions: *mut ::posix_spawn_file_actions_t,
+        fildes: ::c_int,
+    ) -> ::c_int;
+    pub fn posix_spawn_file_actions_addopen(
+        file_actions: *mut ::posix_spawn_file_actions_t,
+        fildes: ::c_int,
+        path: *const ::c_char,
+        oflag: ::c_int,
+        mode: ::mode_t,
+    ) -> ::c_int;
+    pub fn posix_spawnp(
+        pid: *mut ::pid_t,
+        file: *const ::c_char,
+        file_actions: *const ::posix_spawn_file_actions_t,
+        attrp: *const ::posix_spawnattr_t,
+        argv: *mut *mut ::c_char,
+        envp: *mut *mut ::c_char,
+    ) -> ::c_int;
+}
+
+// stdc-predef.h
+
+// stdio.h
+
+// stdio_ext.h
+pub const FSETLOCKING_INTERNAL: ::c_int = 1;
+pub const FSETLOCKING_BYCALLER: ::c_int = 2;
+pub const FSETLOCKING_QUERY: ::c_int = 3;
+extern "C" {
+    pub fn _flushlbf();
+}
+
+// stdlib.h
+
+// string.h
+
+// sys/auxv.h
+pub const AT_NULL: ::c_int = 0;
+extern "C" {
+    pub fn peekauxval(r#type: ::c_ulong, value: *mut ::c_ulong) -> ::c_int;
+    pub fn getauxval(r#type: ::c_ulong) -> ::c_ulong;
+}
+
+// sys/endian.h
+
+// sys/epoll.h
+pub const EPOLL_NONBLOCK: ::c_int = O_NONBLOCK;
+extern "C" {
+    pub fn epoll_create(arg0: ::c_int) -> ::c_int;
+    pub fn epoll_create1(arg0: ::c_int) -> ::c_int;
+    pub fn epoll_ctl(
+        arg0: ::c_int,
+        arg1: ::c_int,
+        arg2: ::c_int,
+        arg3: *mut ::epoll_event,
+    ) -> ::c_int;
+    pub fn epoll_wait(
+        arg0: ::c_int,
+        arg1: *mut ::epoll_event,
+        arg2: ::c_int,
+        arg3: ::c_int,
+    ) -> ::c_int;
+    pub fn epoll_pwait(
+        arg0: ::c_int,
+        arg1: *mut ::epoll_event,
+        arg2: ::c_int,
+        arg3: ::c_int,
+        arg4: *const ::sigset_t,
+    ) -> ::c_int;
+}
+
+// sys/errno.h
+
+// sys/eventfd.h
+pub const EFD_SEMAPHORE: ::c_int = 1;
+pub const EFD_CLOEXEC: ::c_int = O_CLOEXEC;
+pub const EFD_NONBLOCK: ::c_int = O_NONBLOCK;
+pub type eventfd_t = u64;
+extern "C" {
+    pub fn eventfd(arg0: ::c_uint, arg1: ::c_int) -> ::c_int;
+    pub fn eventfd_read(arg0: ::c_int, arg1: *mut ::eventfd_t) -> ::c_int;
+    pub fn eventfd_write(arg0: ::c_int, arg1: ::eventfd_t) -> ::c_int;
+}
+
+// sys/file.h
+
+// sys/fsuid.h
+extern "C" {
+    pub fn setfsuid(uid: ::uid_t) -> ::c_int;
+    pub fn setfsgid(gid: ::gid_t) -> ::c_int;
+}
+
+// sys/inotify.h
+pub const IN_ACCESS: ::c_int = 0x1;
+pub const IN_ATTRIB: ::c_int = 0x4;
+pub const IN_CLOSE_WRITE: ::c_int = 0x8;
+pub const IN_CLOSE_NOWRITE: ::c_int = 0x10;
+pub const IN_CREATE: ::c_int = 0x100;
+pub const IN_DELETE: ::c_int = 0x200;
+pub const IN_DELETE_SELF: ::c_int = 0x400;
+pub const IN_MODIFY: ::c_int = 0x2;
+pub const IN_MOVE_SELF: ::c_int = 0x800;
+pub const IN_MOVED_FROM: ::c_int = 0x40;
+pub const IN_MOVED_TO: ::c_int = 0x80;
+pub const IN_OPEN: ::c_int = 0x20;
+pub const IN_MOVE: ::c_int = IN_MOVED_FROM | IN_MOVED_TO;
+pub const IN_CLOSE: ::c_int = IN_CLOSE_WRITE | IN_CLOSE_NOWRITE;
+pub const IN_DONT_FOLLOW: ::c_int = 0x2000000;
+pub const IN_EXCL_UNLINK: ::c_int = 0x4000000;
+pub const IN_MASK_ADD: ::c_int = 0x20000000;
+pub const IN_ONESHOT: ::c_int = 0x80000000;
+pub const IN_ONLYDIR: ::c_int = 0x1000000;
+pub const IN_IGNORED: ::c_int = 0x8000;
+pub const IN_ISDIR: ::c_int = 0x40000000;
+pub const IN_Q_OVERFLOW: ::c_int = 0x4000;
+pub const IN_UNMOUNT: ::c_int = 0x2000;
+pub const IN_ALL_EVENTS: ::c_int = IN_ACCESS
+    | IN_MODIFY
+    | IN_ATTRIB
+    | IN_CLOSE_WRITE
+    | IN_CLOSE_NOWRITE
+    | IN_OPEN
+    | IN_MOVED_FROM
+    | IN_MOVED_TO
+    | IN_DELETE
+    | IN_CREATE
+    | IN_DELETE_SELF
+    | IN_MOVE_SELF;
+s! {
+    pub struct inotify_event {
+        pub wd: ::c_int,
+        pub mask: ::c_uint,
+        pub cookie: ::c_uint,
+        pub len: ::c_uint,
+        pub name: *mut ::c_char,
+    }
+}
+extern "C" {
+    pub fn inotify_init() -> ::c_int;
+    pub fn inotify_init1(arg0: ::c_int) -> ::c_int;
+    pub fn inotify_add_watch(arg0: ::c_int, arg1: *const ::c_char, arg2: u32) -> ::c_int;
+    pub fn inotify_rm_watch(arg0: ::c_int, arg1: ::c_int) -> ::c_int;
+}
+
+// sys/io.h
+extern "C" {
+    pub fn ioperm(from: ::c_ulong, num: ::c_ulong, turn_on: ::c_int) -> ::c_int;
+    pub fn iopl(level: ::c_int) -> ::c_int;
+    pub fn inb(port: ::c_ushort) -> ::c_uchar;
+    pub fn inb_p(port: ::c_ushort) -> ::c_uchar;
+    pub fn inw(port: ::c_ushort) -> ::c_ushort;
+    pub fn inw_p(port: ::c_ushort) -> ::c_ushort;
+    pub fn inl(port: ::c_ushort) -> ::c_uint;
+    pub fn inl_p(port: ::c_ushort) -> ::c_uint;
+    pub fn outb(value: ::c_uchar, port: ::c_ushort);
+    pub fn outb_p(value: ::c_uchar, port: ::c_ushort);
+    pub fn outw(value: ::c_ushort, port: ::c_ushort);
+    pub fn outw_p(value: ::c_ushort, port: ::c_ushort);
+    pub fn outl(value: ::c_uint, port: ::c_ushort);
+    pub fn outl_p(value: ::c_uint, port: ::c_ushort);
+    pub fn insb(port: ::c_ushort, addr: *mut ::c_void, count: ::c_ulong);
+    pub fn insw(port: ::c_ushort, addr: *mut ::c_void, count: ::c_ulong);
+    pub fn insl(port: ::c_ushort, addr: *mut ::c_void, count: ::c_ulong);
+    pub fn outsb(port: ::c_ushort, addr: *const ::c_void, count: ::c_ulong);
+    pub fn outsw(port: ::c_ushort, addr: *const ::c_void, count: ::c_ulong);
+    pub fn outsl(port: ::c_ushort, addr: *const ::c_void, count: ::c_ulong);
+}
+
+// sys/ioctl.h
+pub const FIONREAD: ::c_ulong = 0x541B;
+pub const FIONBIO: ::c_ulong = 0x5421;
+pub const FIONCLEX: ::c_ulong = 0x5450;
+pub const FIOCLEX: ::c_ulong = 0x5451;
+pub const SIOCGIFMTU: ::c_ulong = 0x8921;
+pub const SIOCSIFMTU: ::c_ulong = 0x8922;
+pub const SIOCDEVPRIVATE: ::c_ulong = 0x89F0;
+extern "C" {
+    pub fn ioctl(fd: ::c_int, request: ::c_ulong, ...) -> ::c_int;
+}
+
+// sys/ipc.h
+
+// sys/kd.h
+
+// sys/klog.h
+extern "C" {
+    pub fn klogctl(r#type: ::c_int, bufp: *mut ::c_char, len: ::c_int) -> ::c_int;
+}
+
+// sys/mman.h
+extern "C" {
+    pub fn mmap64(
+        arg0: *mut ::c_void,
+        arg1: ::size_t,
+        arg2: ::c_int,
+        arg3: ::c_int,
+        arg4: ::c_int,
+        arg5: ::off_t,
+    ) -> *mut ::c_void;
+    pub fn mprotect(arg0: *mut ::c_void, arg1: ::size_t, arg2: ::c_int) -> ::c_int;
+    pub fn posix_madvise(arg0: *mut ::c_void, arg1: ::size_t, arg2: ::c_int) -> ::c_int;
+    pub fn msync(arg0: *mut ::c_void, arg1: ::size_t, arg2: ::c_int) -> ::c_int;
+    pub fn shm_open(arg0: *const ::c_char, arg1: ::c_int, arg2: ::mode_t) -> ::c_int;
+    pub fn shm_unlink(arg0: *const ::c_char) -> ::c_int;
+    pub fn mremap(
+        arg0: *mut ::c_void,
+        arg1: ::size_t,
+        arg2: ::size_t,
+        arg3: ::c_int,
+        ...
+    ) -> *mut ::c_void;
+    pub fn remap_file_pages(
+        arg0: *mut ::c_void,
+        arg1: ::size_t,
+        arg2: ::c_int,
+        arg3: ::size_t,
+        arg4: ::c_int,
+    ) -> ::c_int;
+    pub fn memfd_create(arg0: *const ::c_char, arg1: ::c_uint) -> ::c_int;
+    pub fn madvise(arg0: *mut ::c_void, arg1: ::size_t, arg2: ::c_int) -> ::c_int;
+}
+
+// sys/msg.h
+extern "C" {
+    pub fn msgget(arg0: ::key_t, arg1: ::c_int) -> ::c_int;
+    pub fn msgctl(msqid: ::c_int, cmd: ::c_int, buf: *mut ::msqid64_ds) -> ::c_int;
+    pub fn msgrcv(
+        arg0: ::c_int,
+        arg1: *mut ::c_void,
+        arg2: ::size_t,
+        arg3: ::c_long,
+        arg4: ::c_int,
+    ) -> ::ssize_t;
+    pub fn msgsnd(arg0: ::c_int, arg1: *const ::c_void, arg2: ::size_t, arg3: ::c_int) -> ::c_int;
+}
+
+// sys/param.h
+pub const NBBY: ::c_int = CHAR_BIT;
+pub const NGROUPS: ::c_int = NGROUPS_MAX;
+pub const MAXNAMLEN: ::c_int = 255;
+pub const MAXPATHLEN: ::c_int = 4096;
+pub const HOST_NAME_MAX: ::c_int = 64;
+pub const MAXSYMLINKS: ::c_int = 20;
+pub const MAXHOSTNAMELEN: ::c_int = HOST_NAME_MAX;
+
+// sys/personality.h
+extern "C" {
+    pub fn personality(persona: ::c_ulong) -> ::c_int;
+}
+
+// sys/poll.h
+
+// sys/prctl.h
+pub const PR_SET_PDEATHSIG: ::c_int = 1;
+pub const PR_GET_PDEATHSIG: ::c_int = 2;
+pub const PR_GET_DUMPABLE: ::c_int = 3;
+pub const PR_SET_DUMPABLE: ::c_int = 4;
+pub const PR_GET_UNALIGN: ::c_int = 5;
+pub const PR_SET_UNALIGN: ::c_int = 6;
+pub const PR_UNALIGN_NOPRINT: ::c_int = 1;
+pub const PR_UNALIGN_SIGBUS: ::c_int = 2;
+pub const PR_GET_KEEPCAPS: ::c_int = 7;
+pub const PR_SET_KEEPCAPS: ::c_int = 8;
+pub const PR_GET_FPEMU: ::c_int = 9;
+pub const PR_SET_FPEMU: ::c_int = 10;
+pub const PR_FPEMU_NOPRINT: ::c_int = 1;
+pub const PR_FPEMU_SIGFPE: ::c_int = 2;
+pub const PR_GET_FPEXC: ::c_int = 11;
+pub const PR_SET_FPEXC: ::c_int = 12;
+pub const PR_FP_EXC_SW_ENABLE: ::c_int = 0x80;
+pub const PR_FP_EXC_DIV: ::c_int = 0x010000;
+pub const PR_FP_EXC_OVF: ::c_int = 0x020000;
+pub const PR_FP_EXC_UND: ::c_int = 0x040000;
+pub const PR_FP_EXC_RES: ::c_int = 0x080000;
+pub const PR_FP_EXC_INV: ::c_int = 0x100000;
+pub const PR_FP_EXC_DISABLED: ::c_int = 0;
+pub const PR_FP_EXC_NONRECOV: ::c_int = 1;
+pub const PR_FP_EXC_ASYNC: ::c_int = 2;
+pub const PR_FP_EXC_PRECISE: ::c_int = 3;
+pub const PR_GET_TIMING: ::c_int = 13;
+pub const PR_SET_TIMING: ::c_int = 14;
+pub const PR_TIMING_STATISTICAL: ::c_int = 0;
+pub const PR_TIMING_TIMESTAMP: ::c_int = 1;
+pub const PR_SET_NAME: ::c_int = 15;
+pub const PR_GET_NAME: ::c_int = 16;
+pub const PR_GET_ENDIAN: ::c_int = 19;
+pub const PR_SET_ENDIAN: ::c_int = 20;
+pub const PR_ENDIAN_BIG: ::c_int = 0;
+pub const PR_ENDIAN_LITTLE: ::c_int = 1;
+pub const PR_ENDIAN_PPC_LITTLE: ::c_int = 2;
+pub const PR_GET_SECCOMP: ::c_int = 21;
+pub const PR_SET_SECCOMP: ::c_int = 22;
+pub const PR_CAPBSET_READ: ::c_int = 23;
+pub const PR_CAPBSET_DROP: ::c_int = 24;
+pub const PR_GET_TSC: ::c_int = 25;
+pub const PR_SET_TSC: ::c_int = 26;
+pub const PR_TSC_ENABLE: ::c_int = 1;
+pub const PR_TSC_SIGSEGV: ::c_int = 2;
+pub const PR_GET_SECUREBITS: ::c_int = 27;
+pub const PR_SET_SECUREBITS: ::c_int = 28;
+pub const PR_SET_TIMERSLACK: ::c_int = 29;
+pub const PR_GET_TIMERSLACK: ::c_int = 30;
+pub const PR_TASK_PERF_EVENTS_DISABLE: ::c_int = 31;
+pub const PR_TASK_PERF_EVENTS_ENABLE: ::c_int = 32;
+pub const PR_MCE_KILL: ::c_int = 33;
+pub const PR_MCE_KILL_CLEAR: ::c_int = 0;
+pub const PR_MCE_KILL_SET: ::c_int = 1;
+pub const PR_MCE_KILL_LATE: ::c_int = 0;
+pub const PR_MCE_KILL_EARLY: ::c_int = 1;
+pub const PR_MCE_KILL_DEFAULT: ::c_int = 2;
+pub const PR_MCE_KILL_GET: ::c_int = 34;
+pub const PR_SET_MM: ::c_int = 35;
+pub const PR_SET_MM_START_CODE: ::c_int = 1;
+pub const PR_SET_MM_END_CODE: ::c_int = 2;
+pub const PR_SET_MM_START_DATA: ::c_int = 3;
+pub const PR_SET_MM_END_DATA: ::c_int = 4;
+pub const PR_SET_MM_START_STACK: ::c_int = 5;
+pub const PR_SET_MM_START_BRK: ::c_int = 6;
+pub const PR_SET_MM_BRK: ::c_int = 7;
+pub const PR_SET_MM_ARG_START: ::c_int = 8;
+pub const PR_SET_MM_ARG_END: ::c_int = 9;
+pub const PR_SET_MM_ENV_START: ::c_int = 10;
+pub const PR_SET_MM_ENV_END: ::c_int = 11;
+pub const PR_SET_MM_AUXV: ::c_int = 12;
+pub const PR_SET_MM_EXE_FILE: ::c_int = 13;
+pub const PR_SET_MM_MAP: ::c_int = 14;
+pub const PR_SET_MM_MAP_SIZE: ::c_int = 15;
+pub const PR_SET_CHILD_SUBREAPER: ::c_int = 36;
+pub const PR_GET_CHILD_SUBREAPER: ::c_int = 37;
+pub const PR_SET_NO_NEW_PRIVS: ::c_int = 38;
+pub const PR_GET_NO_NEW_PRIVS: ::c_int = 39;
+pub const PR_GET_TID_ADDRESS: ::c_int = 40;
+pub const PR_SET_THP_DISABLE: ::c_int = 41;
+pub const PR_GET_THP_DISABLE: ::c_int = 42;
+pub const PR_MPX_ENABLE_MANAGEMENT: ::c_int = 43;
+pub const PR_MPX_DISABLE_MANAGEMENT: ::c_int = 44;
+pub const PR_SET_FP_MODE: ::c_int = 45;
+pub const PR_GET_FP_MODE: ::c_int = 46;
+pub const PR_FP_MODE_FR: ::c_int = 1 << 0;
+pub const PR_FP_MODE_FRE: ::c_int = 1 << 1;
+pub const PR_CAP_AMBIENT: ::c_int = 47;
+pub const PR_CAP_AMBIENT_IS_SET: ::c_int = 1;
+pub const PR_CAP_AMBIENT_RAISE: ::c_int = 2;
+pub const PR_CAP_AMBIENT_LOWER: ::c_int = 3;
+pub const PR_CAP_AMBIENT_CLEAR_ALL: ::c_int = 4;
+extern "C" {
+    pub fn prctl(arg0: ::c_int, ...) -> ::c_int;
+}
+
+// sys/ptrace.h
+pub const PTRACE_TRACEME: ::c_int = 0;
+pub const PT_TRACE_ME: ::c_int = PTRACE_TRACEME;
+pub const PT_READ_I: ::c_int = PTRACE_PEEKTEXT;
+pub const PT_READ_D: ::c_int = PTRACE_PEEKDATA;
+pub const PT_READ_U: ::c_int = PTRACE_PEEKUSER;
+pub const PT_WRITE_I: ::c_int = PTRACE_POKETEXT;
+pub const PT_WRITE_D: ::c_int = PTRACE_POKEDATA;
+pub const PT_WRITE_U: ::c_int = PTRACE_POKEUSER;
+pub const PT_CONTINUE: ::c_int = PTRACE_CONT;
+pub const PT_KILL: ::c_int = PTRACE_KILL;
+pub const PT_STEP: ::c_int = PTRACE_SINGLESTEP;
+pub const PT_GETREGS: ::c_int = PTRACE_GETREGS;
+pub const PT_SETREGS: ::c_int = PTRACE_SETREGS;
+pub const PT_GETFPREGS: ::c_int = PTRACE_GETFPREGS;
+pub const PT_SETFPREGS: ::c_int = PTRACE_SETFPREGS;
+pub const PT_ATTACH: ::c_int = PTRACE_ATTACH;
+pub const PT_DETACH: ::c_int = PTRACE_DETACH;
+pub const PT_GETFPXREGS: ::c_int = PTRACE_GETFPXREGS;
+pub const PT_SETFPXREGS: ::c_int = PTRACE_SETFPXREGS;
+pub const PT_SYSCALL: ::c_int = PTRACE_SYSCALL;
+pub const PT_SETOPTIONS: ::c_int = PTRACE_SETOPTIONS;
+pub const PT_GETEVENTMSG: ::c_int = PTRACE_GETEVENTMSG;
+pub const PT_GETSIGINFO: ::c_int = PTRACE_GETSIGINFO;
+pub const PT_SETSIGINFO: ::c_int = PTRACE_SETSIGINFO;
+s! {
+    pub struct ptrace_peeksiginfo_args {
+        pub offset: u64,
+        pub flags: u32,
+        pub nr: i32,
+    }
+}
+extern "C" {
+    pub fn ptrace(arg0: ::c_int, ...) -> ::c_long;
+}
+
+// sys/quota.h
+extern "C" {
+    pub fn quotactl(
+        cmd: ::c_int,
+        special: *const ::c_char,
+        id: ::c_int,
+        addr: ::caddr_t,
+    ) -> ::c_int;
+}
+
+// sys/random.h
+pub const GRND_RANDOM: ::c_int = 1;
+pub const GRND_NONBLOCK: ::c_int = 2;
+extern "C" {
+    pub fn getrandom(arg0: *mut ::c_void, arg1: ::size_t, arg2: ::c_uint) -> ::ssize_t;
+}
+
+// sys/reboot.h
+extern "C" {
+    pub fn reboot(arg: ::c_int) -> ::c_int;
+}
+
+// sys/reg.h
+pub const R15: ::c_int = 0;
+pub const R14: ::c_int = 1;
+pub const R13: ::c_int = 2;
+pub const R12: ::c_int = 3;
+pub const RBP: ::c_int = 4;
+pub const RBX: ::c_int = 5;
+pub const R11: ::c_int = 6;
+pub const R10: ::c_int = 7;
+pub const R9: ::c_int = 8;
+pub const R8: ::c_int = 9;
+pub const RAX: ::c_int = 10;
+pub const RCX: ::c_int = 11;
+pub const RDX: ::c_int = 12;
+pub const RSI: ::c_int = 13;
+pub const RDI: ::c_int = 14;
+pub const ORIG_RAX: ::c_int = 15;
+pub const RIP: ::c_int = 16;
+pub const CS: ::c_int = 17;
+pub const EFLAGS: ::c_int = 18;
+pub const RSP: ::c_int = 19;
+pub const SS: ::c_int = 20;
+pub const FS_BASE: ::c_int = 21;
+pub const GS_BASE: ::c_int = 22;
+pub const DS: ::c_int = 23;
+pub const ES: ::c_int = 24;
+pub const FS: ::c_int = 25;
+pub const GS: ::c_int = 26;
+
+// sys/resource.h
+pub const PRIO_PROCESS: ::c_int = 1;
+pub const PRIO_PGRP: ::c_int = 2;
+pub const PRIO_USER: ::c_int = 3;
+pub const RLIM_NLIMITS: ::c_int = RLIMIT_NLIMITS;
+pub type rlim_t = ::c_ulonglong;
+s! {
+    pub struct rlimit {
+        pub rlim_cur: ::rlim_t,
+        pub rlim_max: ::rlim_t,
+    }
+}
+extern "C" {
+    pub fn getpriority(arg0: ::c_int, arg1: ::id_t) -> ::c_int;
+    pub fn setpriority(arg0: ::c_int, arg1: ::id_t, arg2: ::c_int) -> ::c_int;
+    pub fn getrlimit(arg0: ::c_int, arg1: *mut ::rlimit) -> ::c_int;
+    pub fn setrlimit(arg0: ::c_int, arg1: *const ::rlimit) -> ::c_int;
+    pub fn prlimit(
+        pid: ::pid_t,
+        resource: ::c_int,
+        new_limits: *const ::rlimit,
+        old_limits: *mut ::rlimit,
+    ) -> ::c_int;
+}
+
+// sys/select.h
+
+// sys/sem.h
+pub const GETALL: ::c_int = 13;
+pub const SETVAL: ::c_int = 16;
+pub const SETALL: ::c_int = 17;
+pub const SEM_UNDO: ::c_int = 0x1000;
+s! {
+    pub struct sembuf {
+        pub sem_num: ::c_ushort,
+        pub sem_op: ::c_short,
+        pub sem_flg: ::c_short,
+    }
+    pub struct semid_ds {
+        pub sem_perm: ::ipc64_perm,
+        pub sem_otime: ::time_t,
+        pub sem_ctime: ::time_t,
+        pub sem_nsems: ::c_ulong,
+    }
+}
+extern "C" {
+    pub fn semget(arg0: ::key_t, arg1: ::c_int, arg2: ::c_int) -> ::c_int;
+    pub fn semop(arg0: ::c_int, arg1: *mut ::sembuf, arg2: ::size_t) -> ::c_int;
+    pub fn semctl(arg0: ::c_int, arg1: ::c_int, arg2: ::c_int, ...) -> ::c_int;
+}
+
+// sys/sendfile.h
+extern "C" {
+    pub fn sendfile(arg0: ::c_int, arg1: ::c_int, arg2: *mut ::off_t, arg3: ::size_t) -> ::ssize_t;
+}
+
+// sys/shm.h
+pub const SHM_R: ::c_int = 0o400;
+pub const SHM_W: ::c_int = 0o200;
+pub const SHM_RDONLY: ::c_int = 0o10000;
+pub const SHM_RND: ::c_int = 0o20000;
+pub const SHM_REMAP: ::c_int = 0o40000;
+pub const SHM_EXEC: ::c_int = 0o100000;
+pub const SHM_LOCK: ::c_int = 11;
+pub const SHM_UNLOCK: ::c_int = 12;
+pub const SHM_STAT: ::c_int = 13;
+pub const SHM_INFO: ::c_int = 14;
+pub const SHM_STAT_ANY: ::c_int = 15;
+pub const SHM_DEST: ::c_int = 0o1000;
+pub const SHM_LOCKED: ::c_int = 0o2000;
+pub const SHM_HUGETLB: ::c_int = 0o4000;
+pub const SHM_NORESERVE: ::c_int = 0o10000;
+pub const SHM_HUGE_SHIFT: ::c_int = 26;
+pub const SHM_HUGE_MASK: ::c_int = 0x3f;
+pub const SHM_HUGE_64KB: ::c_int = 16 << 26;
+pub const SHM_HUGE_512KB: ::c_int = 19 << 26;
+pub const SHM_HUGE_1MB: ::c_int = 20 << 26;
+pub const SHM_HUGE_2MB: ::c_int = 21 << 26;
+pub const SHM_HUGE_8MB: ::c_int = 23 << 26;
+pub const SHM_HUGE_16MB: ::c_int = 24 << 26;
+pub const SHM_HUGE_32MB: ::c_int = 25 << 26;
+pub const SHM_HUGE_256MB: ::c_int = 28 << 26;
+pub const SHM_HUGE_512MB: ::c_int = 29 << 26;
+pub const SHM_HUGE_1GB: ::c_int = 30 << 26;
+pub const SHM_HUGE_2GB: ::c_int = 31 << 26;
+pub const SHM_HUGE_16GB: ::c_uint = 34 << 26;
+pub type shmatt_t = ::c_ulong;
+s! {
+    pub struct shmid_ds {
+        pub shm_perm: ::ipc64_perm,
+        pub shm_segsz: ::size_t,
+        pub shm_atime: ::time_t,
+        pub shm_dtime: ::time_t,
+        pub shm_ctime: ::time_t,
+        pub shm_cpid: ::pid_t,
+        pub shm_lpid: ::pid_t,
+        pub shm_nattch: ::c_ulong,
+    }
+    pub struct shminfo {
+        pub shmmax: ::c_ulong,
+        pub shmmin: ::c_ulong,
+        pub shmmni: ::c_ulong,
+        pub shmseg: ::c_ulong,
+        pub shmall: ::c_ulong,
+        pub __unused: [::c_ulong; 4],
+    }
+}
+extern "C" {
+    pub fn shmat(arg0: ::c_int, arg1: *const ::c_void, arg2: ::c_int) -> *mut ::c_void;
+    pub fn shmctl(arg0: ::c_int, arg1: ::c_int, arg2: *mut ::shmid_ds) -> ::c_int;
+    pub fn shmdt(arg0: *const ::c_void) -> ::c_int;
+    pub fn shmget(arg0: ::key_t, arg1: ::size_t, arg2: ::c_int) -> ::c_int;
+}
+
+// sys/signal.h
+
+// sys/signalfd.h
+pub const SFD_CLOEXEC: ::c_int = O_CLOEXEC;
+pub const SFD_NONBLOCK: ::c_int = O_NONBLOCK;
+s! {
+    pub struct signalfd_siginfo {
+        pub ssi_signo: u32,
+        pub ssi_errno: i32,
+        pub ssi_code: i32,
+        pub ssi_pid: u32,
+        pub ssi_uid: u32,
+        pub ssi_fd: i32,
+        pub ssi_tid: u32,
+        pub ssi_band: u32,
+        pub ssi_overrun: u32,
+        pub ssi_trapno: u32,
+        pub ssi_status: i32,
+        pub ssi_int: i32,
+        pub ssi_ptr: u64,
+        pub ssi_utime: u64,
+        pub ssi_stime: u64,
+        pub ssi_addr: u64,
+        pub ssi_addr_lsb: u16,
+        pub pad: [u8; 46],
+    }
+}
+extern "C" {
+    pub fn signalfd(arg0: ::c_int, arg1: *const ::sigset_t, arg2: ::c_int) -> ::c_int;
+}
+
+// sys/socket.h
+
+// sys/stat.h
+extern "C" {
+    pub fn fstat64(fd: ::c_int, result: *mut ::stat) -> ::c_int;
+    pub fn lstat64(arg0: *const ::c_char, arg1: *mut ::stat) -> ::c_int;
+    pub fn mkfifoat(arg0: ::c_int, arg1: *const ::c_char, arg2: ::mode_t) -> ::c_int;
+}
+
+// sys/statfs.h
+
+// sys/statvfs.h
+extern "C" {
+    pub fn statvfs64(arg0: *const ::c_char, arg1: *mut ::statvfs) -> ::c_int;
+}
+
+// sys/swap.h
+extern "C" {
+    pub fn swapon(arg0: *const ::c_char, arg1: ::c_int) -> ::c_int;
+    pub fn swapoff(arg0: *const ::c_char) -> ::c_int;
+}
+
+// sys/sysinfo.h
+s! {
+    pub struct sysinfo {
+        pub uptime: ::c_long,
+        pub loads: [::c_ulong; 3],
+        pub totalram: ::c_ulong,
+        pub freeram: ::c_ulong,
+        pub sharedram: ::c_ulong,
+        pub bufferram: ::c_ulong,
+        pub totalswap: ::c_ulong,
+        pub freeswap: ::c_ulong,
+        pub procs: ::c_ushort,
+        pub totalhigh: ::c_ulong,
+        pub freehigh: ::c_ulong,
+        pub mem_unit: ::c_uint,
+        pub _f: [::c_char; 0],
+    }
+}
+extern "C" {
+    pub fn sysinfo(arg0: *mut ::sysinfo) -> ::c_int;
+}
+
+// sys/syslog.h
+
+// sys/sysmacros.h
+
+// sys/termios.h
+pub const B0: ::speed_t = 0;
+pub const B50: ::speed_t = 1;
+pub const B75: ::speed_t = 2;
+pub const B110: ::speed_t = 3;
+pub const B134: ::speed_t = 4;
+pub const B150: ::speed_t = 5;
+pub const B200: ::speed_t = 6;
+pub const B300: ::speed_t = 7;
+pub const B600: ::speed_t = 8;
+pub const B1200: ::speed_t = 9;
+pub const B1800: ::speed_t = 10;
+pub const B2400: ::speed_t = 11;
+pub const B4800: ::speed_t = 12;
+pub const B9600: ::speed_t = 13;
+pub const B19200: ::speed_t = 14;
+pub const B38400: ::speed_t = 15;
+pub const B57600: ::speed_t = 0o010001;
+pub const B115200: ::speed_t = 0o010002;
+pub const B230400: ::speed_t = 0o010003;
+pub const B460800: ::speed_t = 0o010004;
+pub const B500000: ::speed_t = 0o010005;
+pub const B576000: ::speed_t = 0o010006;
+pub const B921600: ::speed_t = 0o010007;
+pub const B1000000: ::speed_t = 0o010010;
+pub const B1152000: ::speed_t = 0o010011;
+pub const B1500000: ::speed_t = 0o010012;
+pub const B2000000: ::speed_t = 0o010013;
+pub const B2500000: ::speed_t = 0o010014;
+pub const B3000000: ::speed_t = 0o010015;
+pub const B3500000: ::speed_t = 0o010016;
+pub const B4000000: ::speed_t = 0o010017;
+pub const TCSANOW: ::c_int = 0;
+pub const TCSADRAIN: ::c_int = 1;
+pub const TCSAFLUSH: ::c_int = 2;
+pub const TIOCM_DTR: ::c_int = 0x002;
+pub const TIOCM_RTS: ::c_int = 0x004;
+pub const TIOCSCTTY: ::c_ulong = 0x540E;
+pub const TIOCGPGRP: ::c_int = 0x540F;
+pub const TIOCSPGRP: ::c_int = 0x5410;
+pub const TIOCGWINSZ: ::c_ulong = 0x5413;
+pub const TIOCSWINSZ: ::c_ulong = 0x5414;
+pub const TIOCGSID: ::c_int = 0x5429;
+
+// sys/time.h
+s! {
+    pub struct timezone {
+        pub tz_minuteswest: ::c_int,
+        pub tz_dsttime: ::c_int,
+    }
+}
+extern "C" {
+    pub fn gettimeofday(result: *mut ::timeval, unused: *mut ::c_void) -> ::c_int;
+    pub fn settimeofday(result: *const ::timeval, zone: *const ::timezone) -> ::c_int;
+    pub fn timeradd(a: *const ::timeval, b: *const ::timeval, res: *mut ::timeval);
+    pub fn timersub(a: *const ::timeval, b: *const ::timeval, res: *mut ::timeval);
+    pub fn timerclear(tvp: *mut ::timeval);
+    pub fn timerisset(tvp: *mut ::timeval) -> ::c_int;
+    pub fn getitimer(which: ::c_int, curr_value: *mut ::itimerval) -> ::c_int;
+    pub fn setitimer(
+        which: ::c_int,
+        new_value: *const ::itimerval,
+        old_value: *mut ::itimerval,
+    ) -> ::c_int;
+    pub fn timer_create(
+        clockid: ::clockid_t,
+        sevp: *mut ::sigevent,
+        timerid: *mut ::timer_t,
+    ) -> ::c_int;
+    pub fn timer_settime(
+        timerid: ::timer_t,
+        flags: ::c_int,
+        new_value: *const ::itimerspec,
+        old_value: *mut ::itimerspec,
+    ) -> ::c_int;
+    pub fn timer_gettime(timerid: ::timer_t, curr_value: *mut ::itimerspec) -> ::c_int;
+    pub fn timer_delete(timerid: ::timer_t) -> ::c_int;
+}
+
+// sys/timeb.h
+
+// sys/timerfd.h
+pub const TFD_NONBLOCK: ::c_int = O_NONBLOCK;
+pub const TFD_CLOEXEC: ::c_int = O_CLOEXEC;
+pub const TFD_TIMER_ABSTIME: ::c_int = 1;
+pub const TFD_TIMER_CANCEL_ON_SET: ::c_int = 1 << 1;
+extern "C" {
+    pub fn timerfd_create(arg0: ::c_int, arg1: ::c_int) -> ::c_int;
+    pub fn timerfd_settime(
+        arg0: ::c_int,
+        arg1: ::c_int,
+        arg2: *const ::itimerspec,
+        arg3: *mut ::itimerspec,
+    ) -> ::c_int;
+    pub fn timerfd_gettime(arg0: ::c_int, arg1: *mut ::itimerspec) -> ::c_int;
+}
+
+// sys/times.h
+s! {
+    pub struct tms {
+        pub tms_utime: ::clock_t,
+        pub tms_stime: ::clock_t,
+        pub tms_cutime: ::clock_t,
+        pub tms_cstime: ::clock_t,
+    }
+}
+
+// sys/timex.h
+pub const ADJ_OFFSET: ::c_int = 0x0001;
+pub const ADJ_FREQUENCY: ::c_int = 0x0002;
+pub const ADJ_MAXERROR: ::c_int = 0x0004;
+pub const ADJ_ESTERROR: ::c_int = 0x0008;
+pub const ADJ_STATUS: ::c_int = 0x0010;
+pub const ADJ_TIMECONST: ::c_int = 0x0020;
+pub const ADJ_TAI: ::c_int = 0x0080;
+pub const ADJ_SETOFFSET: ::c_int = 0x0100;
+pub const ADJ_MICRO: ::c_int = 0x1000;
+pub const ADJ_NANO: ::c_int = 0x2000;
+pub const ADJ_TICK: ::c_int = 0x4000;
+pub const ADJ_OFFSET_SINGLESHOT: ::c_int = 0x8001;
+pub const ADJ_OFFSET_SS_READ: ::c_int = 0xa001;
+pub const STA_PLL: ::c_int = 0x0001;
+pub const STA_PPSFREQ: ::c_int = 0x0002;
+pub const STA_PPSTIME: ::c_int = 0x0004;
+pub const STA_FLL: ::c_int = 0x0008;
+pub const STA_INS: ::c_int = 0x0010;
+pub const STA_DEL: ::c_int = 0x0020;
+pub const STA_UNSYNC: ::c_int = 0x0040;
+pub const STA_FREQHOLD: ::c_int = 0x0080;
+pub const STA_PPSSIGNAL: ::c_int = 0x0100;
+pub const STA_PPSJITTER: ::c_int = 0x0200;
+pub const STA_PPSWANDER: ::c_int = 0x0400;
+pub const STA_PPSERROR: ::c_int = 0x0800;
+pub const STA_CLOCKERR: ::c_int = 0x1000;
+pub const STA_NANO: ::c_int = 0x2000;
+pub const STA_MODE: ::c_int = 0x4000;
+pub const STA_CLK: ::c_int = 0x8000;
+s! {
+    pub struct timex {
+        pub modes: ::c_int,
+        pub offset: ::c_long,
+        pub freq: ::c_long,
+        pub maxerror: ::c_long,
+        pub esterror: ::c_long,
+        pub status: ::c_int,
+        pub constant: ::c_long,
+        pub precision: ::c_long,
+        pub tolerance: ::c_long,
+        pub time: ::timeval,
+        pub tick: ::c_long,
+        pub ppsfreq: ::c_long,
+        pub jitter: ::c_long,
+        pub shift: ::c_int,
+        pub stabil: ::c_long,
+        pub jitcnt: ::c_long,
+        pub calcnt: ::c_long,
+        pub errcnt: ::c_long,
+        pub stbcnt: ::c_long,
+        pub tai: ::c_int,
+        pub __padding: [::c_int; 11],
+    }
+}
+extern "C" {
+    pub fn adjtimex(arg0: *mut ::timex) -> ::c_int;
+    pub fn clock_adjtime(clk_id: ::clockid_t, buf: *mut ::timex) -> ::c_int;
+    pub fn ntp_adjtime(arg0: *mut ::timex) -> ::c_int;
+}
+
+// sys/types.h
+
+// sys/ucontext.h
+
+// sys/uio.h
+extern "C" {
+    pub fn preadv(fd: ::c_int, iov: *const ::iovec, iovcnt: ::c_int, offset: ::off_t) -> ::ssize_t;
+    pub fn pwritev(fd: ::c_int, iov: *const ::iovec, iovcnt: ::c_int, offset: ::off_t)
+        -> ::ssize_t;
+}
+
+// sys/un.h
+
+// sys/utsname.h
+
+// sys/vfs.h
+
+// sys/vt.h
+
+// sys/wait.h
+
+// sys/xattr.h
+extern "C" {
+    pub fn setxattr(
+        path: *const ::c_char,
+        name: *const ::c_char,
+        val: *const ::c_void,
+        size: ::size_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn lsetxattr(
+        path: *const ::c_char,
+        name: *const ::c_char,
+        val: *const ::c_void,
+        size: ::size_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn fsetxattr(
+        fd: ::c_int,
+        name: *const ::c_char,
+        val: *const ::c_void,
+        size: ::size_t,
+        flags: ::c_int,
+    ) -> ::c_int;
+    pub fn getxattr(
+        path: *const ::c_char,
+        name: *const ::c_char,
+        val: *mut ::c_void,
+        size: ::size_t,
+    ) -> ::ssize_t;
+    pub fn lgetxattr(
+        path: *const ::c_char,
+        name: *const ::c_char,
+        val: *mut ::c_void,
+        size: ::size_t,
+    ) -> ::ssize_t;
+    pub fn fgetxattr(
+        fd: ::c_int,
+        name: *const ::c_char,
+        val: *mut ::c_void,
+        size: ::size_t,
+    ) -> ::ssize_t;
+    pub fn listxattr(path: *const ::c_char, list: *mut ::c_char, size: ::size_t) -> ::ssize_t;
+    pub fn llistxattr(path: *const ::c_char, list: *mut ::c_char, size: ::size_t) -> ::ssize_t;
+    pub fn flistxattr(fd: ::c_int, list: *mut ::c_char, size: ::size_t) -> ::ssize_t;
+    pub fn removexattr(path: *const ::c_char, name: *const ::c_char) -> ::c_int;
+    pub fn lremovexattr(path: *const ::c_char, name: *const ::c_char) -> ::c_int;
+    pub fn fremovexattr(fd: ::c_int, name: *const ::c_char) -> ::c_int;
+}
+
+// termios.h
+
+// time.h
+
+// uchar.h
+pub type char16_t = ::c_ushort;
+pub type char32_t = ::c_uint;
+pub type mbstate_t = ::__mlibc_mbstate;
+extern "C" {
+    pub fn c32rtomb(pmb: *mut ::c_char, c32: ::char32_t, ps: *mut ::mbstate_t) -> ::size_t;
+    pub fn mbrtoc32(
+        pc32: *mut ::char32_t,
+        pmb: *const ::c_char,
+        max: ::size_t,
+        ps: *mut ::mbstate_t,
+    ) -> ::size_t;
+}
+
+// ucontext.h
+extern "C" {
+    pub fn getcontext(arg0: *mut ::ucontext_t) -> ::c_int;
+    pub fn setcontext(arg0: *const ::ucontext_t) -> ::c_int;
+    pub fn makecontext(
+        arg0: *mut ::ucontext_t,
+        arg1: ::Option<unsafe extern "C" fn() -> ::c_void>,
+        arg2: ::c_int,
+        ...
+    );
+    pub fn swapcontext(arg0: *mut ::ucontext_t, arg1: *const ::ucontext_t) -> ::c_int;
+}
+
+// unistd.h
+
+// utmp.h
+pub const EMPTY: ::c_int = 0;
+pub const RUN_LVL: ::c_int = 1;
+pub const BOOT_TIME: ::c_int = 2;
+pub const NEW_TIME: ::c_int = 3;
+pub const OLD_TIME: ::c_int = 4;
+pub const INIT_PROCESS: ::c_int = 5;
+pub const LOGIN_PROCESS: ::c_int = 6;
+pub const USER_PROCESS: ::c_int = 7;
+pub const DEAD_PROCESS: ::c_int = 8;
+pub const ACCOUNTING: ::c_int = 9;
+pub const UT_LINESIZE: ::c_int = 32;
+pub const UT_NAMESIZE: ::c_int = 32;
+pub const UT_HOSTSIZE: ::c_int = 256;
+s! {
+    pub struct exit_status {
+        pub e_termination: ::c_short,
+        pub e_exit: ::c_short,
+    }
+    pub struct utmp {
+        pub ut_type: ::c_short,
+        pub ut_pid: ::pid_t,
+        pub ut_line: [::c_char; 32],
+        pub ut_id: [::c_char; 4],
+        pub ut_user: [::c_char; 32],
+        pub ut_host: [::c_char; 256],
+        pub ut_exit: ::exit_status,
+        pub ut_session: ::c_long,
+        pub ut_tv: ::timeval,
+        pub ut_addr_v6: [i32; 4],
+        pub __unused: [::c_char; 20],
+    }
+    pub struct lastlog {
+        pub ll_time: ::time_t,
+        pub ll_line: [::c_char; 32],
+        pub ll_host: [::c_char; 256],
+    }
+}
+extern "C" {
+    pub fn setutent();
+    pub fn getutent() -> *mut ::utmp;
+    pub fn getutent_r(arg0: *mut ::utmp, arg1: *mut *mut ::utmp) -> ::c_int;
+    pub fn endutent();
+    pub fn pututline(arg0: *const ::utmp) -> *mut ::utmp;
+    pub fn getutline(arg0: *const ::utmp) -> *mut ::utmp;
+    pub fn getutid(arg0: *const ::utmp) -> *mut ::utmp;
+    pub fn utmpname(arg0: *const ::c_char) -> ::c_int;
+}
+
+// utmpx.h
+s! {
+    pub struct utmpx {
+        pub ut_type: ::c_short,
+        pub __ut_pad1: ::c_short,
+        pub ut_pid: ::pid_t,
+        pub ut_line: [::c_char; 32],
+        pub ut_id: [::c_char; 4],
+        pub ut_user: [::c_char; 32],
+        pub ut_host: [::c_char; 256],
+        pub ut_exit: anon_utmpx_line21,
+        pub ut_session: ::c_int,
+        pub __ut_pad2: ::c_int,
+        pub ut_tv: ::timeval,
+        pub ut_addr_v6: [::c_uint; 4],
+        pub __unused: [::c_char; 20],
+    }
+    pub struct anon_utmpx_line21 {
+        pub __e_termination: ::c_short,
+        pub __e_exit: ::c_short,
+    }
+}
+extern "C" {
+    pub fn updwtmpx(arg0: *const ::c_char, arg1: *const ::utmpx);
+    pub fn utmpxname(arg0: *const ::c_char) -> ::c_int;
+    pub fn pututxline(arg0: *const ::utmpx) -> *mut ::utmpx;
+    pub fn getutxent() -> *mut ::utmpx;
+    pub fn getutxid(id: *const ::utmpx) -> *mut ::utmpx;
+    pub fn setutxent();
+    pub fn endutxent();
+}
-- 
2.44.0

