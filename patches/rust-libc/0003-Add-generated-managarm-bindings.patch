From a10dd25caffad40c3b0e21b40960755e1093afea Mon Sep 17 00:00:00 2001
From: no92 <no92.mail@gmail.com>
Date: Fri, 28 Mar 2025 19:33:56 +0100
Subject: [PATCH 3/3] Add generated managarm bindings

---
 src/unix/linux_like/managarm/mod.rs | 2811 +++++++++++++++++++++++++++
 1 file changed, 2811 insertions(+)
 create mode 100644 src/unix/linux_like/managarm/mod.rs

diff --git a/src/unix/linux_like/managarm/mod.rs b/src/unix/linux_like/managarm/mod.rs
new file mode 100644
index 000000000..20b847c80
--- /dev/null
+++ b/src/unix/linux_like/managarm/mod.rs
@@ -0,0 +1,2811 @@
+// This file is autogenerated!
+// All changes made will be lost (eventually)!
+use crate::prelude::*;
+use crate::{
+    sighandler_t, AF_LOCAL, LC_COLLATE_MASK, LC_CTYPE_MASK, LC_MESSAGES_MASK, LC_MONETARY_MASK,
+    LC_NUMERIC_MASK, LC_TIME_MASK, PF_LOCAL,
+};
+
+pub type blkcnt64_t = i64;
+pub type rlimit64 = crate::rlimit;
+pub type rlim64_t = crate::rlim_t;
+pub type dirent64 = crate::dirent;
+pub type statfs64 = crate::statfs;
+pub type statvfs64 = crate::statvfs;
+pub type idtype_t = c_uint;
+pub type sem_t = c_uint;
+pub type Ioctl = c_ulong;
+
+pub type pthread_t = *mut c_void;
+pub type pthread_once_t = c_int;
+
+pub type __u8 = c_uchar;
+pub type __u16 = c_ushort;
+pub type __s16 = c_short;
+pub type __u32 = c_uint;
+pub type __s32 = c_int;
+pub type __u64 = c_ulonglong;
+pub type __s64 = c_longlong;
+
+pub type Elf32_Half = u16;
+pub type Elf32_Word = u32;
+pub type Elf32_Off = u32;
+pub type Elf32_Addr = u32;
+
+pub type Elf64_Half = u16;
+pub type Elf64_Word = u32;
+pub type Elf64_Off = u64;
+pub type Elf64_Addr = u64;
+pub type Elf64_Xword = u64;
+
+pub type blkcnt_t = i64;
+pub type dev_t = u64;
+pub type fsblkcnt_t = u64;
+pub type fsfilcnt_t = u64;
+pub type socklen_t = c_uint;
+pub type ino_t = u64;
+pub type ino64_t = crate::ino_t;
+pub type mode_t = c_uint;
+pub type time_t = c_long;
+pub type msglen_t = c_ulong;
+pub type msgqnum_t = c_ulong;
+pub type suseconds_t = c_long;
+pub type rlim_t = c_ulong;
+pub type off_t = i64;
+pub type off64_t = i64;
+pub type useconds_t = u32;
+pub type shmatt_t = c_ulong;
+pub type clock_t = c_long;
+pub type stack_t = crate::__stack;
+pub type fsid_t = crate::__mlibc_fsid;
+pub type wchar_t = c_int;
+pub type nl_item = c_int;
+pub type greg_t = c_ulong;
+pub type mqd_t = c_int;
+pub type nfds_t = usize;
+pub type pthread_attr_t = crate::__mlibc_threadattr;
+pub type pthread_key_t = crate::uintptr_t;
+pub type pthread_mutexattr_t = crate::__mlibc_mutexattr;
+pub type pthread_mutex_t = crate::__mlibc_mutex;
+pub type pthread_condattr_t = crate::__mlibc_condattr;
+pub type pthread_cond_t = crate::__mlibc_cond;
+pub type pthread_barrierattr_t = crate::__mlibc_barrierattr_struct;
+pub type pthread_barrier_t = crate::__mlibc_barrier;
+pub type pthread_rwlock_t = crate::__mlibc_fair_rwlock;
+pub type pthread_rwlockattr_t = crate::__mlibc_rwlockattr;
+pub type regoff_t = crate::ptrdiff_t;
+pub type regex_t = crate::re_pattern_buffer;
+pub type eventfd_t = u64;
+
+s! {
+    pub struct Elf32_Phdr {
+        pub p_type: Elf32_Word,
+        pub p_offset: Elf32_Off,
+        pub p_vaddr: Elf32_Addr,
+        pub p_paddr: Elf32_Addr,
+        pub p_filesz: Elf32_Word,
+        pub p_memsz: Elf32_Word,
+        pub p_flags: Elf32_Word,
+        pub p_align: Elf32_Word,
+    }
+
+    pub struct Elf64_Phdr {
+        pub p_type: Elf64_Word,
+        pub p_flags: Elf64_Word,
+        pub p_offset: Elf64_Off,
+        pub p_vaddr: Elf64_Addr,
+        pub p_paddr: Elf64_Addr,
+        pub p_filesz: Elf64_Xword,
+        pub p_memsz: Elf64_Xword,
+        pub p_align: Elf64_Xword,
+    }
+
+    pub struct dl_phdr_info {
+        #[cfg(target_pointer_width = "64")]
+        pub dlpi_addr: Elf64_Addr,
+        #[cfg(target_pointer_width = "32")]
+        pub dlpi_addr: Elf32_Addr,
+
+        pub dlpi_name: *const c_char,
+
+        #[cfg(target_pointer_width = "64")]
+        pub dlpi_phdr: *const Elf64_Phdr,
+        #[cfg(target_pointer_width = "32")]
+        pub dlpi_phdr: *const Elf32_Phdr,
+
+        #[cfg(target_pointer_width = "64")]
+        pub dlpi_phnum: Elf64_Half,
+        #[cfg(target_pointer_width = "32")]
+        pub dlpi_phnum: Elf32_Half,
+
+        pub dlpi_adds: c_ulonglong,
+        pub dlpi_subs: c_ulonglong,
+        pub dlpi_tls_modid: size_t,
+        pub dlpi_tls_data: *mut c_void,
+    }
+
+    pub struct cpu_set_t {
+        pub bits: [c_ulong; 16],
+    }
+
+    pub struct ipc_perm {
+        pub __ipc_perm_key: crate::key_t,
+        pub uid: crate::uid_t,
+        pub gid: crate::gid_t,
+        pub cuid: crate::uid_t,
+        pub cgid: crate::gid_t,
+        pub mode: crate::mode_t,
+        pub __ipc_perm_seq: c_int,
+        pub __unused: [c_long; 2],
+    }
+
+    pub struct semid_ds {
+        pub sem_perm: crate::ipc_perm,
+        pub sem_otime: crate::time_t,
+        pub sem_ctime: crate::time_t,
+        pub sem_nsems: c_ulong,
+    }
+
+    pub struct msqid_ds {
+        pub msg_perm: crate::ipc_perm,
+        pub msg_stime: crate::time_t,
+        pub msg_rtime: crate::time_t,
+        pub msg_ctime: crate::time_t,
+        pub msg_cbytes: c_ulong,
+        pub msg_qnum: crate::msgqnum_t,
+        pub msg_qbytes: crate::msglen_t,
+        pub msg_lspid: crate::pid_t,
+        pub msg_lrpid: crate::pid_t,
+        pub __unused: [c_ulong; 2],
+    }
+
+    pub struct shmid_ds {
+        pub shm_perm: crate::ipc_perm,
+        pub shm_segsz: crate::size_t,
+        pub shm_atime: crate::time_t,
+        pub shm_dtime: crate::time_t,
+        pub shm_ctime: crate::time_t,
+        pub shm_cpid: crate::pid_t,
+        pub shm_lpid: crate::pid_t,
+        pub shm_nattch: c_ulong,
+        pub __unused: [c_ulong; 2],
+    }
+
+    pub struct msghdr {
+        pub msg_name: *mut c_void,
+        pub msg_namelen: crate::socklen_t,
+        pub msg_iov: *mut crate::iovec,
+        pub msg_iovlen: crate::size_t,
+        pub msg_control: *mut c_void,
+        pub msg_controllen: crate::size_t,
+        pub msg_flags: c_int,
+    }
+    pub struct cmsghdr {
+        pub cmsg_len: crate::size_t,
+        pub cmsg_level: c_int,
+        pub cmsg_type: c_int,
+    }
+    pub struct in6_pktinfo {
+        pub ipi6_addr: crate::in6_addr,
+        pub ipi6_ifindex: u32,
+    }
+    pub struct mq_attr {
+        pub mq_flags: c_long,
+        pub mq_maxmsg: c_long,
+        pub mq_msgsize: c_long,
+        pub mq_curmsgs: c_long,
+        pub __pad: [c_long; 4],
+    }
+    pub struct ucred {
+        pub pid: crate::pid_t,
+        pub uid: crate::uid_t,
+        pub gid: crate::gid_t,
+    }
+    pub struct rtentry {
+        pub rt_pad1: c_ulong,
+        pub rt_dst: crate::sockaddr,
+        pub rt_gateway: crate::sockaddr,
+        pub rt_genmask: crate::sockaddr,
+        pub rt_flags: c_ushort,
+        pub rt_pad2: c_short,
+        pub rt_pad3: c_ulong,
+        pub rt_tos: c_uchar,
+        pub rt_class: c_uchar,
+        pub rt_pad4: [c_short; 3],
+        pub rt_metric: c_short,
+        pub rt_dev: *mut c_char,
+        pub rt_mtu: c_ulong,
+        pub rt_window: c_ulong,
+        pub rt_irtt: c_ushort,
+    }
+    pub struct sembuf {
+        pub sem_num: c_ushort,
+        pub sem_op: c_short,
+        pub sem_flg: c_short,
+    }
+    pub struct itimerspec {
+        pub it_interval: crate::timespec,
+        pub it_value: crate::timespec,
+    }
+    pub struct siginfo_t {
+        pub si_signo: c_int,
+        pub si_errno: c_int,
+        pub si_code: c_int,
+        pub __si_fields: [c_char; 116],
+        pub __si_align: [usize; 0],
+    }
+    pub struct sigset_t {
+        pub sig: [c_ulong; 16],
+    }
+    pub struct __stack {
+        pub ss_sp: *mut c_void,
+        pub ss_flags: c_int,
+        pub ss_size: crate::size_t,
+    }
+    pub struct __mlibc_threadattr {
+        #[doc(hidden)]
+        size: [u8; 200],
+    }
+    pub struct __mlibc_mutex {
+        #[doc(hidden)]
+        size: [u8; 16],
+    }
+    pub struct __mlibc_mutexattr {
+        #[doc(hidden)]
+        size: [u8; 20],
+    }
+    pub struct __mlibc_cond {
+        #[doc(hidden)]
+        size: [u8; 12],
+    }
+    pub struct __mlibc_condattr {
+        #[doc(hidden)]
+        size: [u8; 8],
+    }
+    // FIXME(1.0): This should not implement `PartialEq`
+    #[allow(unpredictable_function_pointer_comparisons)]
+    pub struct sigaction {
+        pub sa_sigaction: sighandler_t,
+        pub sa_flags: c_ulong,
+        pub sa_restorer: Option<unsafe extern "C" fn()>,
+        pub sa_mask: crate::sigset_t,
+    }
+    pub struct __mlibc_fsid {
+        pub __val: [c_int; 2],
+    }
+    pub struct statfs {
+        pub f_type: c_ulong,
+        pub f_bsize: c_ulong,
+        pub f_blocks: crate::fsblkcnt_t,
+        pub f_bfree: crate::fsblkcnt_t,
+        pub f_bavail: crate::fsblkcnt_t,
+        pub f_files: crate::fsfilcnt_t,
+        pub f_ffree: crate::fsfilcnt_t,
+        pub f_fsid: crate::fsid_t,
+        pub f_namelen: c_ulong,
+        pub f_frsize: c_ulong,
+        pub f_flags: c_ulong,
+        pub __f_spare: [c_ulong; 4],
+    }
+    pub struct statvfs {
+        pub f_bsize: c_ulong,
+        pub f_frsize: c_ulong,
+        pub f_blocks: crate::fsblkcnt_t,
+        pub f_bfree: crate::fsblkcnt_t,
+        pub f_bavail: crate::fsblkcnt_t,
+        pub f_files: crate::fsfilcnt_t,
+        pub f_ffree: crate::fsfilcnt_t,
+        pub f_favail: crate::fsfilcnt_t,
+        pub f_fsid: c_ulong,
+        pub f_flag: c_ulong,
+        pub f_namemax: c_ulong,
+        pub f_spare: [c_uint; 6],
+    }
+    pub struct termios {
+        pub c_iflag: crate::tcflag_t,
+        pub c_oflag: crate::tcflag_t,
+        pub c_cflag: crate::tcflag_t,
+        pub c_lflag: crate::tcflag_t,
+        pub c_line: crate::cc_t,
+        pub c_cc: [crate::cc_t; crate::NCCS],
+        pub ibaud: crate::speed_t,
+        pub obaud: crate::speed_t,
+    }
+    pub struct anon_utmpx_line20 {
+        pub __e_termination: c_short,
+        pub __e_exit: c_short,
+    }
+    pub struct utmpx {
+        pub ut_type: c_short,
+        pub __ut_pad1: c_short,
+        pub ut_pid: crate::pid_t,
+        pub ut_line: [c_char; crate::__UT_LINESIZE],
+        pub ut_id: [c_char; 4],
+        pub ut_user: [c_char; crate::__UT_NAMESIZE],
+        pub ut_host: [c_char; crate::__UT_HOSTSIZE],
+        pub ut_exit: anon_utmpx_line20,
+        pub ut_session: c_int,
+        pub __ut_pad2: c_int,
+        pub ut_tv: crate::timeval,
+        pub ut_addr_v6: [c_uint; 4],
+        pub __unused: [c_char; 20],
+    }
+    pub struct option {
+        pub name: *const c_char,
+        pub has_arg: c_int,
+        pub flag: *mut c_int,
+        pub val: c_int,
+    }
+    pub struct exit_status {
+        pub e_termination: c_short,
+        pub e_exit: c_short,
+    }
+    pub struct utmp {
+        pub ut_type: c_short,
+        pub ut_pid: crate::pid_t,
+        pub ut_line: [c_char; crate::UT_LINESIZE],
+        pub ut_id: [c_char; 4],
+        pub ut_user: [c_char; crate::UT_NAMESIZE],
+        pub ut_host: [c_char; crate::UT_HOSTSIZE],
+        pub ut_exit: crate::exit_status,
+        pub ut_session: c_long,
+        pub ut_tv: crate::timeval,
+        pub ut_addr_v6: [i32; 4],
+        pub __unused: [c_char; 20],
+    }
+    pub struct lastlog {
+        pub ll_time: crate::time_t,
+        pub ll_line: [c_char; crate::UT_LINESIZE],
+        pub ll_host: [c_char; crate::UT_HOSTSIZE],
+    }
+    pub struct _libc_fpxreg {
+        pub significand: [c_ushort; 4],
+        pub exponent: c_ushort,
+        pub __glibc_reserved1: [c_ushort; 3],
+    }
+    pub struct _libc_xmmreg {
+        pub element: [u32; 4],
+    }
+    pub struct _libc_fpstate {
+        pub cwd: u16,
+        pub swd: i16,
+        pub ftw: u16,
+        pub fop: u16,
+        pub rip: u64,
+        pub dp: u64,
+        pub mxcsr: u32,
+        pub mxcr_mask: u32,
+        pub _st: [crate::_libc_fpxreg; 8],
+        pub _xmm: [crate::_libc_xmmreg; 16],
+        pub __glibc_reserved1: [u32; 24],
+    }
+    pub struct dirent {
+        pub d_ino: crate::ino_t,
+        pub d_off: crate::off_t,
+        pub d_reclen: c_ushort,
+        pub d_type: c_uchar,
+        pub d_name: [c_char; 256],
+    }
+    pub struct flock {
+        pub l_type: c_short,
+        pub l_whence: c_short,
+        pub l_start: crate::off_t,
+        pub l_len: crate::off_t,
+        pub l_pid: crate::pid_t,
+    }
+    pub struct flock64 {
+        pub l_type: c_short,
+        pub l_whence: c_short,
+        pub l_start: crate::off_t,
+        pub l_len: crate::off_t,
+        pub l_pid: crate::pid_t,
+    }
+
+    // FIXME(1.0): This should not implement `PartialEq`
+    #[allow(unpredictable_function_pointer_comparisons)]
+    pub struct glob_t {
+        pub gl_pathc: crate::size_t,
+        pub gl_pathv: *mut *mut c_char,
+        pub gl_offs: crate::size_t,
+        pub gl_flags: c_int,
+        pub gl_closedir: Option<unsafe extern "C" fn(*mut c_void)>,
+        pub gl_readdir: Option<unsafe extern "C" fn(*mut c_void) -> *mut crate::dirent>,
+        pub gl_opendir: Option<unsafe extern "C" fn(*const c_char) -> *mut c_void>,
+        pub gl_lstat: Option<unsafe extern "C" fn(*const c_char, *mut crate::stat) -> c_int>,
+        pub gl_stat: Option<unsafe extern "C" fn(*const c_char, *mut crate::stat) -> c_int>,
+    }
+    pub struct mntent {
+        pub mnt_fsname: *mut c_char,
+        pub mnt_dir: *mut c_char,
+        pub mnt_type: *mut c_char,
+        pub mnt_opts: *mut c_char,
+        pub mnt_freq: c_int,
+        pub mnt_passno: c_int,
+    }
+    pub struct if_nameindex {
+        pub if_index: c_uint,
+        pub if_name: *mut c_char,
+    }
+    pub struct packet_mreq {
+        pub mr_ifindex: c_int,
+        pub mr_type: c_ushort,
+        pub mr_alen: c_ushort,
+        pub mr_address: [c_uchar; 8],
+    }
+    pub struct __mlibc_barrierattr_struct {
+        #[doc(hidden)]
+        size: [u8; 4],
+    }
+    pub struct __mlibc_barrier {
+        #[doc(hidden)]
+        size: [u8; 20],
+    }
+    pub struct __mlibc_fair_rwlock {
+        #[doc(hidden)]
+        size: [u8; 12],
+    }
+    pub struct __mlibc_rwlockattr {
+        #[doc(hidden)]
+        size: [u8; 4],
+    }
+    pub struct passwd {
+        pub pw_name: *mut c_char,
+        pub pw_passwd: *mut c_char,
+        pub pw_uid: crate::uid_t,
+        pub pw_gid: crate::gid_t,
+        pub pw_gecos: *mut c_char,
+        pub pw_dir: *mut c_char,
+        pub pw_shell: *mut c_char,
+    }
+    pub struct re_pattern_buffer {
+        pub re_nsub: crate::size_t,
+        pub __opaque: *mut c_void,
+        pub __padding: [*mut c_void; 4],
+        pub __nsub2: crate::size_t,
+        pub __padding2: c_char,
+    }
+    pub struct regmatch_t {
+        pub rm_so: crate::regoff_t,
+        pub rm_eo: crate::regoff_t,
+    }
+    pub struct spwd {
+        pub sp_namp: *mut c_char,
+        pub sp_pwdp: *mut c_char,
+        pub sp_lstchg: c_long,
+        pub sp_min: c_long,
+        pub sp_max: c_long,
+        pub sp_warn: c_long,
+        pub sp_inact: c_long,
+        pub sp_expire: c_long,
+        pub sp_flag: c_ulong,
+    }
+    pub struct posix_spawnattr_t {
+        pub __flags: c_int,
+        pub __pgrp: crate::pid_t,
+        pub __def: crate::sigset_t,
+        pub __mask: crate::sigset_t,
+        pub __prio: c_int,
+        pub __pol: c_int,
+        pub __fn: *mut c_void,
+        pub __pad: [c_char; 56],
+    }
+    pub struct posix_spawn_file_actions_t {
+        pub __pad0: [c_int; 2],
+        pub __actions: *mut c_void,
+        pub __pad: [c_int; 16],
+    }
+    pub struct inotify_event {
+        pub wd: c_int,
+        pub mask: c_uint,
+        pub cookie: c_uint,
+        pub len: c_uint,
+        pub name: *mut c_char,
+    }
+    pub struct ptrace_peeksiginfo_args {
+        pub offset: u64,
+        pub flags: u32,
+        pub nr: i32,
+    }
+    pub struct signalfd_siginfo {
+        pub ssi_signo: u32,
+        pub ssi_errno: i32,
+        pub ssi_code: i32,
+        pub ssi_pid: u32,
+        pub ssi_uid: u32,
+        pub ssi_fd: i32,
+        pub ssi_tid: u32,
+        pub ssi_band: u32,
+        pub ssi_overrun: u32,
+        pub ssi_trapno: u32,
+        pub ssi_status: i32,
+        pub ssi_int: i32,
+        pub ssi_ptr: u64,
+        pub ssi_utime: u64,
+        pub ssi_stime: u64,
+        pub ssi_addr: u64,
+        pub ssi_addr_lsb: u16,
+        pub pad: [u8; 46],
+    }
+    pub struct sysinfo {
+        pub uptime: c_long,
+        pub loads: [c_ulong; 3],
+        pub totalram: c_ulong,
+        pub freeram: c_ulong,
+        pub sharedram: c_ulong,
+        pub bufferram: c_ulong,
+        pub totalswap: c_ulong,
+        pub freeswap: c_ulong,
+        pub procs: c_ushort,
+        pub totalhigh: c_ulong,
+        pub freehigh: c_ulong,
+        pub mem_unit: c_uint,
+        pub _f: [c_char; 0],
+    }
+    pub struct timex {
+        pub modes: c_int,
+        pub offset: c_long,
+        pub freq: c_long,
+        pub maxerror: c_long,
+        pub esterror: c_long,
+        pub status: c_int,
+        pub constant: c_long,
+        pub precision: c_long,
+        pub tolerance: c_long,
+        pub time: crate::timeval,
+        pub tick: c_long,
+        pub ppsfreq: c_long,
+        pub jitter: c_long,
+        pub shift: c_int,
+        pub stabil: c_long,
+        pub jitcnt: c_long,
+        pub calcnt: c_long,
+        pub errcnt: c_long,
+        pub stbcnt: c_long,
+        pub tai: c_int,
+        pub __padding: [c_int; 11],
+    }
+}
+
+s_no_extra_traits! {
+    pub struct __c_anonymous_ifru_map {
+        pub mem_start: c_ulong,
+        pub mem_end: c_ulong,
+        pub base_addr: c_ushort,
+        pub irq: c_uchar,
+        pub dma: c_uchar,
+        pub port: c_uchar,
+    }
+
+    pub union __c_anonymous_ifr_ifru {
+        pub ifru_addr: crate::sockaddr,
+        pub ifru_dstaddr: crate::sockaddr,
+        pub ifru_broadaddr: crate::sockaddr,
+        pub ifru_netmask: crate::sockaddr,
+        pub ifru_hwaddr: crate::sockaddr,
+        pub ifru_flags: c_short,
+        pub ifru_ifindex: c_int,
+        pub ifru_metric: c_int,
+        pub ifru_mtu: c_int,
+        pub ifru_map: __c_anonymous_ifru_map,
+        pub ifru_slave: [c_char; crate::IFNAMSIZ],
+        pub ifru_newname: [c_char; crate::IFNAMSIZ],
+        pub ifru_data: *mut c_char,
+    }
+
+    pub struct ifreq {
+        pub ifr_name: [c_char; crate::IFNAMSIZ],
+        pub ifr_ifru: __c_anonymous_ifr_ifru,
+    }
+
+    pub struct sockaddr_nl {
+        pub nl_family: crate::sa_family_t,
+        nl_pad: c_ushort,
+        pub nl_pid: u32,
+        pub nl_groups: u32,
+    }
+}
+
+f! {
+    pub fn CMSG_NXTHDR(mhdr: *const msghdr, cmsg: *const cmsghdr) -> *mut cmsghdr {
+        if ((*cmsg).cmsg_len as usize) < size_of::<cmsghdr>() {
+            return core::ptr::null_mut::<cmsghdr>();
+        }
+        let next = (cmsg as usize + super::CMSG_ALIGN((*cmsg).cmsg_len as usize)) as *mut cmsghdr;
+        let max = (*mhdr).msg_control as usize + (*mhdr).msg_controllen as usize;
+        if (next.wrapping_offset(1)) as usize > max
+            || next as usize + super::CMSG_ALIGN((*next).cmsg_len as usize) > max
+        {
+            core::ptr::null_mut::<cmsghdr>()
+        } else {
+            next
+        }
+    }
+}
+
+safe_f! {
+    pub {const} fn makedev(major: c_uint, minor: c_uint) -> crate::dev_t {
+        let major = major as crate::dev_t;
+        let minor = minor as crate::dev_t;
+        let mut dev = 0;
+        dev |= (major & 0x00000fff) << 8;
+        dev |= (major & 0xfffff000) << 32;
+        dev |= (minor & 0x000000ff) << 0;
+        dev |= (minor & 0xffffff00) << 12;
+        dev
+    }
+
+    pub {const} fn major(dev: crate::dev_t) -> c_uint {
+        let mut major = 0;
+        major |= (dev & 0x00000000000fff00) >> 8;
+        major |= (dev & 0xfffff00000000000) >> 32;
+        major as c_uint
+    }
+
+    pub {const} fn minor(dev: crate::dev_t) -> c_uint {
+        let mut minor = 0;
+        minor |= (dev & 0x00000000000000ff) >> 0;
+        minor |= (dev & 0x00000ffffff00000) >> 12;
+        minor as c_uint
+    }
+}
+
+impl siginfo_t {
+    pub unsafe fn si_status(&self) -> c_int {
+        #[repr(C)]
+        struct siginfo_sigchld {
+            _si_signo: c_int,
+            _si_errno: c_int,
+            _si_code: c_int,
+            si_pid: crate::pid_t,
+            si_uid: crate::uid_t,
+            si_status: c_int,
+            si_utime: crate::clock_t,
+            si_stime: crate::clock_t,
+        }
+        (*(self as *const siginfo_t).cast::<siginfo_sigchld>()).si_status
+    }
+
+    pub unsafe fn si_addr(&self) -> *mut c_void {
+        #[repr(C)]
+        struct siginfo_sigfault {
+            _si_signo: c_int,
+            _si_errno: c_int,
+            _si_code: c_int,
+            si_addr: *mut c_void,
+        }
+        (*(self as *const siginfo_t).cast::<siginfo_sigfault>()).si_addr
+    }
+}
+
+pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t { size: [0; 16] };
+pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t { size: [0; 12] };
+pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t { size: [0; 12] };
+
+pub const RTLD_DEFAULT: *mut c_void = 0i64 as *mut c_void;
+pub const RLIM_INFINITY: crate::rlim_t = !0;
+
+// linux/netlink.h
+pub const NLA_ALIGNTO: c_int = 4;
+
+pub const NETLINK_ROUTE: c_int = 0;
+pub const NETLINK_UNUSED: c_int = 1;
+pub const NETLINK_USERSOCK: c_int = 2;
+pub const NETLINK_FIREWALL: c_int = 3;
+pub const NETLINK_SOCK_DIAG: c_int = 4;
+pub const NETLINK_NFLOG: c_int = 5;
+pub const NETLINK_XFRM: c_int = 6;
+pub const NETLINK_SELINUX: c_int = 7;
+pub const NETLINK_ISCSI: c_int = 8;
+pub const NETLINK_AUDIT: c_int = 9;
+pub const NETLINK_FIB_LOOKUP: c_int = 10;
+pub const NETLINK_CONNECTOR: c_int = 11;
+pub const NETLINK_NETFILTER: c_int = 12;
+pub const NETLINK_IP6_FW: c_int = 13;
+pub const NETLINK_DNRTMSG: c_int = 14;
+pub const NETLINK_KOBJECT_UEVENT: c_int = 15;
+pub const NETLINK_GENERIC: c_int = 16;
+pub const NETLINK_SCSITRANSPORT: c_int = 18;
+pub const NETLINK_ECRYPTFS: c_int = 19;
+pub const NETLINK_RDMA: c_int = 20;
+pub const NETLINK_CRYPTO: c_int = 21;
+pub const NETLINK_INET_DIAG: c_int = NETLINK_SOCK_DIAG;
+
+pub const NLM_F_REQUEST: c_int = 1;
+pub const NLM_F_MULTI: c_int = 2;
+pub const NLM_F_ACK: c_int = 4;
+pub const NLM_F_ECHO: c_int = 8;
+pub const NLM_F_DUMP_INTR: c_int = 16;
+pub const NLM_F_DUMP_FILTERED: c_int = 32;
+
+pub const NLM_F_ROOT: c_int = 0x100;
+pub const NLM_F_MATCH: c_int = 0x200;
+pub const NLM_F_ATOMIC: c_int = 0x400;
+pub const NLM_F_DUMP: c_int = NLM_F_ROOT | NLM_F_MATCH;
+
+pub const NLM_F_REPLACE: c_int = 0x100;
+pub const NLM_F_EXCL: c_int = 0x200;
+pub const NLM_F_CREATE: c_int = 0x400;
+pub const NLM_F_APPEND: c_int = 0x800;
+
+pub const NLM_F_NONREC: c_int = 0x100;
+pub const NLM_F_BULK: c_int = 0x200;
+
+pub const NLM_F_CAPPED: c_int = 0x100;
+pub const NLM_F_ACK_TLVS: c_int = 0x200;
+
+pub const NETLINK_ADD_MEMBERSHIP: c_int = 1;
+pub const NETLINK_DROP_MEMBERSHIP: c_int = 2;
+pub const NETLINK_PKTINFO: c_int = 3;
+pub const NETLINK_BROADCAST_ERROR: c_int = 4;
+pub const NETLINK_NO_ENOBUFS: c_int = 5;
+pub const NETLINK_RX_RING: c_int = 6;
+pub const NETLINK_TX_RING: c_int = 7;
+pub const NETLINK_LISTEN_ALL_NSID: c_int = 8;
+pub const NETLINK_LIST_MEMBERSHIPS: c_int = 9;
+pub const NETLINK_CAP_ACK: c_int = 10;
+pub const NETLINK_EXT_ACK: c_int = 11;
+pub const NETLINK_GET_STRICT_CHK: c_int = 12;
+
+pub const NLA_F_NESTED: c_int = 1 << 15;
+pub const NLA_F_NET_BYTEORDER: c_int = 1 << 14;
+pub const NLA_TYPE_MASK: c_int = !(NLA_F_NESTED | NLA_F_NET_BYTEORDER);
+
+pub const AT_HWCAP: c_int = 16;
+pub const AT_SECURE: c_int = 23;
+pub const AT_RANDOM: c_int = 25;
+pub const AT_EXECFN: c_int = 31;
+pub const AT_SYSINFO_EHDR: c_int = 33;
+pub const AT_XPIPE: c_int = 0x1000;
+pub const AT_OPENFILES: c_int = 0x1001;
+pub const AT_FS_SERVER: c_int = 0x1102;
+pub const AT_MBUS_SERVER: c_int = 0x1103;
+pub const EPOLL_CLOEXEC: c_int = 0o2000000;
+pub const EPERM: c_int = 1;
+pub const ENOENT: c_int = 2;
+pub const ESRCH: c_int = 3;
+pub const EINTR: c_int = 4;
+pub const EIO: c_int = 5;
+pub const ENXIO: c_int = 6;
+pub const E2BIG: c_int = 7;
+pub const ENOEXEC: c_int = 8;
+pub const EBADF: c_int = 9;
+pub const ECHILD: c_int = 10;
+pub const EAGAIN: c_int = 11;
+pub const ENOMEM: c_int = 12;
+pub const EACCES: c_int = 13;
+pub const EFAULT: c_int = 14;
+pub const ENOTBLK: c_int = 15;
+pub const EBUSY: c_int = 16;
+pub const EEXIST: c_int = 17;
+pub const EXDEV: c_int = 18;
+pub const ENODEV: c_int = 19;
+pub const ENOTDIR: c_int = 20;
+pub const EISDIR: c_int = 21;
+pub const EINVAL: c_int = 22;
+pub const ENFILE: c_int = 23;
+pub const EMFILE: c_int = 24;
+pub const ENOTTY: c_int = 25;
+pub const ETXTBSY: c_int = 26;
+pub const EFBIG: c_int = 27;
+pub const ENOSPC: c_int = 28;
+pub const ESPIPE: c_int = 29;
+pub const EROFS: c_int = 30;
+pub const EMLINK: c_int = 31;
+pub const EPIPE: c_int = 32;
+pub const EDOM: c_int = 33;
+pub const ERANGE: c_int = 34;
+pub const EDEADLK: c_int = 35;
+pub const ENAMETOOLONG: c_int = 36;
+pub const ENOLCK: c_int = 37;
+pub const ENOSYS: c_int = 38;
+pub const ENOTEMPTY: c_int = 39;
+pub const ELOOP: c_int = 40;
+pub const EWOULDBLOCK: c_int = EAGAIN;
+pub const ENOMSG: c_int = 42;
+pub const EIDRM: c_int = 43;
+pub const ECHRNG: c_int = 44;
+pub const EL2NSYNC: c_int = 45;
+pub const EL3HLT: c_int = 46;
+pub const EL3RST: c_int = 47;
+pub const ELNRNG: c_int = 48;
+pub const EUNATCH: c_int = 49;
+pub const ENOCSI: c_int = 50;
+pub const EL2HLT: c_int = 51;
+pub const EBADE: c_int = 52;
+pub const EBADR: c_int = 53;
+pub const EXFULL: c_int = 54;
+pub const ENOANO: c_int = 55;
+pub const EBADRQC: c_int = 56;
+pub const EBADSLT: c_int = 57;
+pub const EDEADLOCK: c_int = EDEADLK;
+pub const EBFONT: c_int = 59;
+pub const ENOSTR: c_int = 60;
+pub const ENODATA: c_int = 61;
+pub const ETIME: c_int = 62;
+pub const ENOSR: c_int = 63;
+pub const ENONET: c_int = 64;
+pub const ENOPKG: c_int = 65;
+pub const EREMOTE: c_int = 66;
+pub const ENOLINK: c_int = 67;
+pub const EADV: c_int = 68;
+pub const ESRMNT: c_int = 69;
+pub const ECOMM: c_int = 70;
+pub const EPROTO: c_int = 71;
+pub const EMULTIHOP: c_int = 72;
+pub const EDOTDOT: c_int = 73;
+pub const EBADMSG: c_int = 74;
+pub const EOVERFLOW: c_int = 75;
+pub const ENOTUNIQ: c_int = 76;
+pub const EBADFD: c_int = 77;
+pub const EREMCHG: c_int = 78;
+pub const ELIBACC: c_int = 79;
+pub const ELIBBAD: c_int = 80;
+pub const ELIBSCN: c_int = 81;
+pub const ELIBMAX: c_int = 82;
+pub const ELIBEXEC: c_int = 83;
+pub const EILSEQ: c_int = 84;
+pub const ERESTART: c_int = 85;
+pub const ESTRPIPE: c_int = 86;
+pub const EUSERS: c_int = 87;
+pub const ENOTSOCK: c_int = 88;
+pub const EDESTADDRREQ: c_int = 89;
+pub const EMSGSIZE: c_int = 90;
+pub const EPROTOTYPE: c_int = 91;
+pub const ENOPROTOOPT: c_int = 92;
+pub const EPROTONOSUPPORT: c_int = 93;
+pub const ESOCKTNOSUPPORT: c_int = 94;
+pub const EOPNOTSUPP: c_int = 95;
+pub const ENOTSUP: c_int = EOPNOTSUPP;
+pub const EPFNOSUPPORT: c_int = 96;
+pub const EAFNOSUPPORT: c_int = 97;
+pub const EADDRINUSE: c_int = 98;
+pub const EADDRNOTAVAIL: c_int = 99;
+pub const ENETDOWN: c_int = 100;
+pub const ENETUNREACH: c_int = 101;
+pub const ENETRESET: c_int = 102;
+pub const ECONNABORTED: c_int = 103;
+pub const ECONNRESET: c_int = 104;
+pub const ENOBUFS: c_int = 105;
+pub const EISCONN: c_int = 106;
+pub const ENOTCONN: c_int = 107;
+pub const ESHUTDOWN: c_int = 108;
+pub const ETOOMANYREFS: c_int = 109;
+pub const ETIMEDOUT: c_int = 110;
+pub const ECONNREFUSED: c_int = 111;
+pub const EHOSTDOWN: c_int = 112;
+pub const EHOSTUNREACH: c_int = 113;
+pub const EALREADY: c_int = 114;
+pub const EINPROGRESS: c_int = 115;
+pub const ESTALE: c_int = 116;
+pub const EUCLEAN: c_int = 117;
+pub const ENOTNAM: c_int = 118;
+pub const ENAVAIL: c_int = 119;
+pub const EISNAM: c_int = 120;
+pub const EREMOTEIO: c_int = 121;
+pub const EDQUOT: c_int = 122;
+pub const ENOMEDIUM: c_int = 123;
+pub const EMEDIUMTYPE: c_int = 124;
+pub const ECANCELED: c_int = 125;
+pub const ENOKEY: c_int = 126;
+pub const EKEYEXPIRED: c_int = 127;
+pub const EKEYREVOKED: c_int = 128;
+pub const EKEYREJECTED: c_int = 129;
+pub const EOWNERDEAD: c_int = 130;
+pub const ENOTRECOVERABLE: c_int = 131;
+pub const ERFKILL: c_int = 132;
+pub const EHWPOISON: c_int = 133;
+pub const EIEIO: c_int = 4095;
+pub const O_PATH: c_int = 0o10000000;
+pub const O_ACCMODE: c_int = 0o3 | O_PATH;
+pub const O_CREAT: c_int = 0o100;
+pub const O_EXCL: c_int = 0o200;
+pub const O_NOCTTY: c_int = 0o400;
+pub const O_TRUNC: c_int = 0o1000;
+pub const O_APPEND: c_int = 0o2000;
+pub const O_NONBLOCK: c_int = 0o4000;
+pub const O_DSYNC: c_int = 0o10000;
+pub const O_ASYNC: c_int = 0o20000;
+pub const O_CLOEXEC: c_int = 0o2000000;
+pub const O_SYNC: c_int = 0o4010000;
+pub const O_RSYNC: c_int = 0o4010000;
+pub const O_NOATIME: c_int = 0o1000000;
+pub const O_TMPFILE: c_int = 0o20000000 | O_DIRECTORY;
+pub const O_EXEC: c_int = O_PATH;
+pub const O_SEARCH: c_int = O_PATH;
+pub const F_SETOWN: c_int = 8;
+pub const F_GETOWN: c_int = 9;
+pub const F_SETSIG: c_int = 10;
+pub const F_GETSIG: c_int = 11;
+pub const F_GETLK64: c_int = 5;
+pub const F_SETLK64: c_int = 6;
+pub const F_SETLKW64: c_int = 7;
+pub const F_GETLK: c_int = F_GETLK64;
+pub const F_SETLK: c_int = F_SETLK64;
+pub const F_SETLKW: c_int = F_SETLKW64;
+pub const F_SETOWN_EX: c_int = 15;
+pub const F_GETOWN_EX: c_int = 16;
+pub const F_GETOWNER_UIDS: c_int = 17;
+pub const F_OFD_GETLK: c_int = 36;
+pub const F_OFD_SETLK: c_int = 37;
+pub const F_OFD_SETLKW: c_int = 38;
+pub const F_RDLCK: c_int = 0;
+pub const F_WRLCK: c_int = 1;
+pub const F_UNLCK: c_int = 2;
+pub const AT_EACCESS: c_int = 0x200;
+pub const POSIX_FADV_DONTNEED: c_int = 4;
+pub const POSIX_FADV_NOREUSE: c_int = 5;
+pub const SOCK_STREAM: c_int = 1;
+pub const SOCK_DGRAM: c_int = 2;
+pub const SOCK_SEQPACKET: c_int = 5;
+pub const SOCK_DCCP: c_int = 6;
+pub const SOCK_PACKET: c_int = 10;
+pub const SOCK_NONBLOCK: c_int = 0o4000;
+pub const PF_FILE: c_int = PF_LOCAL;
+pub const PF_IB: c_int = 27;
+pub const PF_MPLS: c_int = 28;
+pub const PF_NFC: c_int = 39;
+pub const PF_VSOCK: c_int = 40;
+pub const PF_KCM: c_int = 41;
+pub const PF_QIPCRTR: c_int = 42;
+pub const PF_SMC: c_int = 43;
+pub const PF_XDP: c_int = 44;
+pub const AF_FILE: c_int = AF_LOCAL;
+pub const AF_IB: c_int = PF_IB;
+pub const AF_MPLS: c_int = PF_MPLS;
+pub const AF_NFC: c_int = PF_NFC;
+pub const AF_VSOCK: c_int = PF_VSOCK;
+pub const AF_KCM: c_int = PF_KCM;
+pub const AF_QIPCRTR: c_int = PF_QIPCRTR;
+pub const AF_SMC: c_int = PF_SMC;
+pub const AF_XDP: c_int = PF_XDP;
+pub const SO_REUSEADDR: c_int = 2;
+pub const SO_TYPE: c_int = 3;
+pub const SO_ERROR: c_int = 4;
+pub const SO_DONTROUTE: c_int = 5;
+pub const SO_BROADCAST: c_int = 6;
+pub const SO_SNDBUF: c_int = 7;
+pub const SO_RCVBUF: c_int = 8;
+pub const SO_KEEPALIVE: c_int = 9;
+pub const SO_OOBINLINE: c_int = 10;
+pub const SO_NO_CHECK: c_int = 11;
+pub const SO_PRIORITY: c_int = 12;
+pub const SO_LINGER: c_int = 13;
+pub const SO_BSDCOMPAT: c_int = 14;
+pub const SO_REUSEPORT: c_int = 15;
+pub const SO_PASSCRED: c_int = 16;
+pub const SO_PEERCRED: c_int = 17;
+pub const SO_RCVLOWAT: c_int = 18;
+pub const SO_SNDLOWAT: c_int = 19;
+pub const SO_ACCEPTCONN: c_int = 30;
+pub const SO_PEERSEC: c_int = 31;
+pub const SO_SNDBUFFORCE: c_int = 32;
+pub const SO_RCVBUFFORCE: c_int = 33;
+pub const SO_PROTOCOL: c_int = 38;
+pub const SO_DOMAIN: c_int = 39;
+pub const SO_RCVTIMEO: c_int = 20;
+pub const SO_RCVTIMEO_OLD: c_int = 20;
+pub const SO_SNDTIMEO: c_int = 21;
+pub const SO_SNDTIMEO_OLD: c_int = 21;
+pub const SO_TIMESTAMP: c_int = 29;
+pub const SO_TIMESTAMPNS: c_int = 35;
+pub const SO_TIMESTAMPING: c_int = 37;
+pub const SO_SECURITY_AUTHENTICATION: c_int = 22;
+pub const SO_SECURITY_ENCRYPTION_TRANSPORT: c_int = 23;
+pub const SO_SECURITY_ENCRYPTION_NETWORK: c_int = 24;
+pub const SO_BINDTODEVICE: c_int = 25;
+pub const SO_ATTACH_FILTER: c_int = 26;
+pub const SO_DETACH_FILTER: c_int = 27;
+pub const SO_GET_FILTER: c_int = SO_ATTACH_FILTER;
+pub const SO_PEERNAME: c_int = 28;
+pub const SO_PASSSEC: c_int = 34;
+pub const SCM_TIMESTAMPNS: c_int = SO_TIMESTAMPNS;
+pub const SO_MARK: c_int = 36;
+pub const SCM_TIMESTAMPING: c_int = SO_TIMESTAMPING;
+pub const SO_RXQ_OVFL: c_int = 40;
+pub const SO_WIFI_STATUS: c_int = 41;
+pub const SCM_WIFI_STATUS: c_int = SO_WIFI_STATUS;
+pub const SO_PEEK_OFF: c_int = 42;
+pub const SO_NOFCS: c_int = 43;
+pub const SO_LOCK_FILTER: c_int = 44;
+pub const SO_SELECT_ERR_QUEUE: c_int = 45;
+pub const SO_BUSY_POLL: c_int = 46;
+pub const SO_MAX_PACING_RATE: c_int = 47;
+pub const SO_BPF_EXTENSIONS: c_int = 48;
+pub const SO_INCOMING_CPU: c_int = 49;
+pub const SO_ATTACH_BPF: c_int = 50;
+pub const SO_DETACH_BPF: c_int = SO_DETACH_FILTER;
+pub const SO_ATTACH_REUSEPORT_CBPF: c_int = 51;
+pub const SO_ATTACH_REUSEPORT_EBPF: c_int = 52;
+pub const SO_CNX_ADVICE: c_int = 53;
+pub const SCM_TIMESTAMPING_OPT_STATS: c_int = 54;
+pub const SO_MEMINFO: c_int = 55;
+pub const SO_INCOMING_NAPI_ID: c_int = 56;
+pub const SO_COOKIE: c_int = 57;
+pub const SCM_TIMESTAMPING_PKTINFO: c_int = 58;
+pub const SO_PEERGROUPS: c_int = 59;
+pub const SO_ZEROCOPY: c_int = 60;
+pub const SO_TXTIME: c_int = 61;
+pub const SCM_TXTIME: c_int = SO_TXTIME;
+pub const SO_BINDTOIFINDEX: c_int = 62;
+pub const SO_DETACH_REUSEPORT_BPF: c_int = 68;
+pub const SOL_SOCKET: c_int = 1;
+pub const SOL_RXRPC: c_int = 272;
+pub const SOL_PPPOL2TP: c_int = 273;
+pub const SOL_PNPIPE: c_int = 275;
+pub const SOL_RDS: c_int = 276;
+pub const SOL_IUCV: c_int = 277;
+pub const SOL_CAIF: c_int = 278;
+pub const SOL_NFC: c_int = 280;
+pub const SOL_KCM: c_int = 281;
+pub const SOL_TLS: c_int = 282;
+pub const SOL_XDP: c_int = 283;
+pub const SOMAXCONN: c_int = 128;
+pub const MSG_PROXY: c_int = 0x0010;
+pub const MSG_BATCH: c_int = 0x40000;
+pub const MSG_ZEROCOPY: c_int = 0x4000000;
+pub const INET_ADDRSTRLEN: c_int = 16;
+pub const INET6_ADDRSTRLEN: c_int = 46;
+pub const IPPORT_RESERVED: c_int = 1024;
+pub const IPPROTO_MAX: c_int = 256;
+pub const IPV6_JOIN_GROUP: c_int = 20;
+pub const IPV6_LEAVE_GROUP: c_int = 21;
+pub const IN_CLOEXEC: c_int = O_CLOEXEC;
+pub const IN_NONBLOCK: c_int = O_NONBLOCK;
+pub const TIOCEXCL: crate::Ioctl = 0x540C;
+pub const TIOCNXCL: crate::Ioctl = 0x540D;
+pub const SIOCPROTOPRIVATE: crate::Ioctl = 0x89E0;
+pub const SIOCGSTAMP: crate::Ioctl = 0x8906;
+pub const SIOCGIFNAME: crate::Ioctl = 0x8910;
+pub const SIOCGIFCONF: crate::Ioctl = 0x8912;
+pub const SIOCGIFFLAGS: crate::Ioctl = 0x8913;
+pub const SIOCSIFFLAGS: crate::Ioctl = 0x8914;
+pub const SIOCGIFADDR: crate::Ioctl = 0x8915;
+pub const SIOCGIFINDEX: crate::Ioctl = 0x8933;
+pub const SIOCATMARK: crate::Ioctl = 0x8905;
+pub const SIOCGIFHWADDR: crate::Ioctl = 0x8927;
+pub const SIOCGIFBRDADDR: crate::Ioctl = 0x8919;
+pub const SIOCGIFNETMASK: crate::Ioctl = 0x891B;
+pub const IPC_CREAT: c_int = 0o1000;
+pub const IPC_EXCL: c_int = 0o2000;
+pub const IPC_NOWAIT: c_int = 0o4000;
+pub const IPC_RMID: c_int = 0;
+pub const IPC_SET: c_int = 1;
+pub const IPC_STAT: c_int = 2;
+pub const IPC_INFO: c_int = 3;
+pub const PACKET_HOST: c_uchar = 0;
+pub const POLLWRNORM: c_short = 0x0100;
+pub const POLLWRBAND: c_short = 0x0200;
+pub const PTRACE_PEEKTEXT: c_int = 1;
+pub const PTRACE_PEEKDATA: c_int = 2;
+pub const PTRACE_PEEKUSER: c_int = 3;
+pub const PTRACE_POKETEXT: c_int = 4;
+pub const PTRACE_POKEDATA: c_int = 5;
+pub const PTRACE_POKEUSER: c_int = 6;
+pub const PTRACE_CONT: c_int = 7;
+pub const PTRACE_KILL: c_int = 8;
+pub const PTRACE_SINGLESTEP: c_int = 9;
+pub const PTRACE_GETREGS: c_int = 12;
+pub const PTRACE_SETREGS: c_int = 13;
+pub const PTRACE_GETFPREGS: c_int = 14;
+pub const PTRACE_SETFPREGS: c_int = 15;
+pub const PTRACE_ATTACH: c_int = 16;
+pub const PTRACE_DETACH: c_int = 17;
+pub const PTRACE_GETFPXREGS: c_int = 18;
+pub const PTRACE_SETFPXREGS: c_int = 19;
+pub const PTRACE_SYSCALL: c_int = 24;
+pub const PTRACE_SETOPTIONS: c_int = 0x4200;
+pub const PTRACE_GETEVENTMSG: c_int = 0x4201;
+pub const PTRACE_GETSIGINFO: c_int = 0x4202;
+pub const PTRACE_SETSIGINFO: c_int = 0x4203;
+pub const PTRACE_GETREGSET: c_int = 0x4204;
+pub const PTRACE_SETREGSET: c_int = 0x4205;
+pub const PTRACE_SEIZE: c_int = 0x4206;
+pub const PTRACE_INTERRUPT: c_int = 0x4207;
+pub const PTRACE_LISTEN: c_int = 0x4208;
+pub const PTRACE_PEEKSIGINFO: c_int = 0x4209;
+pub const PTRACE_GETSIGMASK: c_int = 0x420A;
+pub const PTRACE_SETSIGMASK: c_int = 0x420B;
+pub const PTRACE_SECCOMP_GET_FILTER: c_int = 0x420C;
+pub const PTRACE_EVENT_STOP: c_int = 128;
+pub const PTRACE_PEEKSIGINFO_SHARED: c_int = 1;
+pub const GRND_NONBLOCK: c_uint = 0x0001;
+pub const GRND_RANDOM: c_uint = 0x0002;
+pub const GRND_INSECURE: c_uint = 0x0004;
+pub const RB_AUTOBOOT: c_int = 0x01234567;
+pub const RB_HALT_SYSTEM: c_int = 0xcdef0123;
+pub const RB_ENABLE_CAD: c_int = 0x89abcdef;
+pub const RB_DISABLE_CAD: c_int = 0;
+pub const RB_POWER_OFF: c_int = 0x4321fedc;
+pub const RB_SW_SUSPEND: c_int = 0xd000fce2;
+pub const RB_KEXEC: c_int = 0x45584543;
+pub const PRIO_PROCESS: c_int = 0;
+pub const PRIO_PGRP: c_int = 1;
+pub const PRIO_USER: c_int = 2;
+pub const RUSAGE_CHILDREN: c_int = -1;
+pub const RLIMIT_CPU: c_int = 0;
+pub const RLIMIT_FSIZE: c_int = 1;
+pub const RLIMIT_DATA: c_int = 2;
+pub const RLIMIT_STACK: c_int = 3;
+pub const RLIMIT_CORE: c_int = 4;
+pub const RLIMIT_RSS: c_int = 5;
+pub const RLIMIT_NPROC: c_int = 6;
+pub const RLIMIT_NOFILE: c_int = 7;
+pub const RLIMIT_MEMLOCK: c_int = 8;
+pub const RLIMIT_AS: c_int = 9;
+pub const RLIMIT_LOCKS: c_int = 10;
+pub const RLIMIT_SIGPENDING: c_int = 11;
+pub const RLIMIT_MSGQUEUE: c_int = 12;
+pub const RLIMIT_NICE: c_int = 13;
+pub const RLIMIT_RTPRIO: c_int = 14;
+pub const RLIMIT_RTTIME: c_int = 15;
+pub const RLIMIT_NLIMITS: c_int = 16;
+pub const RTF_HOST: c_int = 0x0004;
+pub const RTF_REJECT: c_int = 0x0200;
+pub const SEEK_DATA: c_int = 3;
+pub const SEEK_HOLE: c_int = 4;
+pub const ITIMER_REAL: c_int = 0;
+pub const ITIMER_VIRTUAL: c_int = 1;
+pub const ITIMER_PROF: c_int = 2;
+pub const GETPID: c_int = 11;
+pub const GETVAL: c_int = 12;
+pub const GETALL: c_int = 13;
+pub const SETVAL: c_int = 16;
+pub const SETALL: c_int = 17;
+pub const SEM_UNDO: c_int = 0x1000;
+pub const _CS_PATH: c_int = 0;
+pub const _CS_V6_ENV: c_int = 1148;
+pub const _CS_V7_ENV: c_int = 1149;
+pub const F_LOCK: c_int = 1;
+pub const F_TEST: c_int = 2;
+pub const F_TLOCK: c_int = 3;
+pub const F_ULOCK: c_int = 4;
+pub const _PC_LINK_MAX: c_int = 0;
+pub const _PC_MAX_CANON: c_int = 1;
+pub const _PC_MAX_INPUT: c_int = 2;
+pub const _PC_NAME_MAX: c_int = 3;
+pub const _PC_PATH_MAX: c_int = 4;
+pub const _PC_PIPE_BUF: c_int = 5;
+pub const _PC_CHOWN_RESTRICTED: c_int = 6;
+pub const _PC_NO_TRUNC: c_int = 7;
+pub const _PC_VDISABLE: c_int = 8;
+pub const _PC_FILESIZEBITS: c_int = 9;
+pub const _PC_SYMLINK_MAX: c_int = 10;
+pub const _SC_ARG_MAX: c_int = 0;
+pub const _SC_CHILD_MAX: c_int = 1;
+pub const _SC_CLK_TCK: c_int = 2;
+pub const _SC_NGROUPS_MAX: c_int = 3;
+pub const _SC_OPEN_MAX: c_int = 4;
+pub const _SC_STREAM_MAX: c_int = 5;
+pub const _SC_TZNAME_MAX: c_int = 6;
+pub const _SC_JOB_CONTROL: c_int = 7;
+pub const _SC_SAVED_IDS: c_int = 8;
+pub const _SC_REALTIME_SIGNALS: c_int = 9;
+pub const _SC_PRIORITY_SCHEDULING: c_int = 10;
+pub const _SC_TIMERS: c_int = 11;
+pub const _SC_ASYNCHRONOUS_IO: c_int = 12;
+pub const _SC_PRIORITIZED_IO: c_int = 13;
+pub const _SC_SYNCHRONIZED_IO: c_int = 14;
+pub const _SC_FSYNC: c_int = 15;
+pub const _SC_MAPPED_FILES: c_int = 16;
+pub const _SC_MEMLOCK: c_int = 17;
+pub const _SC_MEMLOCK_RANGE: c_int = 18;
+pub const _SC_MEMORY_PROTECTION: c_int = 19;
+pub const _SC_MESSAGE_PASSING: c_int = 20;
+pub const _SC_SEMAPHORES: c_int = 21;
+pub const _SC_SHARED_MEMORY_OBJECTS: c_int = 22;
+pub const _SC_AIO_LISTIO_MAX: c_int = 23;
+pub const _SC_AIO_MAX: c_int = 24;
+pub const _SC_AIO_PRIO_DELTA_MAX: c_int = 25;
+pub const _SC_DELAYTIMER_MAX: c_int = 26;
+pub const _SC_MQ_OPEN_MAX: c_int = 27;
+pub const _SC_MQ_PRIO_MAX: c_int = 28;
+pub const _SC_VERSION: c_int = 29;
+pub const _SC_PAGE_SIZE: c_int = 30;
+pub const _SC_PAGESIZE: c_int = _SC_PAGE_SIZE;
+pub const _SC_RTSIG_MAX: c_int = 31;
+pub const _SC_SEM_NSEMS_MAX: c_int = 32;
+pub const _SC_SEM_VALUE_MAX: c_int = 33;
+pub const _SC_SIGQUEUE_MAX: c_int = 34;
+pub const _SC_TIMER_MAX: c_int = 35;
+pub const _SC_BC_BASE_MAX: c_int = 36;
+pub const _SC_BC_DIM_MAX: c_int = 37;
+pub const _SC_BC_SCALE_MAX: c_int = 38;
+pub const _SC_BC_STRING_MAX: c_int = 39;
+pub const _SC_COLL_WEIGHTS_MAX: c_int = 40;
+pub const _SC_EXPR_NEST_MAX: c_int = 42;
+pub const _SC_LINE_MAX: c_int = 43;
+pub const _SC_RE_DUP_MAX: c_int = 44;
+pub const _SC_2_VERSION: c_int = 46;
+pub const _SC_2_C_BIND: c_int = 47;
+pub const _SC_2_C_DEV: c_int = 48;
+pub const _SC_2_FORT_DEV: c_int = 49;
+pub const _SC_2_FORT_RUN: c_int = 50;
+pub const _SC_2_SW_DEV: c_int = 51;
+pub const _SC_2_LOCALEDEF: c_int = 52;
+pub const _SC_IOV_MAX: c_int = 60;
+pub const _SC_UIO_MAXIOV: c_int = _SC_IOV_MAX;
+pub const _SC_THREADS: c_int = 67;
+pub const _SC_THREAD_SAFE_FUNCTIONS: c_int = 68;
+pub const _SC_GETGR_R_SIZE_MAX: c_int = 69;
+pub const _SC_GETPW_R_SIZE_MAX: c_int = 70;
+pub const _SC_LOGIN_NAME_MAX: c_int = 71;
+pub const _SC_TTY_NAME_MAX: c_int = 72;
+pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: c_int = 73;
+pub const _SC_THREAD_KEYS_MAX: c_int = 74;
+pub const _SC_THREAD_STACK_MIN: c_int = 75;
+pub const _SC_THREAD_THREADS_MAX: c_int = 76;
+pub const _SC_THREAD_ATTR_STACKADDR: c_int = 77;
+pub const _SC_THREAD_ATTR_STACKSIZE: c_int = 78;
+pub const _SC_THREAD_PRIORITY_SCHEDULING: c_int = 79;
+pub const _SC_THREAD_PRIO_INHERIT: c_int = 80;
+pub const _SC_THREAD_PRIO_PROTECT: c_int = 81;
+pub const _SC_THREAD_PROCESS_SHARED: c_int = 82;
+pub const _SC_NPROCESSORS_CONF: c_int = 83;
+pub const _SC_NPROCESSORS_ONLN: c_int = 84;
+pub const _SC_PHYS_PAGES: c_int = 85;
+pub const _SC_AVPHYS_PAGES: c_int = 86;
+pub const _SC_ATEXIT_MAX: c_int = 87;
+pub const _SC_PASS_MAX: c_int = 88;
+pub const _SC_XOPEN_VERSION: c_int = 89;
+pub const _SC_XOPEN_XCU_VERSION: c_int = 90;
+pub const _SC_XOPEN_UNIX: c_int = 91;
+pub const _SC_XOPEN_CRYPT: c_int = 92;
+pub const _SC_XOPEN_ENH_I18N: c_int = 93;
+pub const _SC_XOPEN_SHM: c_int = 94;
+pub const _SC_2_CHAR_TERM: c_int = 95;
+pub const _SC_2_UPE: c_int = 97;
+pub const _SC_XOPEN_XPG2: c_int = 98;
+pub const _SC_XOPEN_XPG3: c_int = 99;
+pub const _SC_XOPEN_XPG4: c_int = 100;
+pub const _SC_NZERO: c_int = 109;
+pub const _SC_XBS5_ILP32_OFF32: c_int = 125;
+pub const _SC_XBS5_ILP32_OFFBIG: c_int = 126;
+pub const _SC_XBS5_LP64_OFF64: c_int = 127;
+pub const _SC_XBS5_LPBIG_OFFBIG: c_int = 128;
+pub const _SC_XOPEN_LEGACY: c_int = 129;
+pub const _SC_XOPEN_REALTIME: c_int = 130;
+pub const _SC_XOPEN_REALTIME_THREADS: c_int = 131;
+pub const _SC_ADVISORY_INFO: c_int = 132;
+pub const _SC_BARRIERS: c_int = 133;
+pub const _SC_CLOCK_SELECTION: c_int = 137;
+pub const _SC_CPUTIME: c_int = 138;
+pub const _SC_THREAD_CPUTIME: c_int = 139;
+pub const _SC_MONOTONIC_CLOCK: c_int = 149;
+pub const _SC_READER_WRITER_LOCKS: c_int = 153;
+pub const _SC_SPIN_LOCKS: c_int = 154;
+pub const _SC_REGEXP: c_int = 155;
+pub const _SC_SHELL: c_int = 157;
+pub const _SC_SPAWN: c_int = 159;
+pub const _SC_SPORADIC_SERVER: c_int = 160;
+pub const _SC_THREAD_SPORADIC_SERVER: c_int = 161;
+pub const _SC_TIMEOUTS: c_int = 164;
+pub const _SC_TYPED_MEMORY_OBJECTS: c_int = 165;
+pub const _SC_2_PBS: c_int = 168;
+pub const _SC_2_PBS_ACCOUNTING: c_int = 169;
+pub const _SC_2_PBS_LOCATE: c_int = 170;
+pub const _SC_2_PBS_MESSAGE: c_int = 171;
+pub const _SC_2_PBS_TRACK: c_int = 172;
+pub const _SC_SYMLOOP_MAX: c_int = 173;
+pub const _SC_STREAMS: c_int = 174;
+pub const _SC_2_PBS_CHECKPOINT: c_int = 175;
+pub const _SC_V6_ILP32_OFF32: c_int = 176;
+pub const _SC_V6_ILP32_OFFBIG: c_int = 177;
+pub const _SC_V6_LP64_OFF64: c_int = 178;
+pub const _SC_V6_LPBIG_OFFBIG: c_int = 179;
+pub const _SC_HOST_NAME_MAX: c_int = 180;
+pub const _SC_TRACE: c_int = 181;
+pub const _SC_TRACE_EVENT_FILTER: c_int = 182;
+pub const _SC_TRACE_INHERIT: c_int = 183;
+pub const _SC_TRACE_LOG: c_int = 184;
+pub const SHM_R: c_int = 0o400;
+pub const SHM_W: c_int = 0o200;
+pub const SHM_RDONLY: c_int = 0o10000;
+pub const SHM_RND: c_int = 0o20000;
+pub const SHM_REMAP: c_int = 0o40000;
+pub const SHM_EXEC: c_int = 0o100000;
+pub const SHM_LOCK: c_int = 11;
+pub const SHM_UNLOCK: c_int = 12;
+pub const SHM_STAT: c_int = 13;
+pub const SHM_INFO: c_int = 14;
+pub const SHM_STAT_ANY: c_int = 15;
+pub const SHM_DEST: c_int = 0o1000;
+pub const SHM_LOCKED: c_int = 0o2000;
+pub const SHM_HUGETLB: c_int = 0o4000;
+pub const SHM_NORESERVE: c_int = 0o10000;
+pub const TIME_UTC: c_int = 1;
+pub const POLL_IN: c_int = 1;
+pub const POLL_OUT: c_int = 2;
+pub const POLL_MSG: c_int = 3;
+pub const POLL_ERR: c_int = 4;
+pub const POLL_PRI: c_int = 5;
+pub const POLL_HUP: c_int = 6;
+pub const SA_NOCLDSTOP: c_ulong = 1;
+pub const SA_NOCLDWAIT: c_ulong = 2;
+pub const SA_SIGINFO: c_ulong = 4;
+pub const SA_ONSTACK: c_ulong = 0x08000000;
+pub const SA_RESTART: c_ulong = 0x10000000;
+pub const SA_NODEFER: c_ulong = 0x40000000;
+pub const SA_RESETHAND: c_ulong = 0x80000000;
+pub const SA_RESTORER: c_ulong = 0x04000000;
+pub const SA_NOMASK: c_ulong = SA_NODEFER;
+pub const SA_ONESHOT: c_ulong = SA_RESETHAND;
+pub const SIGPROF: c_int = 27;
+pub const SIGIO: c_int = 29;
+pub const SIGPWR: c_int = 30;
+pub const SIG_BLOCK: c_int = 0;
+pub const SIG_UNBLOCK: c_int = 1;
+pub const SIG_SETMASK: c_int = 2;
+pub const SIGBUS: c_int = 7;
+pub const SIGUSR1: c_int = 10;
+pub const SIGUSR2: c_int = 12;
+pub const SIGSTKFLT: c_int = 16;
+pub const SIGCHLD: c_int = 17;
+pub const SIGCONT: c_int = 18;
+pub const SIGSTOP: c_int = 19;
+pub const SIGTSTP: c_int = 20;
+pub const SIGTTIN: c_int = 21;
+pub const SIGTTOU: c_int = 22;
+pub const SIGURG: c_int = 23;
+pub const SIGXCPU: c_int = 24;
+pub const SIGXFSZ: c_int = 25;
+pub const SIGVTALRM: c_int = 26;
+pub const SIGWINCH: c_int = 28;
+pub const SIGPOLL: c_int = 29;
+pub const SIGSYS: c_int = 31;
+pub const SIGUNUSED: c_int = SIGSYS;
+pub const SIGCANCEL: c_int = 32;
+pub const SIGTIMER: c_int = 33;
+pub const MINSIGSTKSZ: usize = 2048;
+pub const SIGSTKSZ: usize = 8192;
+pub const SIGEV_THREAD_ID: c_int = 4;
+pub const SEGV_MAPERR: c_int = 1;
+pub const SEGV_ACCERR: c_int = 2;
+pub const ILL_ILLOPC: c_int = 1;
+pub const ILL_ILLOPN: c_int = 2;
+pub const ILL_ILLADR: c_int = 3;
+pub const ILL_ILLTRP: c_int = 4;
+pub const ILL_PRVOPC: c_int = 5;
+pub const ILL_PRVREG: c_int = 6;
+pub const ILL_COPROC: c_int = 7;
+pub const ILL_BADSTK: c_int = 8;
+pub const ILL_BADIADDR: c_int = 9;
+pub const CPU_SETSIZE: c_int = 1024;
+pub const __MLIBC_THREAD_MUTEX_DEFAULT: c_int = 0;
+pub const __MLIBC_THREAD_MUTEX_NORMAL: c_int = 0;
+pub const __MLIBC_THREAD_MUTEX_ERRORCHECK: c_int = 1;
+pub const __MLIBC_THREAD_MUTEX_RECURSIVE: c_int = 2;
+pub const __MLIBC_THREAD_PROCESS_PRIVATE: c_int = 0;
+pub const __MLIBC_THREAD_PROCESS_SHARED: c_int = 1;
+pub const __MLIBC_THREAD_MUTEX_STALLED: c_int = 0;
+pub const __MLIBC_THREAD_MUTEX_ROBUST: c_int = 1;
+pub const __MLIBC_THREAD_PRIO_NONE: c_int = 0;
+pub const __MLIBC_THREAD_PRIO_INHERIT: c_int = 1;
+pub const __MLIBC_THREAD_PRIO_PROTECT: c_int = 2;
+pub const ST_RDONLY: c_ulong = 1;
+pub const ST_NOSUID: c_ulong = 2;
+pub const ST_NODEV: c_ulong = 4;
+pub const ST_NOEXEC: c_ulong = 8;
+pub const ST_SYNCHRONOUS: c_ulong = 16;
+pub const ST_MANDLOCK: c_ulong = 64;
+pub const ST_WRITE: c_ulong = 128;
+pub const ST_APPEND: c_ulong = 256;
+pub const ST_IMMUTABLE: c_ulong = 512;
+pub const ST_NOATIME: c_ulong = 1024;
+pub const ST_NODIRATIME: c_ulong = 2048;
+pub const NCCS: usize = 32;
+pub const VEOF: usize = 4;
+pub const VTIME: usize = 5;
+pub const VMIN: usize = 6;
+pub const VSWTC: usize = 7;
+pub const VSTART: usize = 8;
+pub const VSTOP: usize = 9;
+pub const VSUSP: usize = 10;
+pub const VEOL: usize = 11;
+pub const VREPRINT: usize = 12;
+pub const VDISCARD: usize = 13;
+pub const VWERASE: usize = 14;
+pub const VEOL2: usize = 16;
+pub const IUCLC: crate::tcflag_t = 0o001000;
+pub const IXON: crate::tcflag_t = 0o002000;
+pub const IXOFF: crate::tcflag_t = 0o010000;
+pub const IUTF8: crate::tcflag_t = 0o040000;
+pub const OLCUC: crate::tcflag_t = 0o000002;
+pub const ONLCR: crate::tcflag_t = 0o000004;
+pub const NLDLY: crate::tcflag_t = 0o000400;
+pub const CRDLY: crate::tcflag_t = 0o003000;
+pub const CR1: crate::tcflag_t = 0o001000;
+pub const CR2: crate::tcflag_t = 0o002000;
+pub const CR3: crate::tcflag_t = 0o003000;
+pub const TABDLY: crate::tcflag_t = 0o014000;
+pub const TAB1: crate::tcflag_t = 0o004000;
+pub const TAB2: crate::tcflag_t = 0o010000;
+pub const TAB3: crate::tcflag_t = 0o014000;
+pub const BSDLY: crate::tcflag_t = 0o020000;
+pub const BS1: crate::tcflag_t = 0o020000;
+pub const FFDLY: crate::tcflag_t = 0o100000;
+pub const FF1: crate::tcflag_t = 0o100000;
+pub const VTDLY: crate::tcflag_t = 0o040000;
+pub const VT1: crate::tcflag_t = 0o040000;
+pub const CSIZE: crate::tcflag_t = 0o000060;
+pub const CS6: crate::tcflag_t = 0o000020;
+pub const CS7: crate::tcflag_t = 0o000040;
+pub const CS8: crate::tcflag_t = 0o000060;
+pub const CSTOPB: crate::tcflag_t = 0o000100;
+pub const CREAD: crate::tcflag_t = 0o000200;
+pub const PARENB: crate::tcflag_t = 0o000400;
+pub const PARODD: crate::tcflag_t = 0o001000;
+pub const HUPCL: crate::tcflag_t = 0o002000;
+pub const CLOCAL: crate::tcflag_t = 0o004000;
+pub const ISIG: crate::tcflag_t = 0o000001;
+pub const ICANON: crate::tcflag_t = 0o000002;
+pub const ECHOE: crate::tcflag_t = 0o000020;
+pub const ECHOK: crate::tcflag_t = 0o000040;
+pub const ECHONL: crate::tcflag_t = 0o000100;
+pub const NOFLSH: crate::tcflag_t = 0o000200;
+pub const TOSTOP: crate::tcflag_t = 0o000400;
+pub const IEXTEN: crate::tcflag_t = 0o100000;
+pub const EXTA: crate::speed_t = 0o000016;
+pub const EXTB: crate::speed_t = 0o000017;
+pub const CBAUD: crate::tcflag_t = 0o010017;
+pub const CBAUDEX: crate::tcflag_t = 0o010000;
+pub const CIBAUD: crate::tcflag_t = 0o02003600000;
+pub const CMSPAR: crate::tcflag_t = 0o10000000000;
+pub const XCASE: crate::tcflag_t = 0o000004;
+pub const ECHOCTL: crate::tcflag_t = 0o001000;
+pub const ECHOPRT: crate::tcflag_t = 0o002000;
+pub const ECHOKE: crate::tcflag_t = 0o004000;
+pub const FLUSHO: crate::tcflag_t = 0o010000;
+pub const PENDIN: crate::tcflag_t = 0o040000;
+pub const EXTPROC: crate::tcflag_t = 0o200000;
+pub const XTABS: crate::tcflag_t = 0o014000;
+pub const EMPTY: c_short = 0;
+pub const RUN_LVL: c_short = 1;
+pub const BOOT_TIME: c_short = 2;
+pub const NEW_TIME: c_short = 3;
+pub const OLD_TIME: c_short = 4;
+pub const INIT_PROCESS: c_short = 5;
+pub const LOGIN_PROCESS: c_short = 6;
+pub const USER_PROCESS: c_short = 7;
+pub const DEAD_PROCESS: c_short = 8;
+pub const ACCOUNTING: c_short = 9;
+pub const __UT_HOSTSIZE: usize = 256;
+pub const __UT_NAMESIZE: usize = 32;
+pub const __UT_LINESIZE: usize = 32;
+pub const MAP_ANON: c_int = 0x20;
+pub const MAP_ANONYMOUS: c_int = 0x20;
+pub const MAP_GROWSDOWN: c_int = 0x100;
+pub const MAP_DENYWRITE: c_int = 0x800;
+pub const MAP_EXECUTABLE: c_int = 0x1000;
+pub const MAP_LOCKED: c_int = 0x2000;
+pub const MAP_NORESERVE: c_int = 0x4000;
+pub const MAP_POPULATE: c_int = 0x8000;
+pub const MAP_NONBLOCK: c_int = 0x10000;
+pub const MAP_STACK: c_int = 0x20000;
+pub const MAP_HUGETLB: c_int = 0x40000;
+pub const MAP_SYNC: c_int = 0x80000;
+pub const MAP_FIXED_NOREPLACE: c_int = 0x100000;
+pub const MCL_CURRENT: c_int = 0x01;
+pub const MCL_FUTURE: c_int = 0x02;
+pub const POSIX_MADV_NORMAL: c_int = 0;
+pub const POSIX_MADV_RANDOM: c_int = 1;
+pub const POSIX_MADV_SEQUENTIAL: c_int = 2;
+pub const POSIX_MADV_WILLNEED: c_int = 3;
+pub const POSIX_MADV_DONTNEED: c_int = 4;
+pub const MADV_SOFT_OFFLINE: c_int = 101;
+pub const MREMAP_MAYMOVE: c_int = 1;
+pub const MREMAP_FIXED: c_int = 2;
+pub const MFD_CLOEXEC: c_uint = 1;
+pub const MFD_ALLOW_SEALING: c_uint = 2;
+pub const MFD_HUGETLB: c_uint = 4;
+pub const PTHREAD_STACK_MIN: usize = 16384;
+pub const PTHREAD_KEYS_MAX: c_int = 1024;
+pub const CLONE_PIDFD: c_int = 0x00001000;
+pub const CLONE_CLEAR_SIGHAND: c_ulonglong = 0x100000000;
+pub const CLONE_INTO_CGROUP: c_ulonglong = 0x200000000;
+pub const UT_LINESIZE: usize = 32;
+pub const UT_NAMESIZE: usize = 32;
+pub const UT_HOSTSIZE: usize = 256;
+pub const LC_PAPER: c_int = 7;
+pub const LC_NAME: c_int = 8;
+pub const LC_ADDRESS: c_int = 9;
+pub const LC_TELEPHONE: c_int = 10;
+pub const LC_MEASUREMENT: c_int = 11;
+pub const LC_IDENTIFICATION: c_int = 12;
+pub const LC_PAPER_MASK: c_int = 1 << LC_PAPER;
+pub const LC_NAME_MASK: c_int = 1 << LC_NAME;
+pub const LC_ADDRESS_MASK: c_int = 1 << LC_ADDRESS;
+pub const LC_TELEPHONE_MASK: c_int = 1 << LC_TELEPHONE;
+pub const LC_MEASUREMENT_MASK: c_int = 1 << LC_MEASUREMENT;
+pub const LC_IDENTIFICATION_MASK: c_int = 1 << LC_IDENTIFICATION;
+pub const LC_ALL_MASK: c_int = LC_CTYPE_MASK
+    | LC_NUMERIC_MASK
+    | LC_TIME_MASK
+    | LC_COLLATE_MASK
+    | LC_MONETARY_MASK
+    | LC_MESSAGES_MASK
+    | LC_PAPER_MASK
+    | LC_NAME_MASK
+    | LC_ADDRESS_MASK
+    | LC_TELEPHONE_MASK
+    | LC_MEASUREMENT_MASK
+    | LC_IDENTIFICATION_MASK;
+pub const FPE_INTDIV: c_int = 1;
+pub const FPE_INTOVF: c_int = 2;
+pub const FPE_FLTDIV: c_int = 3;
+pub const FPE_FLTOVF: c_int = 4;
+pub const FPE_FLTUND: c_int = 5;
+pub const FPE_FLTRES: c_int = 6;
+pub const FPE_FLTINV: c_int = 7;
+pub const FPE_FLTSUB: c_int = 8;
+pub const DT_WHT: c_int = 14;
+pub const O_NDELAY: c_int = O_NONBLOCK;
+pub const FALLOC_FL_KEEP_SIZE: c_int = 1;
+pub const FALLOC_FL_PUNCH_HOLE: c_int = 2;
+pub const GLOB_APPEND: c_int = 0x01;
+pub const GLOB_DOOFFS: c_int = 0x02;
+pub const GLOB_ERR: c_int = 0x04;
+pub const GLOB_MARK: c_int = 0x08;
+pub const GLOB_NOCHECK: c_int = 0x10;
+pub const GLOB_NOESCAPE: c_int = 0x20;
+pub const GLOB_NOSORT: c_int = 0x40;
+pub const GLOB_PERIOD: c_int = 0x80;
+pub const GLOB_TILDE: c_int = 0x100;
+pub const GLOB_TILDE_CHECK: c_int = 0x200;
+pub const GLOB_BRACE: c_int = 0x400;
+pub const GLOB_NOMAGIC: c_int = 0x800;
+pub const GLOB_ALTDIRFUNC: c_int = 0x1000;
+pub const GLOB_ONLYDIR: c_int = 0x2000;
+pub const GLOB_MAGCHAR: c_int = 0x4000;
+pub const GLOB_ABORTED: c_int = 1;
+pub const GLOB_NOMATCH: c_int = 2;
+pub const GLOB_NOSPACE: c_int = 3;
+pub const GLOB_NOSYS: c_int = 4;
+pub const BUFSIZ: c_int = 512;
+pub const FOPEN_MAX: c_int = 1024;
+pub const FILENAME_MAX: c_int = 256;
+pub const L_tmpnam: c_int = 256;
+pub const TMP_MAX: c_int = 1024;
+pub const IFF_LOWER_UP: c_int = 0x10000;
+pub const IFF_DORMANT: c_int = 0x20000;
+pub const IFF_ECHO: c_int = 0x40000;
+pub const AI_PASSIVE: c_int = 0x01;
+pub const AI_CANONNAME: c_int = 0x02;
+pub const AI_NUMERICHOST: c_int = 0x04;
+pub const AI_V4MAPPED: c_int = 0x08;
+pub const AI_ALL: c_int = 0x10;
+pub const AI_ADDRCONFIG: c_int = 0x20;
+pub const AI_NUMERICSERV: c_int = 0x40;
+pub const NI_NOFQDN: c_int = 0x01;
+pub const NI_NUMERICHOST: c_int = 0x02;
+pub const NI_NAMEREQD: c_int = 0x04;
+pub const NI_NUMERICSCOPE: c_int = 0x08;
+pub const NI_DGRAM: c_int = 0x10;
+pub const NI_NUMERICSERV: c_int = 2;
+pub const NI_MAXSERV: c_int = 32;
+pub const NI_IDN: c_int = 32;
+pub const NI_IDN_USE_STD3_ASCII_RULES: c_int = 128;
+pub const NI_MAXHOST: c_int = 1025;
+pub const EAI_AGAIN: c_int = 1;
+pub const EAI_BADFLAGS: c_int = 2;
+pub const EAI_FAIL: c_int = 3;
+pub const EAI_FAMILY: c_int = 4;
+pub const EAI_MEMORY: c_int = 5;
+pub const EAI_NONAME: c_int = 6;
+pub const EAI_SERVICE: c_int = 7;
+pub const EAI_SOCKTYPE: c_int = 8;
+pub const EAI_SYSTEM: c_int = 9;
+pub const EAI_OVERFLOW: c_int = 10;
+pub const EAI_NODATA: c_int = 11;
+pub const EAI_ADDRFAMILY: c_int = 12;
+pub const ETH_ALEN: c_int = 6;
+pub const ETH_HLEN: c_int = 14;
+pub const ETH_ZLEN: c_int = 60;
+pub const ETH_FRAME_LEN: c_int = 1514;
+pub const ETH_FCS_LEN: c_int = 4;
+pub const ETH_P_LOOP: c_int = 0x0060;
+pub const ETH_P_PUP: c_int = 0x0200;
+pub const ETH_P_PUPAT: c_int = 0x0201;
+pub const ETH_P_IP: c_int = 0x0800;
+pub const ETH_P_X25: c_int = 0x0805;
+pub const ETH_P_ARP: c_int = 0x0806;
+pub const ETH_P_BPQ: c_int = 0x08FF;
+pub const ETH_P_IEEEPUP: c_int = 0x0a00;
+pub const ETH_P_IEEEPUPAT: c_int = 0x0a01;
+pub const ETH_P_BATMAN: c_int = 0x4305;
+pub const ETH_P_DEC: c_int = 0x6000;
+pub const ETH_P_DNA_DL: c_int = 0x6001;
+pub const ETH_P_DNA_RC: c_int = 0x6002;
+pub const ETH_P_DNA_RT: c_int = 0x6003;
+pub const ETH_P_LAT: c_int = 0x6004;
+pub const ETH_P_DIAG: c_int = 0x6005;
+pub const ETH_P_CUST: c_int = 0x6006;
+pub const ETH_P_SCA: c_int = 0x6007;
+pub const ETH_P_TEB: c_int = 0x6558;
+pub const ETH_P_RARP: c_int = 0x8035;
+pub const ETH_P_ATALK: c_int = 0x809B;
+pub const ETH_P_AARP: c_int = 0x80F3;
+pub const ETH_P_8021Q: c_int = 0x8100;
+pub const ETH_P_IPX: c_int = 0x8137;
+pub const ETH_P_IPV6: c_int = 0x86DD;
+pub const ETH_P_PAUSE: c_int = 0x8808;
+pub const ETH_P_SLOW: c_int = 0x8809;
+pub const ETH_P_WCCP: c_int = 0x883E;
+pub const ETH_P_MPLS_UC: c_int = 0x8847;
+pub const ETH_P_MPLS_MC: c_int = 0x8848;
+pub const ETH_P_ATMMPOA: c_int = 0x884c;
+pub const ETH_P_PPP_DISC: c_int = 0x8863;
+pub const ETH_P_PPP_SES: c_int = 0x8864;
+pub const ETH_P_LINK_CTL: c_int = 0x886c;
+pub const ETH_P_ATMFATE: c_int = 0x8884;
+pub const ETH_P_PAE: c_int = 0x888E;
+pub const ETH_P_AOE: c_int = 0x88A2;
+pub const ETH_P_8021AD: c_int = 0x88A8;
+pub const ETH_P_802_EX1: c_int = 0x88B5;
+pub const ETH_P_TIPC: c_int = 0x88CA;
+pub const ETH_P_8021AH: c_int = 0x88E7;
+pub const ETH_P_MVRP: c_int = 0x88F5;
+pub const ETH_P_1588: c_int = 0x88F7;
+pub const ETH_P_PRP: c_int = 0x88FB;
+pub const ETH_P_FCOE: c_int = 0x8906;
+pub const ETH_P_TDLS: c_int = 0x890D;
+pub const ETH_P_FIP: c_int = 0x8914;
+pub const ETH_P_80221: c_int = 0x8917;
+pub const ETH_P_LOOPBACK: c_int = 0x9000;
+pub const ETH_P_QINQ1: c_int = 0x9100;
+pub const ETH_P_QINQ2: c_int = 0x9200;
+pub const ETH_P_QINQ3: c_int = 0x9300;
+pub const ETH_P_EDSA: c_int = 0xDADA;
+pub const ETH_P_AF_IUCV: c_int = 0xFBFB;
+pub const ETH_P_802_3_MIN: c_int = 0x0600;
+pub const ETH_P_802_3: c_int = 0x0001;
+pub const ETH_P_AX25: c_int = 0x0002;
+pub const ETH_P_ALL: c_int = 0x0003;
+pub const ETH_P_802_2: c_int = 0x0004;
+pub const ETH_P_SNAP: c_int = 0x0005;
+pub const ETH_P_DDCMP: c_int = 0x0006;
+pub const ETH_P_WAN_PPP: c_int = 0x0007;
+pub const ETH_P_PPP_MP: c_int = 0x0008;
+pub const ETH_P_LOCALTALK: c_int = 0x0009;
+pub const ETH_P_CAN: c_int = 0x000C;
+pub const ETH_P_CANFD: c_int = 0x000D;
+pub const ETH_P_PPPTALK: c_int = 0x0010;
+pub const ETH_P_TR_802_2: c_int = 0x0011;
+pub const ETH_P_MOBITEX: c_int = 0x0015;
+pub const ETH_P_CONTROL: c_int = 0x0016;
+pub const ETH_P_IRDA: c_int = 0x0017;
+pub const ETH_P_ECONET: c_int = 0x0018;
+pub const ETH_P_HDLC: c_int = 0x0019;
+pub const ETH_P_ARCNET: c_int = 0x001A;
+pub const ETH_P_DSA: c_int = 0x001B;
+pub const ETH_P_TRAILER: c_int = 0x001C;
+pub const ETH_P_PHONET: c_int = 0x00F5;
+pub const ETH_P_IEEE802154: c_int = 0x00F6;
+pub const ETH_P_CAIF: c_int = 0x00F7;
+pub const PACKET_BROADCAST: c_int = 1;
+pub const PACKET_MULTICAST: c_int = 2;
+pub const PACKET_OTHERHOST: c_int = 3;
+pub const PACKET_OUTGOING: c_int = 4;
+pub const PACKET_LOOPBACK: c_int = 5;
+pub const PACKET_FASTROUTE: c_int = 6;
+pub const PACKET_ADD_MEMBERSHIP: c_int = 1;
+pub const PACKET_DROP_MEMBERSHIP: c_int = 2;
+pub const PACKET_MR_MULTICAST: c_int = 0;
+pub const PACKET_MR_PROMISC: c_int = 1;
+pub const PACKET_MR_ALLMULTI: c_int = 2;
+pub const PACKET_MR_UNICAST: c_int = 3;
+pub const SCHED_OTHER: c_int = 0;
+pub const SCHED_FIFO: c_int = 1;
+pub const SCHED_RR: c_int = 2;
+pub const SCHED_BATCH: c_int = 3;
+pub const SCHED_IDLE: c_int = 5;
+pub const SCHED_DEADLINE: c_int = 6;
+pub const SCHED_RESET_ON_FORK: c_int = 0x40000000;
+pub const PTHREAD_INHERIT_SCHED: c_int = 0;
+pub const PTHREAD_EXPLICIT_SCHED: c_int = 1;
+pub const PTHREAD_MUTEX_DEFAULT: c_int = __MLIBC_THREAD_MUTEX_DEFAULT;
+pub const PTHREAD_MUTEX_NORMAL: c_int = __MLIBC_THREAD_MUTEX_NORMAL;
+pub const PTHREAD_MUTEX_ERRORCHECK: c_int = __MLIBC_THREAD_MUTEX_ERRORCHECK;
+pub const PTHREAD_MUTEX_RECURSIVE: c_int = __MLIBC_THREAD_MUTEX_RECURSIVE;
+pub const PTHREAD_MUTEX_STALLED: c_int = __MLIBC_THREAD_MUTEX_STALLED;
+pub const PTHREAD_MUTEX_ROBUST: c_int = __MLIBC_THREAD_MUTEX_ROBUST;
+pub const PTHREAD_PROCESS_PRIVATE: c_int = __MLIBC_THREAD_PROCESS_PRIVATE;
+pub const PTHREAD_PROCESS_SHARED: c_int = __MLIBC_THREAD_PROCESS_SHARED;
+pub const PTHREAD_PRIO_NONE: c_int = __MLIBC_THREAD_PRIO_NONE;
+pub const PTHREAD_PRIO_INHERIT: c_int = __MLIBC_THREAD_PRIO_INHERIT;
+pub const PTHREAD_PRIO_PROTECT: c_int = __MLIBC_THREAD_PRIO_PROTECT;
+pub const PTHREAD_BARRIER_SERIAL_THREAD: c_int = -1;
+pub const NSS_BUFLEN_PASSWD: c_int = 512;
+pub const REG_EXTENDED: c_int = 1;
+pub const REG_ICASE: c_int = 2;
+pub const REG_NEWLINE: c_int = 4;
+pub const REG_NOSUB: c_int = 8;
+pub const REG_NOTBOL: c_int = 1;
+pub const REG_NOTEOL: c_int = 2;
+pub const REG_OK: c_int = 0;
+pub const REG_NOMATCH: c_int = 1;
+pub const REG_BADPAT: c_int = 2;
+pub const REG_ECOLLATE: c_int = 3;
+pub const REG_ECTYPE: c_int = 4;
+pub const REG_EESCAPE: c_int = 5;
+pub const REG_ESUBREG: c_int = 6;
+pub const REG_EBRACK: c_int = 7;
+pub const REG_EPAREN: c_int = 8;
+pub const REG_EBRACE: c_int = 9;
+pub const REG_BADBR: c_int = 10;
+pub const REG_ERANGE: c_int = 11;
+pub const REG_ESPACE: c_int = 12;
+pub const REG_BADRPT: c_int = 13;
+pub const REG_ENOSYS: c_int = -1;
+pub const POSIX_SPAWN_RESETIDS: c_int = 1;
+pub const POSIX_SPAWN_SETPGROUP: c_int = 2;
+pub const POSIX_SPAWN_SETSIGDEF: c_int = 4;
+pub const POSIX_SPAWN_SETSIGMASK: c_int = 8;
+pub const POSIX_SPAWN_SETSCHEDPARAM: c_int = 16;
+pub const POSIX_SPAWN_SETSCHEDULER: c_int = 32;
+pub const POSIX_SPAWN_USEVFORK: c_int = 64;
+pub const POSIX_SPAWN_SETSID: c_int = 128;
+pub const EPOLL_NONBLOCK: c_int = O_NONBLOCK;
+pub const EFD_SEMAPHORE: c_int = 1;
+pub const EFD_CLOEXEC: c_int = O_CLOEXEC;
+pub const EFD_NONBLOCK: c_int = O_NONBLOCK;
+pub const IN_ACCESS: c_int = 0x1;
+pub const IN_ATTRIB: c_int = 0x4;
+pub const IN_CLOSE_WRITE: c_int = 0x8;
+pub const IN_CLOSE_NOWRITE: c_int = 0x10;
+pub const IN_CREATE: c_int = 0x100;
+pub const IN_DELETE: c_int = 0x200;
+pub const IN_DELETE_SELF: c_int = 0x400;
+pub const IN_MODIFY: c_int = 0x2;
+pub const IN_MOVE_SELF: c_int = 0x800;
+pub const IN_MOVED_FROM: c_int = 0x40;
+pub const IN_MOVED_TO: c_int = 0x80;
+pub const IN_OPEN: c_int = 0x20;
+pub const IN_MOVE: c_int = IN_MOVED_FROM | IN_MOVED_TO;
+pub const IN_CLOSE: c_int = IN_CLOSE_WRITE | IN_CLOSE_NOWRITE;
+pub const IN_DONT_FOLLOW: c_int = 0x2000000;
+pub const IN_EXCL_UNLINK: c_int = 0x4000000;
+pub const IN_MASK_ADD: c_int = 0x20000000;
+pub const IN_ONESHOT: c_int = 0x80000000;
+pub const IN_ONLYDIR: c_int = 0x1000000;
+pub const IN_IGNORED: c_int = 0x8000;
+pub const IN_ISDIR: c_int = 0x40000000;
+pub const IN_Q_OVERFLOW: c_int = 0x4000;
+pub const IN_UNMOUNT: c_int = 0x2000;
+pub const IN_ALL_EVENTS: c_int = IN_ACCESS
+    | IN_MODIFY
+    | IN_ATTRIB
+    | IN_CLOSE_WRITE
+    | IN_CLOSE_NOWRITE
+    | IN_OPEN
+    | IN_MOVED_FROM
+    | IN_MOVED_TO
+    | IN_DELETE
+    | IN_CREATE
+    | IN_DELETE_SELF
+    | IN_MOVE_SELF;
+pub const TIOCMGET: crate::Ioctl = 0x5415;
+pub const TIOCMBIS: crate::Ioctl = 0x5416;
+pub const TIOCMBIC: crate::Ioctl = 0x5417;
+pub const FIONREAD: crate::Ioctl = 0x541B;
+pub const FIONBIO: crate::Ioctl = 0x5421;
+pub const FIONCLEX: crate::Ioctl = 0x5450;
+pub const FIOCLEX: crate::Ioctl = 0x5451;
+pub const SIOCGIFMTU: crate::Ioctl = 0x8921;
+pub const SIOCSIFMTU: crate::Ioctl = 0x8922;
+pub const SIOCDEVPRIVATE: crate::Ioctl = 0x89F0;
+pub const PIDFD_NONBLOCK: c_int = O_NONBLOCK;
+pub const PR_SET_PDEATHSIG: c_int = 1;
+pub const PR_GET_PDEATHSIG: c_int = 2;
+pub const PR_GET_DUMPABLE: c_int = 3;
+pub const PR_SET_DUMPABLE: c_int = 4;
+pub const PR_GET_UNALIGN: c_int = 5;
+pub const PR_SET_UNALIGN: c_int = 6;
+pub const PR_UNALIGN_NOPRINT: c_int = 1;
+pub const PR_UNALIGN_SIGBUS: c_int = 2;
+pub const PR_GET_KEEPCAPS: c_int = 7;
+pub const PR_SET_KEEPCAPS: c_int = 8;
+pub const PR_GET_FPEMU: c_int = 9;
+pub const PR_SET_FPEMU: c_int = 10;
+pub const PR_FPEMU_NOPRINT: c_int = 1;
+pub const PR_FPEMU_SIGFPE: c_int = 2;
+pub const PR_GET_FPEXC: c_int = 11;
+pub const PR_SET_FPEXC: c_int = 12;
+pub const PR_FP_EXC_SW_ENABLE: c_int = 0x80;
+pub const PR_FP_EXC_DIV: c_int = 0x010000;
+pub const PR_FP_EXC_OVF: c_int = 0x020000;
+pub const PR_FP_EXC_UND: c_int = 0x040000;
+pub const PR_FP_EXC_RES: c_int = 0x080000;
+pub const PR_FP_EXC_INV: c_int = 0x100000;
+pub const PR_FP_EXC_DISABLED: c_int = 0;
+pub const PR_FP_EXC_NONRECOV: c_int = 1;
+pub const PR_FP_EXC_ASYNC: c_int = 2;
+pub const PR_FP_EXC_PRECISE: c_int = 3;
+pub const PR_GET_TIMING: c_int = 13;
+pub const PR_SET_TIMING: c_int = 14;
+pub const PR_TIMING_STATISTICAL: c_int = 0;
+pub const PR_TIMING_TIMESTAMP: c_int = 1;
+pub const PR_SET_NAME: c_int = 15;
+pub const PR_GET_NAME: c_int = 16;
+pub const PR_GET_ENDIAN: c_int = 19;
+pub const PR_SET_ENDIAN: c_int = 20;
+pub const PR_ENDIAN_BIG: c_int = 0;
+pub const PR_ENDIAN_LITTLE: c_int = 1;
+pub const PR_ENDIAN_PPC_LITTLE: c_int = 2;
+pub const PR_GET_SECCOMP: c_int = 21;
+pub const PR_SET_SECCOMP: c_int = 22;
+pub const PR_CAPBSET_READ: c_int = 23;
+pub const PR_CAPBSET_DROP: c_int = 24;
+pub const PR_GET_TSC: c_int = 25;
+pub const PR_SET_TSC: c_int = 26;
+pub const PR_TSC_ENABLE: c_int = 1;
+pub const PR_TSC_SIGSEGV: c_int = 2;
+pub const PR_GET_SECUREBITS: c_int = 27;
+pub const PR_SET_SECUREBITS: c_int = 28;
+pub const PR_SET_TIMERSLACK: c_int = 29;
+pub const PR_GET_TIMERSLACK: c_int = 30;
+pub const PR_TASK_PERF_EVENTS_DISABLE: c_int = 31;
+pub const PR_TASK_PERF_EVENTS_ENABLE: c_int = 32;
+pub const PR_MCE_KILL: c_int = 33;
+pub const PR_MCE_KILL_CLEAR: c_int = 0;
+pub const PR_MCE_KILL_SET: c_int = 1;
+pub const PR_MCE_KILL_LATE: c_int = 0;
+pub const PR_MCE_KILL_EARLY: c_int = 1;
+pub const PR_MCE_KILL_DEFAULT: c_int = 2;
+pub const PR_MCE_KILL_GET: c_int = 34;
+pub const PR_SET_MM: c_int = 35;
+pub const PR_SET_MM_START_CODE: c_int = 1;
+pub const PR_SET_MM_END_CODE: c_int = 2;
+pub const PR_SET_MM_START_DATA: c_int = 3;
+pub const PR_SET_MM_END_DATA: c_int = 4;
+pub const PR_SET_MM_START_STACK: c_int = 5;
+pub const PR_SET_MM_START_BRK: c_int = 6;
+pub const PR_SET_MM_BRK: c_int = 7;
+pub const PR_SET_MM_ARG_START: c_int = 8;
+pub const PR_SET_MM_ARG_END: c_int = 9;
+pub const PR_SET_MM_ENV_START: c_int = 10;
+pub const PR_SET_MM_ENV_END: c_int = 11;
+pub const PR_SET_MM_AUXV: c_int = 12;
+pub const PR_SET_MM_EXE_FILE: c_int = 13;
+pub const PR_SET_MM_MAP: c_int = 14;
+pub const PR_SET_MM_MAP_SIZE: c_int = 15;
+pub const PR_SET_PTRACER: c_int = 0x59616d61;
+pub const PR_SET_CHILD_SUBREAPER: c_int = 36;
+pub const PR_GET_CHILD_SUBREAPER: c_int = 37;
+pub const PR_SET_NO_NEW_PRIVS: c_int = 38;
+pub const PR_GET_NO_NEW_PRIVS: c_int = 39;
+pub const PR_GET_TID_ADDRESS: c_int = 40;
+pub const PR_SET_THP_DISABLE: c_int = 41;
+pub const PR_GET_THP_DISABLE: c_int = 42;
+pub const PR_MPX_ENABLE_MANAGEMENT: c_int = 43;
+pub const PR_MPX_DISABLE_MANAGEMENT: c_int = 44;
+pub const PR_SET_FP_MODE: c_int = 45;
+pub const PR_GET_FP_MODE: c_int = 46;
+pub const PR_FP_MODE_FR: c_int = 1 << 0;
+pub const PR_FP_MODE_FRE: c_int = 1 << 1;
+pub const PR_CAP_AMBIENT: c_int = 47;
+pub const PR_CAP_AMBIENT_IS_SET: c_int = 1;
+pub const PR_CAP_AMBIENT_RAISE: c_int = 2;
+pub const PR_CAP_AMBIENT_LOWER: c_int = 3;
+pub const PR_CAP_AMBIENT_CLEAR_ALL: c_int = 4;
+pub const PTRACE_TRACEME: c_int = 0;
+pub const PT_TRACE_ME: c_int = PTRACE_TRACEME;
+pub const PT_READ_I: c_int = PTRACE_PEEKTEXT;
+pub const PT_READ_D: c_int = PTRACE_PEEKDATA;
+pub const PT_READ_U: c_int = PTRACE_PEEKUSER;
+pub const PT_WRITE_I: c_int = PTRACE_POKETEXT;
+pub const PT_WRITE_D: c_int = PTRACE_POKEDATA;
+pub const PT_WRITE_U: c_int = PTRACE_POKEUSER;
+pub const PT_CONTINUE: c_int = PTRACE_CONT;
+pub const PT_KILL: c_int = PTRACE_KILL;
+pub const PT_STEP: c_int = PTRACE_SINGLESTEP;
+pub const PT_GETREGS: c_int = PTRACE_GETREGS;
+pub const PT_SETREGS: c_int = PTRACE_SETREGS;
+pub const PT_GETFPREGS: c_int = PTRACE_GETFPREGS;
+pub const PT_SETFPREGS: c_int = PTRACE_SETFPREGS;
+pub const PT_ATTACH: c_int = PTRACE_ATTACH;
+pub const PT_DETACH: c_int = PTRACE_DETACH;
+pub const PT_GETFPXREGS: c_int = PTRACE_GETFPXREGS;
+pub const PT_SETFPXREGS: c_int = PTRACE_SETFPXREGS;
+pub const PT_SYSCALL: c_int = PTRACE_SYSCALL;
+pub const PT_SETOPTIONS: c_int = PTRACE_SETOPTIONS;
+pub const PT_GETEVENTMSG: c_int = PTRACE_GETEVENTMSG;
+pub const PT_GETSIGINFO: c_int = PTRACE_GETSIGINFO;
+pub const PT_SETSIGINFO: c_int = PTRACE_SETSIGINFO;
+pub const RLIM_NLIMITS: c_int = RLIMIT_NLIMITS;
+pub const SFD_CLOEXEC: c_int = O_CLOEXEC;
+pub const SFD_NONBLOCK: c_int = O_NONBLOCK;
+pub const B0: crate::speed_t = 0;
+pub const B50: crate::speed_t = 1;
+pub const B75: crate::speed_t = 2;
+pub const B110: crate::speed_t = 3;
+pub const B134: crate::speed_t = 4;
+pub const B150: crate::speed_t = 5;
+pub const B200: crate::speed_t = 6;
+pub const B300: crate::speed_t = 7;
+pub const B600: crate::speed_t = 8;
+pub const B1200: crate::speed_t = 9;
+pub const B1800: crate::speed_t = 10;
+pub const B2400: crate::speed_t = 11;
+pub const B4800: crate::speed_t = 12;
+pub const B9600: crate::speed_t = 13;
+pub const B19200: crate::speed_t = 14;
+pub const B38400: crate::speed_t = 15;
+pub const B57600: crate::speed_t = 0o010001;
+pub const B115200: crate::speed_t = 0o010002;
+pub const B230400: crate::speed_t = 0o010003;
+pub const B460800: crate::speed_t = 0o010004;
+pub const B500000: crate::speed_t = 0o010005;
+pub const B576000: crate::speed_t = 0o010006;
+pub const B921600: crate::speed_t = 0o010007;
+pub const B1000000: crate::speed_t = 0o010010;
+pub const B1152000: crate::speed_t = 0o010011;
+pub const B1500000: crate::speed_t = 0o010012;
+pub const B2000000: crate::speed_t = 0o010013;
+pub const B2500000: crate::speed_t = 0o010014;
+pub const B3000000: crate::speed_t = 0o010015;
+pub const B3500000: crate::speed_t = 0o010016;
+pub const B4000000: crate::speed_t = 0o010017;
+pub const TCSANOW: c_int = 0;
+pub const TCSADRAIN: c_int = 1;
+pub const TCSAFLUSH: c_int = 2;
+pub const TIOCM_DTR: c_int = 0x002;
+pub const TIOCM_RTS: c_int = 0x004;
+pub const TIOCM_CTS: c_int = 0x020;
+pub const TIOCM_CAR: c_int = 0x040;
+pub const TIOCM_RNG: c_int = 0x080;
+pub const TIOCM_DSR: c_int = 0x100;
+pub const TIOCM_RI: c_int = TIOCM_RNG;
+pub const TIOCM_CD: c_int = TIOCM_CAR;
+pub const TIOCSCTTY: crate::Ioctl = 0x540E;
+pub const TIOCGPGRP: crate::Ioctl = 0x540F;
+pub const TIOCSPGRP: crate::Ioctl = 0x5410;
+pub const TIOCGWINSZ: crate::Ioctl = 0x5413;
+pub const TIOCSWINSZ: crate::Ioctl = 0x5414;
+pub const TIOCGSID: c_int = 0x5429;
+pub const TFD_NONBLOCK: c_int = O_NONBLOCK;
+pub const TFD_CLOEXEC: c_int = O_CLOEXEC;
+pub const TFD_TIMER_ABSTIME: c_int = 1;
+pub const TFD_TIMER_CANCEL_ON_SET: c_int = 1 << 1;
+pub const ADJ_OFFSET: c_int = 0x0001;
+pub const ADJ_FREQUENCY: c_int = 0x0002;
+pub const ADJ_MAXERROR: c_int = 0x0004;
+pub const ADJ_ESTERROR: c_int = 0x0008;
+pub const ADJ_STATUS: c_int = 0x0010;
+pub const ADJ_TIMECONST: c_int = 0x0020;
+pub const ADJ_TAI: c_int = 0x0080;
+pub const ADJ_SETOFFSET: c_int = 0x0100;
+pub const ADJ_MICRO: c_int = 0x1000;
+pub const ADJ_NANO: c_int = 0x2000;
+pub const ADJ_TICK: c_int = 0x4000;
+pub const ADJ_OFFSET_SINGLESHOT: c_int = 0x8001;
+pub const ADJ_OFFSET_SS_READ: c_int = 0xa001;
+pub const STA_PLL: c_int = 0x0001;
+pub const STA_PPSFREQ: c_int = 0x0002;
+pub const STA_PPSTIME: c_int = 0x0004;
+pub const STA_FLL: c_int = 0x0008;
+pub const STA_INS: c_int = 0x0010;
+pub const STA_DEL: c_int = 0x0020;
+pub const STA_UNSYNC: c_int = 0x0040;
+pub const STA_FREQHOLD: c_int = 0x0080;
+pub const STA_PPSSIGNAL: c_int = 0x0100;
+pub const STA_PPSJITTER: c_int = 0x0200;
+pub const STA_PPSWANDER: c_int = 0x0400;
+pub const STA_PPSERROR: c_int = 0x0800;
+pub const STA_CLOCKERR: c_int = 0x1000;
+pub const STA_NANO: c_int = 0x2000;
+pub const STA_MODE: c_int = 0x4000;
+pub const STA_CLK: c_int = 0x8000;
+pub const TIME_ERROR: c_int = 5;
+extern "C" {
+    #[link_name = "__gnu_strerror_r"]
+    pub fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: size_t) -> c_int;
+
+    /// POSIX version of `basename(3)`, defined in `libgen.h`.
+    #[link_name = "basename"]
+    pub fn posix_basename(path: *mut c_char) -> *mut c_char;
+    /// GNU version of `basename(3)`, defined in `string.h`.
+    #[link_name = "__mlibc_gnu_basename_c"]
+    pub fn gnu_basename(path: *const c_char) -> *mut c_char;
+
+    pub fn msgctl(msqid: c_int, cmd: c_int, buf: *mut crate::msqid_ds) -> c_int;
+    pub fn ftok(__path: *const c_char, __proj_id: c_int) -> crate::key_t;
+    pub fn accept4(
+        __sockfd: c_int,
+        __addr: *mut crate::sockaddr,
+        __addrlen: *mut crate::socklen_t,
+        __flags: c_int,
+    ) -> c_int;
+    pub fn recvfrom(
+        __sockfd: c_int,
+        __buf: *mut c_void,
+        __size: crate::size_t,
+        __flags: c_int,
+        __src_addr: *mut crate::sockaddr,
+        __addrlen: *mut crate::socklen_t,
+    ) -> crate::ssize_t;
+    pub fn recvmmsg(
+        __sockfd: c_int,
+        __msgvec: *mut crate::mmsghdr,
+        __vlen: c_uint,
+        __flags: c_int,
+        __timeout: *mut crate::timespec,
+    ) -> c_int;
+    pub fn sendmmsg(
+        __sockfd: c_int,
+        __msgvec: *mut crate::mmsghdr,
+        __vlen: c_uint,
+        __flags: c_int,
+    ) -> c_int;
+    pub fn ctermid(__s: *mut c_char) -> *mut c_char;
+    pub fn endusershell();
+    pub fn faccessat(__fd: c_int, __path: *const c_char, __mode: c_int, __flags: c_int) -> c_int;
+    pub fn gethostid() -> c_long;
+    pub fn sethostname(__buffer: *const c_char, __max_length: crate::size_t) -> c_int;
+    pub fn sync();
+    pub fn getpagesize() -> c_int;
+    pub fn daemon(__nochdir: c_int, __noclose: c_int) -> c_int;
+    pub fn gettid() -> crate::pid_t;
+    pub fn getentropy(__buffer: *mut c_void, __size: crate::size_t) -> c_int;
+    pub fn dup3(__fd: c_int, __newfd: c_int, __flags: c_int) -> c_int;
+    pub fn vhangup() -> c_int;
+    pub fn getdtablesize() -> c_int;
+    pub fn syncfs(__fd: c_int) -> c_int;
+    pub fn timer_getoverrun(__timerid: crate::timer_t) -> c_int;
+    pub fn futimes(__fd: c_int, __tv: *const crate::timeval) -> c_int;
+    pub fn lutimes(__filename: *const c_char, __tv: *const crate::timeval) -> c_int;
+    pub fn timer_create(
+        __clockid: crate::clockid_t,
+        __sevp: *mut crate::sigevent,
+        __timerid: *mut crate::timer_t,
+    ) -> c_int;
+    pub fn timer_settime(
+        __timerid: crate::timer_t,
+        __flags: c_int,
+        __new_value: *const crate::itimerspec,
+        __old_value: *mut crate::itimerspec,
+    ) -> c_int;
+    pub fn timer_gettime(__timerid: crate::timer_t, __curr_value: *mut crate::itimerspec) -> c_int;
+    pub fn timer_delete(__timerid: crate::timer_t) -> c_int;
+    pub fn clock_nanosleep(
+        __clockid: crate::clockid_t,
+        __flags: c_int,
+        __req: *const crate::timespec,
+        __rem: *mut crate::timespec,
+    ) -> c_int;
+    pub fn asctime_r(__tm: *const crate::tm, __buf: *mut c_char) -> *mut c_char;
+    pub fn ctime_r(__timer: *const crate::time_t, __buf: *mut c_char) -> *mut c_char;
+    pub fn getloadavg(__loadavg: *mut c_double, __count: c_int) -> c_int;
+    pub fn rand() -> c_int;
+    pub fn rand_r(__seed: *mut c_uint) -> c_int;
+    pub fn srand(__seed: c_uint);
+    pub fn at_quick_exit(__func: Option<unsafe extern "C" fn()>) -> c_int;
+    pub fn _Exit(__status: c_int);
+    pub fn quick_exit(__status: c_int);
+    pub fn mktemp(__pattern: *mut c_char) -> *mut c_char;
+    pub fn qsort_r(
+        __base: *mut c_void,
+        __nmemb: crate::size_t,
+        __size: crate::size_t,
+        __compar: Option<unsafe extern "C" fn(*const c_void, *const c_void, *mut c_void) -> c_int>,
+        __arg: *mut c_void,
+    );
+    pub fn abs(__number: c_int) -> c_int;
+    pub fn labs(__number: c_long) -> c_long;
+    pub fn llabs(__number: c_longlong) -> c_longlong;
+    pub fn random() -> c_long;
+    pub fn drand48() -> c_double;
+    pub fn erand48(__s: *mut c_ushort) -> c_double;
+    pub fn seed48(__s: *mut c_ushort) -> *mut c_ushort;
+    pub fn srand48(__seed: c_long);
+    pub fn mrand48() -> c_long;
+    pub fn jrand48(__s: *mut c_ushort) -> c_long;
+    pub fn mkstemps(__pattern: *mut c_char, __suffixlen: c_int) -> c_int;
+    pub fn reallocarray(
+        __ptr: *mut c_void,
+        __count: crate::size_t,
+        __size: crate::size_t,
+    ) -> *mut c_void;
+    pub fn sched_getscheduler(__pid: crate::pid_t) -> c_int;
+    pub fn sched_setaffinity(
+        __pid: crate::pid_t,
+        __cpusetsize: crate::size_t,
+        __mask: *const crate::cpu_set_t,
+    ) -> c_int;
+    pub fn sched_getaffinity(
+        __pid: crate::pid_t,
+        __cpusetsize: crate::size_t,
+        __mask: *mut crate::cpu_set_t,
+    ) -> c_int;
+    pub fn unshare(flags: c_int) -> c_int;
+    pub fn clone(
+        arg0: Option<unsafe extern "C" fn(*mut c_void) -> c_int>,
+        arg1: *mut c_void,
+        arg2: c_int,
+        arg3: *mut c_void,
+        ...
+    ) -> c_int;
+    pub fn sched_getcpu() -> c_int;
+    pub fn setns(fd: c_int, nstype: c_int) -> c_int;
+    pub fn process_vm_readv(
+        pid: crate::pid_t,
+        local_iov: *const crate::iovec,
+        liovcnt: c_ulong,
+        remote_iov: *const crate::iovec,
+        riovcnt: c_ulong,
+        flags: c_ulong,
+    ) -> crate::ssize_t;
+    pub fn process_vm_writev(
+        pid: crate::pid_t,
+        local_iov: *const crate::iovec,
+        liovcnt: c_ulong,
+        remote_iov: *const crate::iovec,
+        riovcnt: c_ulong,
+        flags: c_ulong,
+    ) -> crate::ssize_t;
+    pub fn setutent();
+    pub fn getutent() -> *mut crate::utmp;
+    pub fn getutent_r(__buf: *mut crate::utmp, __res: *mut *mut crate::utmp) -> c_int;
+    pub fn endutent();
+    pub fn pututline(__line: *const crate::utmp) -> *mut crate::utmp;
+    pub fn getutline(__line: *const crate::utmp) -> *mut crate::utmp;
+    pub fn getutid(__id: *const crate::utmp) -> *mut crate::utmp;
+    pub fn utmpname(__file: *const c_char) -> c_int;
+    pub fn updwtmp(wtmp_file: *const c_char, ut: *const crate::utmp);
+    pub fn sigsuspend(__sigmask: *const crate::sigset_t) -> c_int;
+    pub fn pthread_sigmask(
+        __how: c_int,
+        __sigmask: *const crate::sigset_t,
+        __oldmask: *mut crate::sigset_t,
+    ) -> c_int;
+    pub fn pthread_kill(__thrd: crate::pthread_t, __sig: c_int) -> c_int;
+    pub fn siginterrupt(__sig: c_int, __flag: c_int) -> c_int;
+    pub fn sigaltstack(__ss: *const crate::stack_t, __oss: *mut crate::stack_t) -> c_int;
+    pub fn sigtimedwait(
+        __set: *const crate::sigset_t,
+        __info: *mut crate::siginfo_t,
+        __timeout: *const crate::timespec,
+    ) -> c_int;
+    pub fn sigwait(__set: *const crate::sigset_t, __sig: *mut c_int) -> c_int;
+    pub fn sigwaitinfo(__set: *const crate::sigset_t, __info: *mut crate::siginfo_t) -> c_int;
+    pub fn sigisemptyset(__set: *const crate::sigset_t) -> c_int;
+    pub fn sigqueue(__pid: crate::pid_t, __sig: c_int, __value: crate::sigval) -> c_int;
+    pub fn popen(__command: *const c_char, __type: *const c_char) -> *mut crate::FILE;
+    pub fn fseeko64(__stream: *mut crate::FILE, __offset: crate::off64_t, __whence: c_int)
+        -> c_int;
+    pub fn ftello64(__stream: *mut crate::FILE) -> crate::off64_t;
+    pub fn seekdir(__dirp: *mut crate::DIR, __loc: c_long);
+    pub fn telldir(__dirp: *mut crate::DIR) -> c_long;
+    pub fn __errno_location() -> *mut c_int;
+    pub fn backtrace(__buffer: *mut *mut c_void, __size: c_int) -> c_int;
+    pub fn fallocate(
+        __fd: c_int,
+        __mode: c_int,
+        __offset: crate::off_t,
+        __len: crate::off_t,
+    ) -> c_int;
+    pub fn posix_fallocate(__fd: c_int, __offset: crate::off_t, __size: crate::off_t) -> c_int;
+    pub fn splice(
+        __fd_in: c_int,
+        __off_in: *mut crate::off_t,
+        __fd_out: c_int,
+        __off_out: *mut crate::off_t,
+        __len: crate::size_t,
+        __flags: c_uint,
+    ) -> crate::ssize_t;
+    pub fn vmsplice(
+        __fd: c_int,
+        __iov: *const crate::iovec,
+        __nr_segs: crate::size_t,
+        __flags: c_uint,
+    ) -> crate::ssize_t;
+    pub fn getopt_long(
+        __argc: c_int,
+        __argv: *mut *mut c_char,
+        __optstring: *const c_char,
+        __longopts: *const option,
+        __longindex: *mut c_int,
+    ) -> c_int;
+    pub fn glob(
+        __pattern: *const c_char,
+        __flags: c_int,
+        __errfunc: Option<unsafe extern "C" fn(*const c_char, c_int) -> c_int>,
+        __pglob: *mut crate::glob_t,
+    ) -> c_int;
+    pub fn globfree(__pglog: *mut crate::glob_t);
+    pub fn fread_unlocked(
+        __buffer: *mut c_void,
+        __size: crate::size_t,
+        __count: crate::size_t,
+        __stream: *mut crate::FILE,
+    ) -> crate::size_t;
+    pub fn endgrent();
+    pub fn getgrent() -> *mut crate::group;
+    pub fn getgrgid(__gid: crate::gid_t) -> *mut crate::group;
+    pub fn getgrgid_r(
+        __gid: crate::gid_t,
+        __grp: *mut crate::group,
+        __buf: *mut c_char,
+        __buflen: crate::size_t,
+        __res: *mut *mut crate::group,
+    ) -> c_int;
+    pub fn getgrnam(__name: *const c_char) -> *mut crate::group;
+    pub fn getgrnam_r(
+        __name: *const c_char,
+        __grp: *mut crate::group,
+        __buf: *mut c_char,
+        __buflen: crate::size_t,
+        __res: *mut *mut crate::group,
+    ) -> c_int;
+    pub fn setgrent();
+    pub fn putgrent(__grp: *const crate::group, __stream: *mut crate::FILE) -> c_int;
+    pub fn initgroups(__user: *const c_char, __group: crate::gid_t) -> c_int;
+    pub fn getgrouplist(
+        __user: *const c_char,
+        __group: crate::gid_t,
+        __groups: *mut crate::gid_t,
+        __ngroups: *mut c_int,
+    ) -> c_int;
+    pub fn nl_langinfo(__item: crate::nl_item) -> *mut c_char;
+    pub fn nl_langinfo_l(__item: crate::nl_item, __loc: crate::locale_t) -> *mut c_char;
+    pub fn dirname(__path: *mut c_char) -> *mut c_char;
+    pub fn dl_iterate_phdr(
+        __callback: Option<
+            unsafe extern "C" fn(*mut crate::dl_phdr_info, crate::size_t, *mut c_void) -> c_int,
+        >,
+        __data: *mut c_void,
+    ) -> c_int;
+    pub fn setmntent(__filename: *const c_char, __type: *const c_char) -> *mut crate::FILE;
+    pub fn getmntent(__f: *mut crate::FILE) -> *mut crate::mntent;
+    pub fn addmntent(__f: *mut crate::FILE, __mnt: *const crate::mntent) -> c_int;
+    pub fn endmntent(__f: *mut crate::FILE) -> c_int;
+    pub fn hasmntopt(__mnt: *const crate::mntent, __opt: *const c_char) -> *mut c_char;
+    pub fn getmntent_r(
+        __f: *mut crate::FILE,
+        __mnt: *mut crate::mntent,
+        __linebuf: *mut c_char,
+        __buflen: c_int,
+    ) -> *mut crate::mntent;
+    pub fn mq_getattr(__mqdes: crate::mqd_t, __attr: *mut crate::mq_attr) -> c_int;
+    pub fn mq_setattr(
+        __mqdes: crate::mqd_t,
+        __newattr: *const crate::mq_attr,
+        __oldattr: *mut crate::mq_attr,
+    ) -> c_int;
+    pub fn mq_unlink(__name: *const c_char) -> c_int;
+    pub fn mq_open(__name: *const c_char, __flags: c_int, ...) -> crate::mqd_t;
+    pub fn if_freenameindex(__index: *mut crate::if_nameindex);
+    pub fn if_nameindex() -> *mut crate::if_nameindex;
+    pub fn getnameinfo(
+        __addr: *const crate::sockaddr,
+        __addrlen: crate::socklen_t,
+        __host: *mut c_char,
+        __hostlen: crate::socklen_t,
+        __serv: *mut c_char,
+        __servlen: crate::socklen_t,
+        __flags: c_int,
+    ) -> c_int;
+    pub fn ppoll(
+        __fds: *mut crate::pollfd,
+        __nfds: crate::nfds_t,
+        __timeout_ts: *const crate::timespec,
+        __sigmask: *const crate::sigset_t,
+    ) -> c_int;
+    pub fn sched_get_priority_max(__policy: c_int) -> c_int;
+    pub fn sched_get_priority_min(__policy: c_int) -> c_int;
+    pub fn sched_setscheduler(
+        __pid: crate::pid_t,
+        __policy: c_int,
+        __param: *const crate::sched_param,
+    ) -> c_int;
+    pub fn sched_getparam(__pid: crate::pid_t, __param: *mut crate::sched_param) -> c_int;
+    pub fn sched_setparam(__pid: crate::pid_t, __param: *const crate::sched_param) -> c_int;
+    pub fn pthread_attr_getdetachstate(
+        __attr: *const crate::pthread_attr_t,
+        __state: *mut c_int,
+    ) -> c_int;
+    pub fn pthread_attr_getstackaddr(
+        __attr: *const crate::pthread_attr_t,
+        __stackaddr: *mut *mut c_void,
+    ) -> c_int;
+    pub fn pthread_attr_setstackaddr(
+        __attr: *mut crate::pthread_attr_t,
+        __stackaddr: *mut c_void,
+    ) -> c_int;
+    pub fn pthread_attr_getguardsize(
+        __attr: *const crate::pthread_attr_t,
+        __guardsize: *mut crate::size_t,
+    ) -> c_int;
+    pub fn pthread_attr_setguardsize(
+        __attr: *mut crate::pthread_attr_t,
+        __guardsize: crate::size_t,
+    ) -> c_int;
+    pub fn pthread_attr_getscope(
+        __attr: *const crate::pthread_attr_t,
+        __scope: *mut c_int,
+    ) -> c_int;
+    pub fn pthread_attr_setscope(__attr: *mut crate::pthread_attr_t, __scope: c_int) -> c_int;
+    pub fn pthread_attr_getschedparam(
+        __attr: *const crate::pthread_attr_t,
+        __param: *mut crate::sched_param,
+    ) -> c_int;
+    pub fn pthread_attr_setschedparam(
+        __attr: *mut crate::pthread_attr_t,
+        __param: *const crate::sched_param,
+    ) -> c_int;
+    pub fn pthread_attr_getschedpolicy(
+        __attr: *const crate::pthread_attr_t,
+        __schedpolicy: *mut c_int,
+    ) -> c_int;
+    pub fn pthread_attr_setschedpolicy(
+        __attr: *mut crate::pthread_attr_t,
+        __schedpolicy: c_int,
+    ) -> c_int;
+    pub fn pthread_attr_getinheritsched(
+        __attr: *const crate::pthread_attr_t,
+        __inheritsched: *mut c_int,
+    ) -> c_int;
+    pub fn pthread_attr_setinheritsched(
+        __attr: *mut crate::pthread_attr_t,
+        __inheritsched: c_int,
+    ) -> c_int;
+    pub fn pthread_attr_getaffinity_np(
+        __attr: *const crate::pthread_attr_t,
+        __cpusetsize: crate::size_t,
+        __cpuset: *mut crate::cpu_set_t,
+    ) -> c_int;
+    pub fn pthread_attr_setaffinity_np(
+        __attr: *mut crate::pthread_attr_t,
+        __cpusetsize: crate::size_t,
+        __cpuset: *const crate::cpu_set_t,
+    ) -> c_int;
+    pub fn pthread_attr_getsigmask_np(
+        __attr: *const crate::pthread_attr_t,
+        __sigmask: *mut crate::sigset_t,
+    ) -> c_int;
+    pub fn pthread_attr_setsigmask_np(
+        __attr: *mut crate::pthread_attr_t,
+        __sigmask: *const crate::sigset_t,
+    ) -> c_int;
+    pub fn pthread_getaffinity_np(
+        __thrd: crate::pthread_t,
+        __cpusetsize: crate::size_t,
+        __cpuset: *mut crate::cpu_set_t,
+    ) -> c_int;
+    pub fn pthread_setaffinity_np(
+        __thrd: crate::pthread_t,
+        __cpusetsize: crate::size_t,
+        __cpuset: *const crate::cpu_set_t,
+    ) -> c_int;
+    pub fn pthread_create(
+        __thrd: *mut crate::pthread_t,
+        __attr: *const crate::pthread_attr_t,
+        __fn: extern "C" fn(*mut c_void) -> *mut c_void,
+        __arg: *mut c_void,
+    ) -> c_int;
+    pub fn pthread_setname_np(__thrd: crate::pthread_t, __name: *const c_char) -> c_int;
+    pub fn pthread_getname_np(
+        __thrd: crate::pthread_t,
+        __name: *mut c_char,
+        __size: crate::size_t,
+    ) -> c_int;
+    pub fn pthread_setschedparam(
+        __thrd: crate::pthread_t,
+        __policy: c_int,
+        __param: *const crate::sched_param,
+    ) -> c_int;
+    pub fn pthread_getschedparam(
+        __thrd: crate::pthread_t,
+        __policy: *mut c_int,
+        __param: *mut crate::sched_param,
+    ) -> c_int;
+    pub fn pthread_setcanceltype(__type: c_int, __oldtype: *mut c_int) -> c_int;
+    pub fn pthread_setcancelstate(__state: c_int, __oldstate: *mut c_int) -> c_int;
+    pub fn pthread_testcancel();
+    pub fn pthread_cancel(__thrd: crate::pthread_t) -> c_int;
+    pub fn pthread_atfork(
+        __prepare: Option<unsafe extern "C" fn()>,
+        __parent: Option<unsafe extern "C" fn()>,
+        __child: Option<unsafe extern "C" fn()>,
+    ) -> c_int;
+    pub fn pthread_once(
+        __once: *mut crate::pthread_once_t,
+        __fn: Option<unsafe extern "C" fn()>,
+    ) -> c_int;
+    pub fn pthread_mutexattr_gettype(
+        __attr: *const crate::pthread_mutexattr_t,
+        __type: *mut c_int,
+    ) -> c_int;
+    pub fn pthread_mutexattr_getrobust(
+        __attr: *const crate::pthread_mutexattr_t,
+        __robust: *mut c_int,
+    ) -> c_int;
+    pub fn pthread_mutexattr_setrobust(
+        __attr: *mut crate::pthread_mutexattr_t,
+        __robust: c_int,
+    ) -> c_int;
+    pub fn pthread_mutexattr_getpshared(
+        __attr: *const crate::pthread_mutexattr_t,
+        __pshared: *mut c_int,
+    ) -> c_int;
+    pub fn pthread_mutexattr_getprotocol(
+        __attr: *const crate::pthread_mutexattr_t,
+        __protocol: *mut c_int,
+    ) -> c_int;
+    pub fn pthread_mutexattr_setprotocol(
+        __attr: *mut crate::pthread_mutexattr_t,
+        __protocol: c_int,
+    ) -> c_int;
+    pub fn pthread_mutexattr_getprioceiling(
+        __attr: *const crate::pthread_mutexattr_t,
+        __prioceiling: *mut c_int,
+    ) -> c_int;
+    pub fn pthread_mutexattr_setprioceiling(
+        __attr: *mut crate::pthread_mutexattr_t,
+        __prioceiling: c_int,
+    ) -> c_int;
+    pub fn pthread_mutex_timedlock(
+        __mtx: *mut crate::pthread_mutex_t,
+        __abs_timeout: *const crate::timespec,
+    ) -> c_int;
+    pub fn pthread_mutex_consistent(__mtx: *mut crate::pthread_mutex_t) -> c_int;
+    pub fn pthread_condattr_getpshared(
+        __attr: *const crate::pthread_condattr_t,
+        __pshared: *mut c_int,
+    ) -> c_int;
+    pub fn pthread_barrierattr_init(__attr: *mut crate::pthread_barrierattr_t) -> c_int;
+    pub fn pthread_barrierattr_destroy(__attr: *mut crate::pthread_barrierattr_t) -> c_int;
+    pub fn pthread_barrierattr_setpshared(
+        __attr: *mut crate::pthread_barrierattr_t,
+        __pshared: c_int,
+    ) -> c_int;
+    pub fn pthread_barrierattr_getpshared(
+        __attr: *const crate::pthread_barrierattr_t,
+        __pshared: *mut c_int,
+    ) -> c_int;
+    pub fn pthread_barrier_init(
+        __barrier: *mut crate::pthread_barrier_t,
+        __attr: *const crate::pthread_barrierattr_t,
+        __count: c_uint,
+    ) -> c_int;
+    pub fn pthread_barrier_destroy(__barrier: *mut crate::pthread_barrier_t) -> c_int;
+    pub fn pthread_barrier_wait(__barrier: *mut crate::pthread_barrier_t) -> c_int;
+    pub fn pthread_getcpuclockid(
+        __thrd: crate::pthread_t,
+        __clockid: *mut crate::clockid_t,
+    ) -> c_int;
+    pub fn endpwent();
+    pub fn getpwent() -> *mut crate::passwd;
+    pub fn getpwnam_r(
+        __name: *const c_char,
+        __ret: *mut crate::passwd,
+        __buf: *mut c_char,
+        __buflen: crate::size_t,
+        __res: *mut *mut crate::passwd,
+    ) -> c_int;
+    pub fn getpwuid_r(
+        __uid: crate::uid_t,
+        __ret: *mut crate::passwd,
+        __buf: *mut c_char,
+        __buflen: crate::size_t,
+        __res: *mut *mut crate::passwd,
+    ) -> c_int;
+    pub fn setpwent();
+    pub fn putpwent(__pwd: *const crate::passwd, __f: *mut crate::FILE) -> c_int;
+    pub fn fgetpwent(__f: *mut crate::FILE) -> *mut crate::passwd;
+    pub fn regcomp(__regex: *mut crate::regex_t, __pattern: *const c_char, __flags: c_int)
+        -> c_int;
+    pub fn regexec(
+        __regex: *const crate::regex_t,
+        __string: *const c_char,
+        __nmatch: crate::size_t,
+        __pmatch: *mut crate::regmatch_t,
+        __flags: c_int,
+    ) -> c_int;
+    pub fn regerror(
+        __errcode: c_int,
+        __regex: *const crate::regex_t,
+        __errbuf: *mut c_char,
+        __errbuf_size: crate::size_t,
+    ) -> crate::size_t;
+    pub fn regfree(__regex: *mut crate::regex_t);
+    pub fn putspent(__sp: *const crate::spwd, __f: *mut crate::FILE) -> c_int;
+    pub fn lckpwdf() -> c_int;
+    pub fn ulckpwdf() -> c_int;
+    pub fn getspnam(__name: *const c_char) -> *mut crate::spwd;
+    pub fn getspnam_r(
+        __name: *const c_char,
+        __sp: *mut crate::spwd,
+        __buf: *mut c_char,
+        __size: crate::size_t,
+        __res: *mut *mut crate::spwd,
+    ) -> c_int;
+    pub fn fgetspent(__f: *mut crate::FILE) -> *mut crate::spwd;
+    pub fn endspent();
+    pub fn sgetspent(__s: *const c_char) -> *mut crate::spwd;
+    pub fn posix_spawn(
+        __pid: *mut crate::pid_t,
+        __path: *const c_char,
+        __file_actions: *const crate::posix_spawn_file_actions_t,
+        __attrs: *const crate::posix_spawnattr_t,
+        __argv: *mut *mut c_char,
+        __envp: *mut *mut c_char,
+    ) -> c_int;
+    pub fn posix_spawnattr_init(__attr: *mut crate::posix_spawnattr_t) -> c_int;
+    pub fn posix_spawnattr_destroy(__attr: *mut crate::posix_spawnattr_t) -> c_int;
+    pub fn posix_spawnattr_setflags(
+        __attr: *mut crate::posix_spawnattr_t,
+        __flags: c_short,
+    ) -> c_int;
+    pub fn posix_spawnattr_setsigdefault(
+        __attr: *mut crate::posix_spawnattr_t,
+        __sigdefault: *const crate::sigset_t,
+    ) -> c_int;
+    pub fn posix_spawnattr_setschedparam(
+        __attr: *mut crate::posix_spawnattr_t,
+        __schedparam: *const crate::sched_param,
+    ) -> c_int;
+    pub fn posix_spawnattr_setschedpolicy(
+        __attr: *mut crate::posix_spawnattr_t,
+        __schedpolicy: c_int,
+    ) -> c_int;
+    pub fn posix_spawnattr_setsigmask(
+        __attr: *mut crate::posix_spawnattr_t,
+        __sigmask: *const crate::sigset_t,
+    ) -> c_int;
+    pub fn posix_spawnattr_setpgroup(
+        __attr: *mut crate::posix_spawnattr_t,
+        __pgroup: crate::pid_t,
+    ) -> c_int;
+    pub fn posix_spawn_file_actions_init(
+        __file_actions: *mut crate::posix_spawn_file_actions_t,
+    ) -> c_int;
+    pub fn posix_spawn_file_actions_destroy(
+        __file_actions: *mut crate::posix_spawn_file_actions_t,
+    ) -> c_int;
+    pub fn posix_spawn_file_actions_adddup2(
+        __file_actions: *mut crate::posix_spawn_file_actions_t,
+        __fildes: c_int,
+        __newfildes: c_int,
+    ) -> c_int;
+    pub fn posix_spawn_file_actions_addclose(
+        __file_actions: *mut crate::posix_spawn_file_actions_t,
+        __fildes: c_int,
+    ) -> c_int;
+    pub fn posix_spawn_file_actions_addopen(
+        __file_actions: *mut crate::posix_spawn_file_actions_t,
+        __fildes: c_int,
+        __path: *const c_char,
+        __oflag: c_int,
+        __mode: crate::mode_t,
+    ) -> c_int;
+    pub fn posix_spawnp(
+        __pid: *mut crate::pid_t,
+        __file: *const c_char,
+        __file_actions: *const crate::posix_spawn_file_actions_t,
+        __attrp: *const crate::posix_spawnattr_t,
+        __argv: *mut *mut c_char,
+        __envp: *mut *mut c_char,
+    ) -> c_int;
+    pub fn peekauxval(__type: c_ulong, __value: *mut c_ulong) -> c_int;
+    pub fn getauxval(__type: c_ulong) -> c_ulong;
+    pub fn epoll_create(__flags: c_int) -> c_int;
+    pub fn epoll_create1(__flags: c_int) -> c_int;
+    pub fn epoll_ctl(
+        __epfd: c_int,
+        __mode: c_int,
+        __fd: c_int,
+        __ev: *mut crate::epoll_event,
+    ) -> c_int;
+    pub fn epoll_wait(
+        __epfd: c_int,
+        __events: *mut crate::epoll_event,
+        __maxevents: c_int,
+        __timeout: c_int,
+    ) -> c_int;
+    pub fn epoll_pwait(
+        __epfd: c_int,
+        __events: *mut crate::epoll_event,
+        __maxevents: c_int,
+        __timeout: c_int,
+        __sigmask: *const crate::sigset_t,
+    ) -> c_int;
+    pub fn eventfd(__initval: c_uint, __flags: c_int) -> c_int;
+    pub fn eventfd_read(__fd: c_int, __value: *mut crate::eventfd_t) -> c_int;
+    pub fn eventfd_write(__fd: c_int, __value: crate::eventfd_t) -> c_int;
+    pub fn setfsuid(__uid: crate::uid_t) -> c_int;
+    pub fn setfsgid(__gid: crate::gid_t) -> c_int;
+    pub fn inotify_init() -> c_int;
+    pub fn inotify_init1(__flags: c_int) -> c_int;
+    pub fn inotify_add_watch(__ifd: c_int, __path: *const c_char, __mask: u32) -> c_int;
+    pub fn inotify_rm_watch(__ifd: c_int, __wd: c_int) -> c_int;
+    pub fn klogctl(__type: c_int, __bufp: *mut c_char, __len: c_int) -> c_int;
+    pub fn mprotect(__addr: *mut c_void, __size: crate::size_t, __prot: c_int) -> c_int;
+    pub fn posix_madvise(__addr: *mut c_void, __size: crate::size_t, __advise: c_int) -> c_int;
+    pub fn msync(__addr: *mut c_void, __size: crate::size_t, __flags: c_int) -> c_int;
+    pub fn shm_open(__name: *const c_char, __oflag: c_int, __mode: crate::mode_t) -> c_int;
+    pub fn shm_unlink(__name: *const c_char) -> c_int;
+    pub fn mremap(
+        __old_address: *mut c_void,
+        __old_size: crate::size_t,
+        __new_size: crate::size_t,
+        __flags: c_int,
+        ...
+    ) -> *mut c_void;
+    pub fn remap_file_pages(
+        __addr: *mut c_void,
+        __size: crate::size_t,
+        __prot: c_int,
+        __pgoff: crate::size_t,
+        __flags: c_int,
+    ) -> c_int;
+    pub fn memfd_create(__name: *const c_char, __flags: c_uint) -> c_int;
+    pub fn madvise(__addr: *mut c_void, __size: crate::size_t, __advise: c_int) -> c_int;
+    pub fn msgget(__key: crate::key_t, __msgflg: c_int) -> c_int;
+    pub fn msgrcv(
+        __msqid: c_int,
+        __msgp: *mut c_void,
+        __size: crate::size_t,
+        __msgtyp: c_long,
+        __msgflg: c_int,
+    ) -> crate::ssize_t;
+    pub fn msgsnd(
+        __msqid: c_int,
+        __msgp: *const c_void,
+        __size: crate::size_t,
+        __msgflg: c_int,
+    ) -> c_int;
+    pub fn personality(__persona: c_ulong) -> c_int;
+    pub fn pidfd_open(__pid: crate::pid_t, __flags: c_uint) -> c_int;
+    pub fn pidfd_getpid(__fd: c_int) -> crate::pid_t;
+    pub fn pidfd_send_signal(
+        __pidfd: c_int,
+        __sig: c_int,
+        __info: *mut crate::siginfo_t,
+        __flags: c_uint,
+    ) -> c_int;
+    pub fn prctl(__op: c_int, ...) -> c_int;
+    pub fn ptrace(__op: c_int, ...) -> c_long;
+    pub fn getrandom(
+        __buffer: *mut c_void,
+        __max_size: crate::size_t,
+        __flags: c_uint,
+    ) -> crate::ssize_t;
+    pub fn reboot(__arg: c_int) -> c_int;
+    pub fn getpriority(__which: c_int, __who: crate::id_t) -> c_int;
+    pub fn setpriority(__which: c_int, __who: crate::id_t, __prio: c_int) -> c_int;
+    pub fn getrlimit(__resource: c_int, __rlim: *mut crate::rlimit) -> c_int;
+    pub fn getrlimit64(__resource: c_int, __rlim: *mut crate::rlimit) -> c_int;
+    pub fn setrlimit(__resource: c_int, __rlim: *const crate::rlimit) -> c_int;
+    pub fn setrlimit64(__resource: c_int, __rlim: *const crate::rlimit) -> c_int;
+    pub fn prlimit(
+        __pid: crate::pid_t,
+        __resource: c_int,
+        __new_limits: *const crate::rlimit,
+        __old_limits: *mut crate::rlimit,
+    ) -> c_int;
+    pub fn semget(__key: crate::key_t, __nsems: c_int, __semflg: c_int) -> c_int;
+    pub fn semop(__semid: c_int, __sops: *mut crate::sembuf, __nsops: crate::size_t) -> c_int;
+    pub fn semctl(__semid: c_int, __semnum: c_int, __op: c_int, ...) -> c_int;
+    pub fn sendfile(
+        __out_fd: c_int,
+        __in_fd: c_int,
+        __offset: *mut crate::off_t,
+        __size: crate::size_t,
+    ) -> crate::ssize_t;
+    pub fn shmat(__shmid: c_int, __shmaddr: *const c_void, __shmflg: c_int) -> *mut c_void;
+    pub fn shmctl(__shmid: c_int, __cmd: c_int, __buf: *mut crate::shmid_ds) -> c_int;
+    pub fn shmdt(__shmaddr: *const c_void) -> c_int;
+    pub fn shmget(__key: crate::key_t, __size: crate::size_t, __shmflg: c_int) -> c_int;
+    pub fn signalfd(__fd: c_int, __mask: *const crate::sigset_t, __flags: c_int) -> c_int;
+    pub fn mkfifoat(__dirfd: c_int, __pathname: *const c_char, __mode: crate::mode_t) -> c_int;
+    pub fn swapon(__path: *const c_char, __flags: c_int) -> c_int;
+    pub fn swapoff(__path: *const c_char) -> c_int;
+    pub fn sysinfo(__info: *mut crate::sysinfo) -> c_int;
+    pub fn gettimeofday(__result: *mut crate::timeval, __unused: *mut c_void) -> c_int;
+    pub fn settimeofday(__result: *const crate::timeval, __zone: *const crate::timezone) -> c_int;
+    pub fn getitimer(__which: c_int, __curr_value: *mut crate::itimerval) -> c_int;
+    pub fn setitimer(
+        __which: c_int,
+        __new_value: *const crate::itimerval,
+        __old_value: *mut crate::itimerval,
+    ) -> c_int;
+    pub fn timerfd_create(__clockid: c_int, __flags: c_int) -> c_int;
+    pub fn timerfd_settime(
+        __fd: c_int,
+        __flags: c_int,
+        __value: *const crate::itimerspec,
+        __oldvalue: *mut crate::itimerspec,
+    ) -> c_int;
+    pub fn timerfd_gettime(__fd: c_int, __value: *mut crate::itimerspec) -> c_int;
+    pub fn adjtimex(__buf: *mut crate::timex) -> c_int;
+    pub fn clock_adjtime(__clockid: crate::clockid_t, __buf: *mut crate::timex) -> c_int;
+    pub fn ntp_adjtime(__buf: *mut crate::timex) -> c_int;
+    pub fn preadv(
+        __fd: c_int,
+        __iov: *const crate::iovec,
+        __iovcnt: c_int,
+        __offset: crate::off_t,
+    ) -> crate::ssize_t;
+    pub fn pwritev(
+        __fd: c_int,
+        __iov: *const crate::iovec,
+        __iovcnt: c_int,
+        __offset: crate::off_t,
+    ) -> crate::ssize_t;
+    pub fn setxattr(
+        __path: *const c_char,
+        __name: *const c_char,
+        __val: *const c_void,
+        __size: crate::size_t,
+        __flags: c_int,
+    ) -> c_int;
+    pub fn lsetxattr(
+        __path: *const c_char,
+        __name: *const c_char,
+        __val: *const c_void,
+        __size: crate::size_t,
+        __flags: c_int,
+    ) -> c_int;
+    pub fn fsetxattr(
+        __fd: c_int,
+        __name: *const c_char,
+        __val: *const c_void,
+        __size: crate::size_t,
+        __flags: c_int,
+    ) -> c_int;
+    pub fn getxattr(
+        __path: *const c_char,
+        __name: *const c_char,
+        __val: *mut c_void,
+        __size: crate::size_t,
+    ) -> crate::ssize_t;
+    pub fn lgetxattr(
+        __path: *const c_char,
+        __name: *const c_char,
+        __val: *mut c_void,
+        __size: crate::size_t,
+    ) -> crate::ssize_t;
+    pub fn fgetxattr(
+        __fd: c_int,
+        __name: *const c_char,
+        __val: *mut c_void,
+        __size: crate::size_t,
+    ) -> crate::ssize_t;
+    pub fn listxattr(
+        __path: *const c_char,
+        __list: *mut c_char,
+        __size: crate::size_t,
+    ) -> crate::ssize_t;
+    pub fn llistxattr(
+        __path: *const c_char,
+        __list: *mut c_char,
+        __size: crate::size_t,
+    ) -> crate::ssize_t;
+    pub fn flistxattr(__fd: c_int, __list: *mut c_char, __size: crate::size_t) -> crate::ssize_t;
+    pub fn removexattr(__path: *const c_char, __name: *const c_char) -> c_int;
+    pub fn lremovexattr(__path: *const c_char, __name: *const c_char) -> c_int;
+    pub fn fremovexattr(__fd: c_int, __name: *const c_char) -> c_int;
+    pub fn endutxent();
+    pub fn getutxent() -> *mut crate::utmpx;
+    pub fn getutxid(__id: *const crate::utmpx) -> *mut crate::utmpx;
+    pub fn getutxline(__ut: *const crate::utmpx) -> *mut crate::utmpx;
+    pub fn pututxline(__line: *const crate::utmpx) -> *mut crate::utmpx;
+    pub fn setutxent();
+    pub fn updwtmpx(__wtmp_file: *const c_char, __ut: *const crate::utmpx);
+    pub fn utmpxname(__file: *const c_char) -> c_int;
+}
+
+cfg_if! {
+    if #[cfg(target_arch = "aarch64")] {
+        mod aarch64;
+        pub use self::aarch64::*;
+    } else if #[cfg(any(target_arch = "riscv64"))] {
+        mod riscv64;
+        pub use self::riscv64::*;
+    } else if #[cfg(target_arch = "x86_64")] {
+        mod x86_64;
+        pub use self::x86_64::*;
+    } else {
+        // Unknown target_arch
+    }
+}
-- 
2.51.0

