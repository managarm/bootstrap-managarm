From 181b1d303d75d8307144daa30f6754540139ba81 Mon Sep 17 00:00:00 2001
From: no92 <no92.mail@gmail.com>
Date: Fri, 28 Mar 2025 19:33:56 +0100
Subject: [PATCH 3/4] Add generated managarm bindings

---
 src/unix/linux_like/managarm/mod.rs | 988 ++++++++++++++++++++++++++++
 1 file changed, 988 insertions(+)
 create mode 100644 src/unix/linux_like/managarm/mod.rs

diff --git a/src/unix/linux_like/managarm/mod.rs b/src/unix/linux_like/managarm/mod.rs
new file mode 100644
index 000000000..162b1abf3
--- /dev/null
+++ b/src/unix/linux_like/managarm/mod.rs
@@ -0,0 +1,988 @@
+// This file is autogenerated!
+// All changes made will be lost (eventually)!
+use crate::prelude::*;
+use crate::{
+    sighandler_t, AF_LOCAL, LC_COLLATE_MASK, LC_CTYPE_MASK, LC_MESSAGES_MASK, LC_MONETARY_MASK,
+    LC_NUMERIC_MASK, LC_TIME_MASK, PF_LOCAL,
+};
+
+pub type blkcnt64_t = i64;
+pub type rlimit64 = crate::rlimit;
+pub type rlim64_t = crate::rlim_t;
+pub type dirent64 = crate::dirent;
+pub type statfs64 = crate::statfs;
+pub type statvfs64 = crate::statvfs;
+pub type idtype_t = c_uint;
+pub type sem_t = c_uint;
+pub type Ioctl = c_ulong;
+
+pub type pthread_t = *mut c_void;
+pub type pthread_once_t = c_int;
+pub type pthread_key_t = crate::uintptr_t;
+
+pub type __u8 = c_uchar;
+pub type __u16 = c_ushort;
+pub type __s16 = c_short;
+pub type __u32 = c_uint;
+pub type __s32 = c_int;
+pub type __u64 = c_ulonglong;
+pub type __s64 = c_longlong;
+
+pub type Elf32_Half = u16;
+pub type Elf32_Word = u32;
+pub type Elf32_Off = u32;
+pub type Elf32_Addr = u32;
+
+pub type Elf64_Half = u16;
+pub type Elf64_Word = u32;
+pub type Elf64_Off = u64;
+pub type Elf64_Addr = u64;
+pub type Elf64_Xword = u64;
+
+pub type ino_t = u64;
+pub type ino64_t = crate::ino_t;
+pub type off_t = i64;
+pub type off64_t = i64;
+pub type reclen_t = c_ushort;
+pub type mode_t = c_uint;
+pub type dev_t = u64;
+pub type blkcnt_t = i64;
+pub type time_t = c_long;
+pub type wchar_t = c_int;
+pub type socklen_t = c_uint;
+pub type clock_t = c_long;
+pub type stack_t = crate::__stack;
+pub type nfds_t = usize;
+pub type pthread_attr_t = crate::__mlibc_threadattr;
+pub type greg_t = c_ulong;
+pub type pthread_barrier_t = crate::__mlibc_barrier;
+pub type pthread_barrierattr_t = crate::__mlibc_barrierattr_struct;
+pub type pthread_cond_t = crate::__mlibc_cond;
+pub type pthread_condattr_t = crate::__mlibc_condattr;
+pub type pthread_mutex_t = crate::__mlibc_mutex;
+pub type pthread_mutexattr_t = crate::__mlibc_mutexattr;
+pub type pthread_rwlock_t = crate::__mlibc_fair_rwlock;
+pub type pthread_rwlockattr_t = crate::__mlibc_rwlockattr;
+pub type pthread_spinlock_t = crate::__mlibc_spinlock;
+pub type msglen_t = c_ulong;
+pub type msgqnum_t = c_ulong;
+pub type suseconds_t = c_long;
+pub type rlim_t = c_ulong;
+pub type fsblkcnt_t = u64;
+pub type fsfilcnt_t = u64;
+pub type fsid_t = crate::__mlibc_fsid;
+
+s! {
+    pub struct Elf32_Phdr {
+        pub p_type: Elf32_Word,
+        pub p_offset: Elf32_Off,
+        pub p_vaddr: Elf32_Addr,
+        pub p_paddr: Elf32_Addr,
+        pub p_filesz: Elf32_Word,
+        pub p_memsz: Elf32_Word,
+        pub p_flags: Elf32_Word,
+        pub p_align: Elf32_Word,
+    }
+
+    pub struct Elf64_Phdr {
+        pub p_type: Elf64_Word,
+        pub p_flags: Elf64_Word,
+        pub p_offset: Elf64_Off,
+        pub p_vaddr: Elf64_Addr,
+        pub p_paddr: Elf64_Addr,
+        pub p_filesz: Elf64_Xword,
+        pub p_memsz: Elf64_Xword,
+        pub p_align: Elf64_Xword,
+    }
+
+    pub struct dl_phdr_info {
+        #[cfg(target_pointer_width = "64")]
+        pub dlpi_addr: Elf64_Addr,
+        #[cfg(target_pointer_width = "32")]
+        pub dlpi_addr: Elf32_Addr,
+
+        pub dlpi_name: *const c_char,
+
+        #[cfg(target_pointer_width = "64")]
+        pub dlpi_phdr: *const Elf64_Phdr,
+        #[cfg(target_pointer_width = "32")]
+        pub dlpi_phdr: *const Elf32_Phdr,
+
+        #[cfg(target_pointer_width = "64")]
+        pub dlpi_phnum: Elf64_Half,
+        #[cfg(target_pointer_width = "32")]
+        pub dlpi_phnum: Elf32_Half,
+
+        pub dlpi_adds: c_ulonglong,
+        pub dlpi_subs: c_ulonglong,
+        pub dlpi_tls_modid: size_t,
+        pub dlpi_tls_data: *mut c_void,
+    }
+
+    pub struct cpu_set_t {
+        pub bits: [c_ulong; 16],
+    }
+
+    pub struct ipc_perm {
+        pub __ipc_perm_key: crate::key_t,
+        pub uid: crate::uid_t,
+        pub gid: crate::gid_t,
+        pub cuid: crate::uid_t,
+        pub cgid: crate::gid_t,
+        pub mode: crate::mode_t,
+        pub __ipc_perm_seq: c_int,
+        pub __unused: [c_long; 2],
+    }
+
+    pub struct semid_ds {
+        pub sem_perm: crate::ipc_perm,
+        pub sem_otime: crate::time_t,
+        pub sem_ctime: crate::time_t,
+        pub sem_nsems: c_ulong,
+    }
+
+    pub struct msqid_ds {
+        pub msg_perm: crate::ipc_perm,
+        pub msg_stime: crate::time_t,
+        pub msg_rtime: crate::time_t,
+        pub msg_ctime: crate::time_t,
+        pub msg_cbytes: c_ulong,
+        pub msg_qnum: crate::msgqnum_t,
+        pub msg_qbytes: crate::msglen_t,
+        pub msg_lspid: crate::pid_t,
+        pub msg_lrpid: crate::pid_t,
+        pub __unused: [c_ulong; 2],
+    }
+
+    pub struct shmid_ds {
+        pub shm_perm: crate::ipc_perm,
+        pub shm_segsz: crate::size_t,
+        pub shm_atime: crate::time_t,
+        pub shm_dtime: crate::time_t,
+        pub shm_ctime: crate::time_t,
+        pub shm_cpid: crate::pid_t,
+        pub shm_lpid: crate::pid_t,
+        pub shm_nattch: c_ulong,
+        pub __unused: [c_ulong; 2],
+    }
+
+    pub struct dirent {
+        pub d_ino: crate::ino_t,
+        pub d_off: crate::off_t,
+        pub d_reclen: crate::reclen_t,
+        pub d_type: c_uchar,
+        pub d_name: [c_char; 256],
+    }
+    pub struct flock {
+        pub l_type: c_short,
+        pub l_whence: c_short,
+        pub l_start: crate::off_t,
+        pub l_len: crate::off_t,
+        pub l_pid: crate::pid_t,
+    }
+    pub struct msghdr {
+        pub msg_name: *mut c_void,
+        pub msg_namelen: crate::socklen_t,
+        pub msg_iov: *mut crate::iovec,
+        pub msg_iovlen: c_int,
+        pub __pad0: c_int,
+        pub msg_control: *mut c_void,
+        pub msg_controllen: crate::socklen_t,
+        pub __pad1: c_int,
+        pub msg_flags: c_int,
+    }
+    pub struct cmsghdr {
+        pub cmsg_len: crate::socklen_t,
+        pub __pad: c_int,
+        pub cmsg_level: c_int,
+        pub cmsg_type: c_int,
+    }
+    pub struct sigset_t {
+        pub __sig: [c_ulong; 16],
+    }
+    pub struct siginfo_t {
+        pub si_signo: c_int,
+        pub si_errno: c_int,
+        pub si_code: c_int,
+        pub __si_fields: [c_char; 116],
+        pub __si_align: [usize; 0],
+    }
+    pub struct __stack {
+        pub ss_sp: *mut c_void,
+        pub ss_flags: c_int,
+        pub ss_size: crate::size_t,
+    }
+    pub struct __mlibc_threadattr {
+        #[doc(hidden)]
+        size: [u8; 200],
+    }
+    pub struct __mlibc_mutex {
+        #[doc(hidden)]
+        size: [u8; 16],
+    }
+    pub struct __mlibc_mutexattr {
+        #[doc(hidden)]
+        size: [u8; 20],
+    }
+    pub struct __mlibc_cond {
+        #[doc(hidden)]
+        size: [u8; 12],
+    }
+    pub struct __mlibc_condattr {
+        #[doc(hidden)]
+        size: [u8; 8],
+    }
+    pub struct __mlibc_barrier {
+        #[doc(hidden)]
+        size: [u8; 20],
+    }
+    pub struct __mlibc_barrierattr_struct {
+        #[doc(hidden)]
+        size: [u8; 4],
+    }
+    pub struct __mlibc_fair_rwlock {
+        #[doc(hidden)]
+        size: [u8; 12],
+    }
+    pub struct __mlibc_rwlockattr {
+        #[doc(hidden)]
+        size: [u8; 4],
+    }
+    pub struct __mlibc_spinlock {
+        #[doc(hidden)]
+        size: [u8; 4],
+    }
+    // FIXME(1.0): This should not implement `PartialEq`
+    #[allow(unpredictable_function_pointer_comparisons)]
+    pub struct sigaction {
+        pub sa_sigaction: sighandler_t,
+        pub sa_flags: c_ulong,
+        pub sa_restorer: Option<unsafe extern "C" fn()>,
+        pub sa_mask: crate::sigset_t,
+    }
+    pub struct passwd {
+        pub pw_name: *mut c_char,
+        pub pw_passwd: *mut c_char,
+        pub pw_uid: crate::uid_t,
+        pub pw_gid: crate::gid_t,
+        pub pw_gecos: *mut c_char,
+        pub pw_dir: *mut c_char,
+        pub pw_shell: *mut c_char,
+    }
+    pub struct __mlibc_fsid {
+        pub __val: [c_int; 2],
+    }
+    pub struct statfs {
+        pub f_type: c_ulong,
+        pub f_bsize: c_ulong,
+        pub f_blocks: crate::fsblkcnt_t,
+        pub f_bfree: crate::fsblkcnt_t,
+        pub f_bavail: crate::fsblkcnt_t,
+        pub f_files: crate::fsfilcnt_t,
+        pub f_ffree: crate::fsfilcnt_t,
+        pub f_fsid: crate::fsid_t,
+        pub f_namelen: c_ulong,
+        pub f_frsize: c_ulong,
+        pub f_flags: c_ulong,
+        pub __f_spare: [c_ulong; 4],
+    }
+    pub struct statvfs {
+        pub f_bsize: c_ulong,
+        pub f_frsize: c_ulong,
+        pub f_blocks: crate::fsblkcnt_t,
+        pub f_bfree: crate::fsblkcnt_t,
+        pub f_bavail: crate::fsblkcnt_t,
+        pub f_files: crate::fsfilcnt_t,
+        pub f_ffree: crate::fsfilcnt_t,
+        pub f_favail: crate::fsfilcnt_t,
+        pub f_fsid: c_ulong,
+        pub f_flag: c_ulong,
+        pub f_namemax: c_ulong,
+        pub f_spare: [c_uint; 6],
+    }
+    pub struct termios {
+        pub c_iflag: crate::tcflag_t,
+        pub c_oflag: crate::tcflag_t,
+        pub c_cflag: crate::tcflag_t,
+        pub c_lflag: crate::tcflag_t,
+        pub c_line: crate::cc_t,
+        pub c_cc: [crate::cc_t; crate::NCCS],
+        pub c_ibaud: crate::speed_t,
+        pub c_obaud: crate::speed_t,
+    }
+}
+
+s_no_extra_traits! {
+    pub struct __c_anonymous_ifru_map {
+        pub mem_start: c_ulong,
+        pub mem_end: c_ulong,
+        pub base_addr: c_ushort,
+        pub irq: c_uchar,
+        pub dma: c_uchar,
+        pub port: c_uchar,
+    }
+
+    pub union __c_anonymous_ifr_ifru {
+        pub ifru_addr: crate::sockaddr,
+        pub ifru_dstaddr: crate::sockaddr,
+        pub ifru_broadaddr: crate::sockaddr,
+        pub ifru_netmask: crate::sockaddr,
+        pub ifru_hwaddr: crate::sockaddr,
+        pub ifru_flags: c_short,
+        pub ifru_ifindex: c_int,
+        pub ifru_metric: c_int,
+        pub ifru_mtu: c_int,
+        pub ifru_map: __c_anonymous_ifru_map,
+        pub ifru_slave: [c_char; crate::IFNAMSIZ],
+        pub ifru_newname: [c_char; crate::IFNAMSIZ],
+        pub ifru_data: *mut c_char,
+    }
+
+    pub struct ifreq {
+        pub ifr_name: [c_char; crate::IFNAMSIZ],
+        pub ifr_ifru: __c_anonymous_ifr_ifru,
+    }
+
+    pub struct sockaddr_nl {
+        pub nl_family: crate::sa_family_t,
+        nl_pad: c_ushort,
+        pub nl_pid: u32,
+        pub nl_groups: u32,
+    }
+}
+
+f! {
+    pub fn CMSG_NXTHDR(mhdr: *const msghdr, cmsg: *const cmsghdr) -> *mut cmsghdr {
+        if ((*cmsg).cmsg_len as usize) < size_of::<cmsghdr>() {
+            return core::ptr::null_mut::<cmsghdr>();
+        }
+        let next = (cmsg as usize + super::CMSG_ALIGN((*cmsg).cmsg_len as usize)) as *mut cmsghdr;
+        let max = (*mhdr).msg_control as usize + (*mhdr).msg_controllen as usize;
+        if (next.wrapping_offset(1)) as usize > max
+            || next as usize + super::CMSG_ALIGN((*next).cmsg_len as usize) > max
+        {
+            core::ptr::null_mut::<cmsghdr>()
+        } else {
+            next
+        }
+    }
+}
+
+safe_f! {
+    pub const fn makedev(major: c_uint, minor: c_uint) -> crate::dev_t {
+        let major = major as crate::dev_t;
+        let minor = minor as crate::dev_t;
+        let mut dev = 0;
+        dev |= (major & 0x00000fff) << 8;
+        dev |= (major & 0xfffff000) << 32;
+        dev |= (minor & 0x000000ff) << 0;
+        dev |= (minor & 0xffffff00) << 12;
+        dev
+    }
+
+    pub const fn major(dev: crate::dev_t) -> c_uint {
+        let mut major = 0;
+        major |= (dev & 0x00000000000fff00) >> 8;
+        major |= (dev & 0xfffff00000000000) >> 32;
+        major as c_uint
+    }
+
+    pub const fn minor(dev: crate::dev_t) -> c_uint {
+        let mut minor = 0;
+        minor |= (dev & 0x00000000000000ff) >> 0;
+        minor |= (dev & 0x00000ffffff00000) >> 12;
+        minor as c_uint
+    }
+}
+
+impl siginfo_t {
+    pub unsafe fn si_status(&self) -> c_int {
+        #[repr(C)]
+        struct siginfo_sigchld {
+            _si_signo: c_int,
+            _si_errno: c_int,
+            _si_code: c_int,
+            si_pid: crate::pid_t,
+            si_uid: crate::uid_t,
+            si_status: c_int,
+            si_utime: crate::clock_t,
+            si_stime: crate::clock_t,
+        }
+        (*(self as *const siginfo_t).cast::<siginfo_sigchld>()).si_status
+    }
+
+    pub unsafe fn si_addr(&self) -> *mut c_void {
+        #[repr(C)]
+        struct siginfo_sigfault {
+            _si_signo: c_int,
+            _si_errno: c_int,
+            _si_code: c_int,
+            si_addr: *mut c_void,
+        }
+        (*(self as *const siginfo_t).cast::<siginfo_sigfault>()).si_addr
+    }
+}
+
+pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t { size: [0; 16] };
+pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t { size: [0; 12] };
+pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t { size: [0; 12] };
+
+pub const RTLD_DEFAULT: *mut c_void = 0i64 as *mut c_void;
+pub const RLIM_INFINITY: crate::rlim_t = !0;
+
+// linux/netlink.h
+pub const NLA_ALIGNTO: c_int = 4;
+
+pub const NETLINK_ROUTE: c_int = 0;
+pub const NETLINK_UNUSED: c_int = 1;
+pub const NETLINK_USERSOCK: c_int = 2;
+pub const NETLINK_FIREWALL: c_int = 3;
+pub const NETLINK_SOCK_DIAG: c_int = 4;
+pub const NETLINK_NFLOG: c_int = 5;
+pub const NETLINK_XFRM: c_int = 6;
+pub const NETLINK_SELINUX: c_int = 7;
+pub const NETLINK_ISCSI: c_int = 8;
+pub const NETLINK_AUDIT: c_int = 9;
+pub const NETLINK_FIB_LOOKUP: c_int = 10;
+pub const NETLINK_CONNECTOR: c_int = 11;
+pub const NETLINK_NETFILTER: c_int = 12;
+pub const NETLINK_IP6_FW: c_int = 13;
+pub const NETLINK_DNRTMSG: c_int = 14;
+pub const NETLINK_KOBJECT_UEVENT: c_int = 15;
+pub const NETLINK_GENERIC: c_int = 16;
+pub const NETLINK_SCSITRANSPORT: c_int = 18;
+pub const NETLINK_ECRYPTFS: c_int = 19;
+pub const NETLINK_RDMA: c_int = 20;
+pub const NETLINK_CRYPTO: c_int = 21;
+pub const NETLINK_INET_DIAG: c_int = NETLINK_SOCK_DIAG;
+
+pub const NLM_F_REQUEST: c_int = 1;
+pub const NLM_F_MULTI: c_int = 2;
+pub const NLM_F_ACK: c_int = 4;
+pub const NLM_F_ECHO: c_int = 8;
+pub const NLM_F_DUMP_INTR: c_int = 16;
+pub const NLM_F_DUMP_FILTERED: c_int = 32;
+
+pub const NLM_F_ROOT: c_int = 0x100;
+pub const NLM_F_MATCH: c_int = 0x200;
+pub const NLM_F_ATOMIC: c_int = 0x400;
+pub const NLM_F_DUMP: c_int = NLM_F_ROOT | NLM_F_MATCH;
+
+pub const NLM_F_REPLACE: c_int = 0x100;
+pub const NLM_F_EXCL: c_int = 0x200;
+pub const NLM_F_CREATE: c_int = 0x400;
+pub const NLM_F_APPEND: c_int = 0x800;
+
+pub const NLM_F_NONREC: c_int = 0x100;
+pub const NLM_F_BULK: c_int = 0x200;
+
+pub const NLM_F_CAPPED: c_int = 0x100;
+pub const NLM_F_ACK_TLVS: c_int = 0x200;
+
+pub const NETLINK_ADD_MEMBERSHIP: c_int = 1;
+pub const NETLINK_DROP_MEMBERSHIP: c_int = 2;
+pub const NETLINK_PKTINFO: c_int = 3;
+pub const NETLINK_BROADCAST_ERROR: c_int = 4;
+pub const NETLINK_NO_ENOBUFS: c_int = 5;
+pub const NETLINK_RX_RING: c_int = 6;
+pub const NETLINK_TX_RING: c_int = 7;
+pub const NETLINK_LISTEN_ALL_NSID: c_int = 8;
+pub const NETLINK_LIST_MEMBERSHIPS: c_int = 9;
+pub const NETLINK_CAP_ACK: c_int = 10;
+pub const NETLINK_EXT_ACK: c_int = 11;
+pub const NETLINK_GET_STRICT_CHK: c_int = 12;
+
+pub const NLA_F_NESTED: c_int = 1 << 15;
+pub const NLA_F_NET_BYTEORDER: c_int = 1 << 14;
+pub const NLA_TYPE_MASK: c_int = !(NLA_F_NESTED | NLA_F_NET_BYTEORDER);
+
+pub const EPERM: c_int = 1;
+pub const ENOENT: c_int = 2;
+pub const ESRCH: c_int = 3;
+pub const EINTR: c_int = 4;
+pub const EIO: c_int = 5;
+pub const ENXIO: c_int = 6;
+pub const E2BIG: c_int = 7;
+pub const ENOEXEC: c_int = 8;
+pub const EBADF: c_int = 9;
+pub const ECHILD: c_int = 10;
+pub const EAGAIN: c_int = 11;
+pub const ENOMEM: c_int = 12;
+pub const EACCES: c_int = 13;
+pub const EFAULT: c_int = 14;
+pub const ENOTBLK: c_int = 15;
+pub const EBUSY: c_int = 16;
+pub const EEXIST: c_int = 17;
+pub const EXDEV: c_int = 18;
+pub const ENODEV: c_int = 19;
+pub const ENOTDIR: c_int = 20;
+pub const EISDIR: c_int = 21;
+pub const EINVAL: c_int = 22;
+pub const ENFILE: c_int = 23;
+pub const EMFILE: c_int = 24;
+pub const ENOTTY: c_int = 25;
+pub const ETXTBSY: c_int = 26;
+pub const EFBIG: c_int = 27;
+pub const ENOSPC: c_int = 28;
+pub const ESPIPE: c_int = 29;
+pub const EROFS: c_int = 30;
+pub const EMLINK: c_int = 31;
+pub const EPIPE: c_int = 32;
+pub const EDOM: c_int = 33;
+pub const ERANGE: c_int = 34;
+pub const EDEADLK: c_int = 35;
+pub const ENAMETOOLONG: c_int = 36;
+pub const ENOLCK: c_int = 37;
+pub const ENOSYS: c_int = 38;
+pub const ENOTEMPTY: c_int = 39;
+pub const ELOOP: c_int = 40;
+pub const EWOULDBLOCK: c_int = EAGAIN;
+pub const ENOMSG: c_int = 42;
+pub const EIDRM: c_int = 43;
+pub const ECHRNG: c_int = 44;
+pub const EL2NSYNC: c_int = 45;
+pub const EL3HLT: c_int = 46;
+pub const EL3RST: c_int = 47;
+pub const ELNRNG: c_int = 48;
+pub const EUNATCH: c_int = 49;
+pub const ENOCSI: c_int = 50;
+pub const EL2HLT: c_int = 51;
+pub const EBADE: c_int = 52;
+pub const EBADR: c_int = 53;
+pub const EXFULL: c_int = 54;
+pub const ENOANO: c_int = 55;
+pub const EBADRQC: c_int = 56;
+pub const EBADSLT: c_int = 57;
+pub const EDEADLOCK: c_int = EDEADLK;
+pub const EBFONT: c_int = 59;
+pub const ENOSTR: c_int = 60;
+pub const ENODATA: c_int = 61;
+pub const ETIME: c_int = 62;
+pub const ENOSR: c_int = 63;
+pub const ENONET: c_int = 64;
+pub const ENOPKG: c_int = 65;
+pub const EREMOTE: c_int = 66;
+pub const ENOLINK: c_int = 67;
+pub const EADV: c_int = 68;
+pub const ESRMNT: c_int = 69;
+pub const ECOMM: c_int = 70;
+pub const EPROTO: c_int = 71;
+pub const EMULTIHOP: c_int = 72;
+pub const EDOTDOT: c_int = 73;
+pub const EBADMSG: c_int = 74;
+pub const EOVERFLOW: c_int = 75;
+pub const ENOTUNIQ: c_int = 76;
+pub const EBADFD: c_int = 77;
+pub const EREMCHG: c_int = 78;
+pub const ELIBACC: c_int = 79;
+pub const ELIBBAD: c_int = 80;
+pub const ELIBSCN: c_int = 81;
+pub const ELIBMAX: c_int = 82;
+pub const ELIBEXEC: c_int = 83;
+pub const EILSEQ: c_int = 84;
+pub const ERESTART: c_int = 85;
+pub const ESTRPIPE: c_int = 86;
+pub const EUSERS: c_int = 87;
+pub const ENOTSOCK: c_int = 88;
+pub const EDESTADDRREQ: c_int = 89;
+pub const EMSGSIZE: c_int = 90;
+pub const EPROTOTYPE: c_int = 91;
+pub const ENOPROTOOPT: c_int = 92;
+pub const EPROTONOSUPPORT: c_int = 93;
+pub const ESOCKTNOSUPPORT: c_int = 94;
+pub const EOPNOTSUPP: c_int = 95;
+pub const ENOTSUP: c_int = EOPNOTSUPP;
+pub const EPFNOSUPPORT: c_int = 96;
+pub const EAFNOSUPPORT: c_int = 97;
+pub const EADDRINUSE: c_int = 98;
+pub const EADDRNOTAVAIL: c_int = 99;
+pub const ENETDOWN: c_int = 100;
+pub const ENETUNREACH: c_int = 101;
+pub const ENETRESET: c_int = 102;
+pub const ECONNABORTED: c_int = 103;
+pub const ECONNRESET: c_int = 104;
+pub const ENOBUFS: c_int = 105;
+pub const EISCONN: c_int = 106;
+pub const ENOTCONN: c_int = 107;
+pub const ESHUTDOWN: c_int = 108;
+pub const ETOOMANYREFS: c_int = 109;
+pub const ETIMEDOUT: c_int = 110;
+pub const ECONNREFUSED: c_int = 111;
+pub const EHOSTDOWN: c_int = 112;
+pub const EHOSTUNREACH: c_int = 113;
+pub const EALREADY: c_int = 114;
+pub const EINPROGRESS: c_int = 115;
+pub const ESTALE: c_int = 116;
+pub const EUCLEAN: c_int = 117;
+pub const ENOTNAM: c_int = 118;
+pub const ENAVAIL: c_int = 119;
+pub const EISNAM: c_int = 120;
+pub const EREMOTEIO: c_int = 121;
+pub const EDQUOT: c_int = 122;
+pub const ENOMEDIUM: c_int = 123;
+pub const EMEDIUMTYPE: c_int = 124;
+pub const ECANCELED: c_int = 125;
+pub const ENOKEY: c_int = 126;
+pub const EKEYEXPIRED: c_int = 127;
+pub const EKEYREVOKED: c_int = 128;
+pub const EKEYREJECTED: c_int = 129;
+pub const EOWNERDEAD: c_int = 130;
+pub const ENOTRECOVERABLE: c_int = 131;
+pub const ERFKILL: c_int = 132;
+pub const EHWPOISON: c_int = 133;
+pub const O_PATH: c_int = 0o10000000;
+pub const O_ACCMODE: c_int = 0o3 | O_PATH;
+pub const O_CREAT: c_int = 0o100;
+pub const O_EXCL: c_int = 0o200;
+pub const O_NOCTTY: c_int = 0o400;
+pub const O_TRUNC: c_int = 0o1000;
+pub const O_APPEND: c_int = 0o2000;
+pub const O_NONBLOCK: c_int = 0o4000;
+pub const O_DSYNC: c_int = 0o10000;
+pub const O_ASYNC: c_int = 0o20000;
+pub const O_CLOEXEC: c_int = 0o2000000;
+pub const O_SYNC: c_int = 0o4010000;
+pub const F_GETLK64: c_int = 5;
+pub const F_SETLK64: c_int = 6;
+pub const F_SETLKW64: c_int = 7;
+pub const F_GETLK: c_int = F_GETLK64;
+pub const F_SETLK: c_int = F_SETLK64;
+pub const F_SETLKW: c_int = F_SETLKW64;
+pub const F_RDLCK: c_int = 0;
+pub const F_WRLCK: c_int = 1;
+pub const F_UNLCK: c_int = 2;
+pub const AT_EACCESS: c_int = 0x200;
+pub const POSIX_FADV_DONTNEED: c_int = 4;
+pub const POSIX_FADV_NOREUSE: c_int = 5;
+pub const _SC_PAGE_SIZE: c_int = 30;
+pub const _SC_PAGESIZE: c_int = _SC_PAGE_SIZE;
+pub const _SC_GETPW_R_SIZE_MAX: c_int = 70;
+pub const _SC_HOST_NAME_MAX: c_int = 180;
+pub const O_NDELAY: c_int = O_NONBLOCK;
+pub const FALLOC_FL_KEEP_SIZE: c_int = 1;
+pub const FALLOC_FL_PUNCH_HOLE: c_int = 2;
+pub const SOCK_STREAM: c_int = 1;
+pub const SOCK_DGRAM: c_int = 2;
+pub const SOCK_NONBLOCK: c_int = 0o4000;
+pub const SO_REUSEADDR: c_int = 2;
+pub const SO_ERROR: c_int = 4;
+pub const SO_BROADCAST: c_int = 6;
+pub const SO_LINGER: c_int = 13;
+pub const SO_RCVTIMEO: c_int = 20;
+pub const SO_SNDTIMEO: c_int = 21;
+pub const SO_PASSCRED: c_int = 16;
+pub const SO_TIMESTAMP: c_int = 29;
+pub const SOL_SOCKET: c_int = 1;
+pub const SOMAXCONN: c_int = 128;
+pub const EAI_SYSTEM: c_int = 9;
+pub const SA_NOCLDSTOP: c_ulong = 1;
+pub const SA_NOCLDWAIT: c_ulong = 2;
+pub const SA_SIGINFO: c_ulong = 4;
+pub const SA_ONSTACK: c_ulong = 0x08000000;
+pub const SA_RESTART: c_ulong = 0x10000000;
+pub const SA_NODEFER: c_ulong = 0x40000000;
+pub const SA_RESETHAND: c_ulong = 0x80000000;
+pub const SA_RESTORER: c_ulong = 0x04000000;
+pub const SA_NOMASK: c_ulong = SA_NODEFER;
+pub const SA_ONESHOT: c_ulong = SA_RESETHAND;
+pub const SIGPROF: c_int = 27;
+pub const SIGIO: c_int = 29;
+pub const SIGPWR: c_int = 30;
+pub const SIG_BLOCK: c_int = 0;
+pub const SIG_UNBLOCK: c_int = 1;
+pub const SIG_SETMASK: c_int = 2;
+pub const SIGBUS: c_int = 7;
+pub const SIGUSR1: c_int = 10;
+pub const SIGUSR2: c_int = 12;
+pub const SIGCHLD: c_int = 17;
+pub const SIGCONT: c_int = 18;
+pub const SIGSTOP: c_int = 19;
+pub const SIGTSTP: c_int = 20;
+pub const SIGTTIN: c_int = 21;
+pub const SIGTTOU: c_int = 22;
+pub const SIGURG: c_int = 23;
+pub const SIGXCPU: c_int = 24;
+pub const SIGXFSZ: c_int = 25;
+pub const SIGVTALRM: c_int = 26;
+pub const SIGWINCH: c_int = 28;
+pub const SIGSYS: c_int = 31;
+pub const __MLIBC_THREAD_MUTEX_NORMAL: c_int = 0;
+pub const POLLWRNORM: c_short = 0x0100;
+pub const POLLWRBAND: c_short = 0x0200;
+pub const PTHREAD_MUTEX_NORMAL: c_int = __MLIBC_THREAD_MUTEX_NORMAL;
+pub const PTHREAD_STACK_MIN: usize = 16384;
+pub const EPOLL_CLOEXEC: c_int = 0o2000000;
+pub const EFD_CLOEXEC: c_int = O_CLOEXEC;
+pub const EFD_NONBLOCK: c_int = O_NONBLOCK;
+pub const TIOCEXCL: crate::Ioctl = 0x540C;
+pub const TIOCNXCL: crate::Ioctl = 0x540D;
+pub const FIONREAD: crate::Ioctl = 0x541B;
+pub const FIONBIO: crate::Ioctl = 0x5421;
+pub const MAP_ANON: c_int = 0x20;
+pub const POSIX_MADV_SEQUENTIAL: c_int = 2;
+pub const ST_RDONLY: c_ulong = 1;
+pub const ST_NOSUID: c_ulong = 2;
+pub const ST_NODEV: c_ulong = 4;
+pub const ST_NOEXEC: c_ulong = 8;
+pub const ST_SYNCHRONOUS: c_ulong = 16;
+pub const ST_MANDLOCK: c_ulong = 64;
+pub const ST_WRITE: c_ulong = 128;
+pub const ST_APPEND: c_ulong = 256;
+pub const ST_IMMUTABLE: c_ulong = 512;
+pub const ST_NOATIME: c_ulong = 1024;
+pub const ST_NODIRATIME: c_ulong = 2048;
+pub const NCCS: usize = 32;
+pub const VINTR: c_int = 0;
+pub const VQUIT: c_int = 1;
+pub const VERASE: c_int = 2;
+pub const VKILL: c_int = 3;
+pub const VEOF: usize = 4;
+pub const VTIME: usize = 5;
+pub const VMIN: usize = 6;
+pub const VSWTC: usize = 7;
+pub const VSTART: usize = 8;
+pub const VSTOP: usize = 9;
+pub const VSUSP: usize = 10;
+pub const VEOL: usize = 11;
+pub const VREPRINT: usize = 12;
+pub const VDISCARD: usize = 13;
+pub const VWERASE: usize = 14;
+pub const VLNEXT: c_int = 15;
+pub const VEOL2: usize = 16;
+pub const IGNBRK: c_int = 0o000001;
+pub const BRKINT: c_int = 0o000002;
+pub const IGNPAR: c_int = 0o000004;
+pub const PARMRK: c_int = 0o000010;
+pub const INPCK: c_int = 0o000020;
+pub const ISTRIP: c_int = 0o000040;
+pub const INLCR: c_int = 0o000100;
+pub const IGNCR: c_int = 0o000200;
+pub const ICRNL: c_int = 0o000400;
+pub const IUCLC: crate::tcflag_t = 0o001000;
+pub const IXON: crate::tcflag_t = 0o002000;
+pub const IXANY: c_int = 0o004000;
+pub const IXOFF: crate::tcflag_t = 0o010000;
+pub const IMAXBEL: c_int = 0o020000;
+pub const IUTF8: crate::tcflag_t = 0o040000;
+pub const OPOST: c_int = 0o000001;
+pub const OLCUC: crate::tcflag_t = 0o000002;
+pub const ONLCR: crate::tcflag_t = 0o000004;
+pub const OCRNL: c_int = 0o000010;
+pub const ONOCR: c_int = 0o000020;
+pub const ONLRET: c_int = 0o000040;
+pub const OFILL: c_int = 0o000100;
+pub const OFDEL: c_int = 0o000200;
+pub const NLDLY: crate::tcflag_t = 0o000400;
+pub const NL0: c_int = 0o000000;
+pub const NL1: c_int = 0o000400;
+pub const CRDLY: crate::tcflag_t = 0o003000;
+pub const CR0: c_int = 0o000000;
+pub const CR1: crate::tcflag_t = 0o001000;
+pub const CR2: crate::tcflag_t = 0o002000;
+pub const CR3: crate::tcflag_t = 0o003000;
+pub const TABDLY: crate::tcflag_t = 0o014000;
+pub const TAB0: c_int = 0o000000;
+pub const TAB1: crate::tcflag_t = 0o004000;
+pub const TAB2: crate::tcflag_t = 0o010000;
+pub const TAB3: crate::tcflag_t = 0o014000;
+pub const BSDLY: crate::tcflag_t = 0o020000;
+pub const BS0: c_int = 0o000000;
+pub const BS1: crate::tcflag_t = 0o020000;
+pub const FFDLY: crate::tcflag_t = 0o100000;
+pub const FF0: c_int = 0o000000;
+pub const FF1: crate::tcflag_t = 0o100000;
+pub const VTDLY: crate::tcflag_t = 0o040000;
+pub const VT0: c_int = 0o000000;
+pub const VT1: crate::tcflag_t = 0o040000;
+pub const CSIZE: crate::tcflag_t = 0o000060;
+pub const CS5: c_int = 0o000000;
+pub const CS6: crate::tcflag_t = 0o000020;
+pub const CS7: crate::tcflag_t = 0o000040;
+pub const CS8: crate::tcflag_t = 0o000060;
+pub const CSTOPB: crate::tcflag_t = 0o000100;
+pub const CREAD: crate::tcflag_t = 0o000200;
+pub const PARENB: crate::tcflag_t = 0o000400;
+pub const PARODD: crate::tcflag_t = 0o001000;
+pub const HUPCL: crate::tcflag_t = 0o002000;
+pub const CLOCAL: crate::tcflag_t = 0o004000;
+pub const ISIG: crate::tcflag_t = 0o000001;
+pub const ICANON: crate::tcflag_t = 0o000002;
+pub const ECHO: c_int = 0o000010;
+pub const ECHOE: crate::tcflag_t = 0o000020;
+pub const ECHOK: crate::tcflag_t = 0o000040;
+pub const ECHONL: crate::tcflag_t = 0o000100;
+pub const NOFLSH: crate::tcflag_t = 0o000200;
+pub const TOSTOP: crate::tcflag_t = 0o000400;
+pub const IEXTEN: crate::tcflag_t = 0o100000;
+pub const EXTA: crate::speed_t = 0o000016;
+pub const EXTB: crate::speed_t = 0o000017;
+pub const CBAUD: crate::tcflag_t = 0o010017;
+pub const CBAUDEX: crate::tcflag_t = 0o010000;
+pub const CIBAUD: crate::tcflag_t = 0o02003600000;
+pub const CMSPAR: crate::tcflag_t = 0o10000000000;
+pub const CRTSCTS: c_int = 0o20000000000;
+pub const XCASE: crate::tcflag_t = 0o000004;
+pub const ECHOCTL: crate::tcflag_t = 0o001000;
+pub const ECHOPRT: crate::tcflag_t = 0o002000;
+pub const ECHOKE: crate::tcflag_t = 0o004000;
+pub const FLUSHO: crate::tcflag_t = 0o010000;
+pub const PENDIN: crate::tcflag_t = 0o040000;
+pub const EXTPROC: crate::tcflag_t = 0o200000;
+pub const XTABS: crate::tcflag_t = 0o014000;
+pub const B0: crate::speed_t = 0;
+pub const B50: crate::speed_t = 1;
+pub const B75: crate::speed_t = 2;
+pub const B110: crate::speed_t = 3;
+pub const B134: crate::speed_t = 4;
+pub const B150: crate::speed_t = 5;
+pub const B200: crate::speed_t = 6;
+pub const B300: crate::speed_t = 7;
+pub const B600: crate::speed_t = 8;
+pub const B1200: crate::speed_t = 9;
+pub const B1800: crate::speed_t = 10;
+pub const B2400: crate::speed_t = 11;
+pub const B4800: crate::speed_t = 12;
+pub const B9600: crate::speed_t = 13;
+pub const B19200: crate::speed_t = 14;
+pub const B38400: crate::speed_t = 15;
+pub const B57600: crate::speed_t = 0o010001;
+pub const B115200: crate::speed_t = 0o010002;
+pub const B230400: crate::speed_t = 0o010003;
+pub const B460800: crate::speed_t = 0o010004;
+pub const B500000: crate::speed_t = 0o010005;
+pub const B576000: crate::speed_t = 0o010006;
+pub const B921600: crate::speed_t = 0o010007;
+pub const B1000000: crate::speed_t = 0o010010;
+pub const B1152000: crate::speed_t = 0o010011;
+pub const B1500000: crate::speed_t = 0o010012;
+pub const B2000000: crate::speed_t = 0o010013;
+pub const B2500000: crate::speed_t = 0o010014;
+pub const B3000000: crate::speed_t = 0o010015;
+pub const B3500000: crate::speed_t = 0o010016;
+pub const B4000000: crate::speed_t = 0o010017;
+pub const TCSANOW: c_int = 0;
+pub const TCSADRAIN: c_int = 1;
+pub const TCSAFLUSH: c_int = 2;
+pub const TIOCGWINSZ: crate::Ioctl = 0x5413;
+pub const TIOCSWINSZ: crate::Ioctl = 0x5414;
+extern "C" {
+    #[link_name = "__gnu_strerror_r"]
+    pub fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: size_t) -> c_int;
+
+    /// POSIX version of `basename(3)`, defined in `libgen.h`.
+    #[link_name = "basename"]
+    pub fn posix_basename(path: *mut c_char) -> *mut c_char;
+    /// GNU version of `basename(3)`, defined in `string.h`.
+    #[link_name = "__mlibc_gnu_basename_c"]
+    pub fn gnu_basename(path: *const c_char) -> *mut c_char;
+
+    pub fn msgctl(msqid: c_int, cmd: c_int, buf: *mut crate::msqid_ds) -> c_int;
+    pub fn seekdir(dirp: *mut crate::DIR, loc: c_long);
+    pub fn __errno_location() -> *mut c_int;
+    pub fn mkfifoat(dirfd: c_int, pathname: *const c_char, mode: crate::mode_t) -> c_int;
+    pub fn dup3(fd: c_int, newfd: c_int, flags: c_int) -> c_int;
+    pub fn faccessat(fd: c_int, path: *const c_char, mode: c_int, flags: c_int) -> c_int;
+    pub fn sync();
+    pub fn posix_fallocate(fd: c_int, offset: crate::off_t, size: crate::off_t) -> c_int;
+    pub fn endgrent();
+    pub fn getgrent() -> *mut crate::group;
+    pub fn setgrent();
+    pub fn getgrgid_r(
+        gid: crate::gid_t,
+        grp: *mut crate::group,
+        buf: *mut c_char,
+        buflen: crate::size_t,
+        res: *mut *mut crate::group,
+    ) -> c_int;
+    pub fn getgrnam_r(
+        name: *const c_char,
+        grp: *mut crate::group,
+        buf: *mut c_char,
+        buflen: crate::size_t,
+        res: *mut *mut crate::group,
+    ) -> c_int;
+    pub fn getgrouplist(
+        user: *const c_char,
+        group: crate::gid_t,
+        groups: *mut crate::gid_t,
+        ngroups: *mut c_int,
+    ) -> c_int;
+    pub fn dl_iterate_phdr(
+        callback: Option<
+            unsafe extern "C" fn(*mut crate::dl_phdr_info, crate::size_t, *mut c_void) -> c_int,
+        >,
+        data: *mut c_void,
+    ) -> c_int;
+    pub fn accept4(
+        sockfd: c_int,
+        addr: *mut crate::sockaddr,
+        addrlen: *mut crate::socklen_t,
+        flags: c_int,
+    ) -> c_int;
+    pub fn recvfrom(
+        sockfd: c_int,
+        buf: *mut c_void,
+        size: crate::size_t,
+        flags: c_int,
+        src_addr: *mut crate::sockaddr,
+        addrlen: *mut crate::socklen_t,
+    ) -> crate::ssize_t;
+    pub fn sigwait(set: *const crate::sigset_t, sig: *mut c_int) -> c_int;
+    pub fn endpwent();
+    pub fn getpwent() -> *mut crate::passwd;
+    pub fn setpwent();
+    pub fn getpwnam_r(
+        name: *const c_char,
+        ret: *mut crate::passwd,
+        buf: *mut c_char,
+        buflen: crate::size_t,
+        res: *mut *mut crate::passwd,
+    ) -> c_int;
+    pub fn getpwuid_r(
+        uid: crate::uid_t,
+        ret: *mut crate::passwd,
+        buf: *mut c_char,
+        buflen: crate::size_t,
+        res: *mut *mut crate::passwd,
+    ) -> c_int;
+    pub fn epoll_create1(flags: c_int) -> c_int;
+    pub fn epoll_ctl(epfd: c_int, mode: c_int, fd: c_int, ev: *mut crate::epoll_event) -> c_int;
+    pub fn epoll_wait(
+        epfd: c_int,
+        events: *mut crate::epoll_event,
+        maxevents: c_int,
+        timeout: c_int,
+    ) -> c_int;
+    pub fn eventfd(initval: c_uint, flags: c_int) -> c_int;
+    pub fn mprotect(addr: *mut c_void, size: crate::size_t, prot: c_int) -> c_int;
+    pub fn posix_madvise(addr: *mut c_void, size: crate::size_t, advise: c_int) -> c_int;
+    pub fn msync(addr: *mut c_void, size: crate::size_t, flags: c_int) -> c_int;
+    pub fn madvise(addr: *mut c_void, size: crate::size_t, advise: c_int) -> c_int;
+    pub fn preadv(
+        fd: c_int,
+        iov: *const crate::iovec,
+        iovcnt: c_int,
+        offset: crate::off_t,
+    ) -> crate::ssize_t;
+    pub fn pwritev(
+        fd: c_int,
+        iov: *const crate::iovec,
+        iovcnt: c_int,
+        offset: crate::off_t,
+    ) -> crate::ssize_t;
+}
+
+cfg_if! {
+    if #[cfg(target_arch = "aarch64")] {
+        mod aarch64;
+        pub use self::aarch64::*;
+    } else if #[cfg(any(target_arch = "riscv64"))] {
+        mod riscv64;
+        pub use self::riscv64::*;
+    } else if #[cfg(target_arch = "x86_64")] {
+        mod x86_64;
+        pub use self::x86_64::*;
+    } else {
+        // Unknown target_arch
+    }
+}
-- 
2.52.0

